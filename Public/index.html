<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MTG Forge - Deck & Collection Manager</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
      body {
        font-family: "Inter", sans-serif;
      }
      .card-image-container {
        position: relative;
        padding-top: 140%; /* Aspect ratio for MTG cards */
      }
      .card-image {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
      }
      .modal-backdrop {
        background-color: rgba(0, 0, 0, 0.75);
      }
      /* Hide scrollbar for webkit */
      .no-scrollbar::-webkit-scrollbar {
        display: none;
      }
      /* Hide scrollbar for IE, Edge and Firefox */
      .no-scrollbar {
        -ms-overflow-style: none; /* IE and Edge */
        scrollbar-width: none; /* Firefox */
      }
      /* Master Delete Button Logic */
      .delete-button {
        display: none;
      }
      .edit-mode .delete-button {
        display: inline-flex; /* Use flex to align icon and text */
      }

      .group-header {
        background-color: #374151; /* gray-700 */
        color: #d1d5db; /* gray-300 */
        padding: 0.75rem 1.5rem;
        font-weight: bold;
        font-size: 1.25rem;
        margin-top: 1.5rem;
        border-bottom: 3px solid #4f46e5; /* indigo-600 */
        position: sticky;
        top: 72px; /* Height of header */
        z-index: 5;
      }
      /* For Table Sorting */
      .sortable {
        cursor: pointer;
      }
      .sortable:hover {
        color: #a78bfa;
      }
      .edit-mode .sortable {
        cursor: default;
      }
      .edit-mode .sortable:hover {
        color: inherit;
      }
      .sort-asc::after {
        content: " ▲";
        font-size: 0.8em;
      }
      .sort-desc::after {
        content: " ▼";
        font-size: 0.8em;
      }
      /* Card Modal Edit Mode */
      .card-modal-value-display {
        display: block;
      }
      .card-modal-value-input {
        display: none;
      }
      .card-modal-edit-mode .card-modal-value-display {
        display: none;
      }
      .card-modal-edit-mode .card-modal-value-input {
        display: block;
      }

      .oracle-text-truncate {
        overflow: hidden;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
      }
      .kpi-gradient-bar {
        position: absolute;
        bottom: 0;
        left: 0;
        height: 4px;
        border-radius: 0 0 0.5rem 0.5rem;
        transition: width 0.5s ease-in-out;
      }
      /* Toast Notifications */
      #toast-container {
        position: fixed;
        bottom: 1.5rem;
        right: 1.5rem;
        z-index: 100;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }
      .toast {
        display: flex;
        align-items: center;
        padding: 1rem;
        border-radius: 0.5rem;
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1),
          0 4px 6px -2px rgba(0, 0, 0, 0.05);
        min-width: 300px;
        max-width: 400px;
        transform: translateX(120%);
        animation: slideIn 0.5s forwards, slideOut 0.5s 4.5s forwards;
      }
      @keyframes slideIn {
        from {
          transform: translateX(120%);
        }
        to {
          transform: translateX(0);
        }
      }
      @keyframes slideOut {
        from {
          transform: translateX(0);
        }
        to {
          transform: translateX(120%);
        }
      }

      /* Accordion styles */
      details > summary {
        list-style: none;
        cursor: pointer;
      }
      details > summary::-webkit-details-marker {
        display: none;
      }
      details summary:before {
        content: "+";
        margin-right: 0.5rem;
        font-weight: bold;
      }
      details[open] summary:before {
        content: "-";
      }
    </style>
  </head>
  <body class="bg-gray-900 text-gray-200">
    <!-- Login Screen -->
    <div
      id="login-screen"
      class="fixed inset-0 z-[100] flex items-center justify-center bg-gray-900"
    >
      <div class="p-8 bg-gray-800 rounded-lg shadow-2xl max-w-sm w-full">
        <h1
          class="text-3xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-pink-600 mb-2 text-center"
        >
          MTG Forge
        </h1>
        <p class="text-gray-400 mb-6 text-center">
          Your personal MTG collection manager.
        </p>
        <form id="email-login-form" class="space-y-4">
          <div>
            <label
              for="email"
              class="block text-sm font-medium text-left text-gray-300"
              >Email</label
            >
            <input
              type="email"
              id="email"
              required
              class="mt-1 w-full p-2 border rounded-md bg-gray-700 border-gray-600 text-white"
            />
          </div>
          <div>
            <label
              for="password"
              class="block text-sm font-medium text-left text-gray-300"
              >Password</label
            >
            <input
              type="password"
              id="password"
              required
              class="mt-1 w-full p-2 border rounded-md bg-gray-700 border-gray-600 text-white"
            />
          </div>
          <div class="flex space-x-2">
            <button
              type="button"
              id="email-login-btn"
              class="w-full bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 transition"
            >
              Login
            </button>
            <button
              type="button"
              id="signup-btn"
              class="w-full bg-gray-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-gray-500 transition"
            >
              Sign Up
            </button>
          </div>
        </form>
        <div class="relative flex py-5 items-center">
          <div class="flex-grow border-t border-gray-600"></div>
          <span class="flex-shrink mx-4 text-gray-500">Or</span>
          <div class="flex-grow border-t border-gray-600"></div>
        </div>
        <button
          id="login-with-google-btn"
          class="w-full flex items-center justify-center bg-gray-200 border border-gray-400 text-gray-800 font-bold py-3 px-4 rounded-lg hover:bg-gray-300 transition"
        >
          <svg
            class="w-5 h-5 mr-3"
            viewBox="0 0 48 48"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path
              fill-rule="evenodd"
              clip-rule="evenodd"
              d="M48 24C48 22.0435 47.2107 20.1692 45.8284 18.7869C44.4461 17.4046 42.5717 16.6152 40.6154 16.6152H24V29.5385H37.8462C37.4308 32.6154 35.8462 35.2615 33.2308 36.9231V43.8462H41.6923C45.5077 40.2462 48 34.8 48 24Z"
              fill="#4285F4"
            ></path>
            <path
              fill-rule="evenodd"
              clip-rule="evenodd"
              d="M24 48C30.6 48 36.2769 45.8769 40.6154 42.1846L33.2308 36.9231C31.1077 38.3077 28.1538 39.2308 24 39.2308C17.6308 39.2308 12.1846 34.9846 10.3385 29.2615H1.56923V36.4615C5.90769 43.4769 14.3077 48 24 48Z"
              fill="#34A853"
            ></path>
            <path
              fill-rule="evenodd"
              clip-rule="evenodd"
              d="M10.3385 29.2615C9.87692 27.8769 9.6 26.3077 9.6 24.5538C9.6 22.8 9.87692 21.2308 10.3385 19.8462V12.6462H1.56923C-0.553846 16.7077 -0.553846 21.8462 1.56923 35.9077L10.3385 29.2615Z"
              fill="#FBBC05"
            ></path>
            <path
              fill-rule="evenodd"
              clip-rule="evenodd"
              d="M24 9.87692C27.3231 9.87692 30.0923 11 32.3077 12.9231L39.8769 5.35385C35.6308 1.84615 30.0923 0 24 0C14.3077 0 5.90769 4.52308 1.56923 11.5385L10.3385 18.2308C12.1846 12.5077 17.6308 9.87692 24 9.87692Z"
              fill="#EA4335"
            ></path>
          </svg>
          Sign in with Google
        </button>
      </div>
    </div>

    <!-- Main Application Container -->
    <div id="app-wrapper" class="hidden w-full h-screen flex">
      <!-- Sidebar Navigation -->
      <nav class="w-64 bg-gray-800 flex-shrink-0 flex flex-col p-4">
        <div class="flex items-center gap-3 mb-8">
          <svg
            class="w-10 h-10 text-purple-400"
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 24 24"
            fill="currentColor"
          >
            <path
              d="M5 22V8H3V6L12 1L21 6V8H19V22H15V14H9V22H5ZM7 20H11V12H13V20H17V8.825L12 5.5L7 8.825V20Z"
            />
          </svg>
          <h1
            class="text-2xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-pink-600"
          >
            MTG Forge
          </h1>
        </div>
        <div class="space-y-2 flex-grow">
          <button
            id="nav-collection"
            class="nav-link w-full text-left flex items-center gap-3 px-3 py-2 rounded-lg bg-indigo-600 text-white"
          >
            <svg
              class="w-5 h-5"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"
              ></path>
            </svg>
            My Collection
          </button>
          <button
            id="nav-decks"
            class="nav-link w-full text-left flex items-center gap-3 px-3 py-2 rounded-lg text-gray-400 hover:bg-gray-700 hover:text-white"
          >
            <svg
              class="w-5 h-5"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z"
              ></path>
            </svg>
            Decks
          </button>
          <div class="border-t border-gray-700 my-4"></div>
          <button
            id="nav-rule-lookup"
            class="nav-link w-full text-left flex items-center gap-3 px-3 py-2 rounded-lg text-gray-400 hover:bg-gray-700 hover:text-white"
          >
            <svg
              class="w-5 h-5"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.79 4 4s-1.79 4-4 4c-1.742 0-3.223-.835-3.772-2M12 5v.01M12 19v.01"
              ></path>
            </svg>
            Rule Lookup
          </button>
          <button
            id="nav-general-chat"
            class="nav-link w-full text-left flex items-center gap-3 px-3 py-2 rounded-lg text-gray-400 hover:bg-gray-700 hover:text-white"
          >
            <svg
              class="w-5 h-5"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"
              ></path>
            </svg>
            MTG Chat
          </button>
        </div>
        <div class="space-y-2">
          <button
            id="nav-settings"
            class="nav-link w-full text-left flex items-center gap-3 px-3 py-2 rounded-lg text-gray-400 hover:bg-gray-700 hover:text-white"
          >
            <svg
              class="w-5 h-5"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"
              ></path>
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"
              ></path>
            </svg>
            Settings
          </button>
        </div>
      </nav>

      <!-- Main Content -->
      <div
        id="app-content"
        class="flex-1 flex flex-col h-screen overflow-y-auto"
      >
        <header
          class="bg-gray-800/80 backdrop-blur-sm sticky top-0 z-10 p-4 flex justify-between items-center border-b border-gray-700"
        >
          <h2 id="page-title" class="text-2xl font-bold">My Collection</h2>
          <div class="flex items-center gap-4">
            <button
              id="new-player-guide-btn"
              class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300 flex items-center gap-2"
            >
              <svg
                class="w-5 h-5"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
                xmlns="http://www.w3.org/2000/svg"
              >
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  stroke-width="2"
                  d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.79 4 4s-1.79 4-4 4c-1.742 0-3.223-.835-3.772-2M12 5v.01M12 19v.01"
                ></path>
              </svg>
              New Player Guide
            </button>
            <button
              id="edit-mode-toggle"
              class="bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300 flex items-center gap-2"
            >
              <svg
                class="w-5 h-5"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  stroke-width="2"
                  d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"
                ></path>
              </svg>
              <span id="edit-mode-text">Edit Mode</span>
            </button>
          </div>
        </header>

        <main id="main-content" class="p-6 space-y-6">
          <!-- Collection View -->
          <div id="collection-view">
            <!-- Add Card Section -->
            <div class="bg-gray-800 p-4 rounded-lg shadow-lg mb-6">
              <h3 class="text-xl font-semibold mb-4">Add Card to Collection</h3>
              <div class="flex flex-col md:flex-row gap-4">
                <input
                  type="text"
                  id="card-search-input"
                  class="flex-grow bg-gray-700 border border-gray-600 rounded-lg px-4 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500"
                  placeholder="Enter card name (e.g., Sol Ring)"
                />
                <button
                  id="search-card-btn"
                  class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300 flex items-center justify-center"
                >
                  <svg
                    id="search-icon"
                    class="w-5 h-5 mr-2"
                    fill="none"
                    stroke="currentColor"
                    viewBox="0 0 24 24"
                  >
                    <path
                      stroke-linecap="round"
                      stroke-linejoin="round"
                      stroke-width="2"
                      d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"
                    ></path>
                  </svg>
                  <span id="search-text">Search</span>
                  <div
                    id="search-spinner"
                    class="hidden animate-spin rounded-full h-5 w-5 border-b-2 border-white"
                  ></div>
                </button>
              </div>
            </div>

            <!-- Collection Filters & Grouping -->
            <div
              class="bg-gray-800 p-4 rounded-lg shadow-lg mb-6 flex flex-wrap gap-4 items-end"
            >
              <div class="flex-grow" style="min-width: 150px">
                <label for="filter-text" class="text-sm text-gray-400"
                  >Filter by Name/Type</label
                >
                <input
                  type="text"
                  id="filter-text"
                  class="w-full mt-1 bg-gray-700 border border-gray-600 rounded-lg px-4 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500"
                  placeholder="e.g., Goblin, Instant..."
                />
              </div>
              <div class="flex-grow" style="min-width: 150px">
                <label for="collection-group-by" class="text-sm text-gray-400"
                  >Group By</label
                >
                <select
                  id="collection-group-by"
                  class="w-full mt-1 bg-gray-700 border border-gray-600 rounded-lg px-4 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500"
                >
                  <option value="">None</option>
                  <option value="type_line">Type</option>
                  <option value="rarity">Rarity</option>
                  <option value="color_identity">Color</option>
                  <option value="cmc">Mana Value</option>
                  <option value="set_name">Set</option>
                </select>
              </div>
              <div class="flex items-center space-x-2">
                <input
                  type="checkbox"
                  id="hide-in-deck-checkbox"
                  class="h-4 w-4 rounded bg-gray-700 border-gray-600 text-indigo-600 focus:ring-indigo-500"
                />
                <label for="hide-in-deck-checkbox" class="text-sm text-gray-300"
                  >Hide Cards in Decks</label
                >
              </div>
              <div class="flex-shrink-0">
                <label class="text-sm text-gray-400">Grid Size</label>
                <div class="mt-1 flex items-center rounded-lg bg-gray-700 p-1">
                  <button
                    class="grid-size-btn p-2 rounded-md text-gray-400"
                    data-size="sm"
                    title="Small"
                  >
                    S
                  </button>
                  <button
                    class="grid-size-btn p-2 rounded-md bg-indigo-600 text-white"
                    data-size="md"
                    title="Medium"
                  >
                    M
                  </button>
                  <button
                    class="grid-size-btn p-2 rounded-md text-gray-400"
                    data-size="lg"
                    title="Large"
                  >
                    L
                  </button>
                </div>
              </div>
              <div class="flex-shrink-0">
                <label class="text-sm text-gray-400">View</label>
                <div class="mt-1 flex items-center rounded-lg bg-gray-700 p-1">
                  <button
                    id="view-toggle-grid"
                    class="view-toggle p-2 rounded-md bg-indigo-600 text-white"
                    title="Grid View"
                  >
                    <svg
                      class="w-5 h-5"
                      fill="none"
                      stroke="currentColor"
                      viewBox="0 0 24 24"
                    >
                      <path
                        stroke-linecap="round"
                        stroke-linejoin="round"
                        stroke-width="2"
                        d="M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z"
                      ></path>
                    </svg>
                  </button>
                  <button
                    id="view-toggle-table"
                    class="view-toggle p-2 rounded-md text-gray-400"
                    title="Table View"
                  >
                    <svg
                      class="w-5 h-5"
                      fill="none"
                      stroke="currentColor"
                      viewBox="0 0 24 24"
                    >
                      <path
                        stroke-linecap="round"
                        stroke-linejoin="round"
                        stroke-width="2"
                        d="M4 6h16M4 10h16M4 14h16M4 18h16"
                      ></path>
                    </svg>
                  </button>
                </div>
              </div>
              <button
                id="reset-filters-btn"
                class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg"
              >
                Reset
              </button>
            </div>

            <!-- Collection Content -->
            <div id="collection-content">
              <!-- Grouped or Table content will be injected here -->
            </div>
            <div
              id="collection-pagination"
              class="flex justify-center items-center space-x-2 mt-6"
            >
              <!-- Pagination controls will be injected here -->
            </div>
            <p id="no-cards-msg" class="text-center text-gray-500 mt-8">
              Your collection is empty. Use the search bar above to add cards!
            </p>
          </div>

          <!-- Decks View -->
          <div id="decks-view" class="hidden">
            <div
              class="bg-gray-800 p-4 rounded-lg shadow-lg mb-6 flex flex-col md:flex-row justify-between items-center gap-4"
            >
              <h2 class="text-2xl font-semibold">My Decks</h2>
              <button
                id="create-deck-btn"
                class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300"
              >
                Create New Deck
              </button>
            </div>
            <div
              id="decks-list"
              class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6"
            >
              <!-- Deck items will be dynamically inserted here -->
            </div>
            <p id="no-decks-msg" class="text-center text-gray-500 mt-8">
              You haven't created any decks yet. Click the button above to start
              building!
            </p>
          </div>

          <!-- Single Deck View -->
          <div id="single-deck-view" class="hidden">
            <!-- Will be populated by JS -->
          </div>

          <!-- Settings View -->
          <div id="settings-view" class="hidden space-y-8">
            <div class="bg-gray-800 p-6 rounded-lg shadow-lg">
              <h2
                class="text-2xl font-semibold mb-4 border-b border-gray-700 pb-2"
              >
                Account
              </h2>
              <div class="space-y-4">
                <div>
                  <label class="text-sm text-gray-400">User Email</label>
                  <p
                    id="user-email"
                    class="text-lg bg-gray-700 p-2 rounded-md"
                  ></p>
                </div>
                <button
                  id="logout-btn"
                  class="w-full sm:w-auto bg-red-800 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg flex items-center justify-center gap-2"
                >
                  <svg
                    class="w-5 h-5"
                    fill="none"
                    stroke="currentColor"
                    viewBox="0 0 24 24"
                  >
                    <path
                      stroke-linecap="round"
                      stroke-linejoin="round"
                      stroke-width="2"
                      d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1"
                    ></path>
                  </svg>
                  Logout
                </button>
              </div>
            </div>
            <div class="bg-gray-800 p-6 rounded-lg shadow-lg">
              <h2
                class="text-2xl font-semibold mb-4 border-b border-gray-700 pb-2"
              >
                Card Modal Display
              </h2>
              <div
                id="modal-visibility-settings"
                class="grid grid-cols-2 sm:grid-cols-3 gap-4"
              >
                <!-- Checkboxes will be injected here -->
              </div>
            </div>
            <div class="bg-gray-800 p-6 rounded-lg shadow-lg">
              <h2
                class="text-2xl font-semibold mb-4 border-b border-gray-700 pb-2"
              >
                Deck Management
              </h2>
              <p class="text-gray-400 mb-4">
                Enable "Edit Mode" from the top bar to delete decks.
              </p>
              <div id="settings-deck-list" class="space-y-4">
                <!-- Deck list for deletion will be populated here -->
              </div>
            </div>
            <div class="bg-gray-800 p-6 rounded-lg shadow-lg">
              <h2
                class="text-2xl font-semibold mb-4 border-b border-gray-700 pb-2"
              >
                Data Management
              </h2>
              <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                <button
                  id="export-all-data-btn"
                  class="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg"
                >
                  Export All Data
                </button>
                <label
                  class="flex-1 bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg cursor-pointer text-center flex items-center justify-center"
                >
                  <span>Import All Data</span>
                  <input
                    type="file"
                    id="import-all-data-input"
                    class="hidden"
                    accept=".json"
                  />
                </label>
                <button
                  id="export-deck-data-btn"
                  class="flex-1 bg-blue-800 hover:bg-blue-900 text-white font-bold py-2 px-4 rounded-lg"
                >
                  Export Active Deck
                </button>
                <label
                  class="flex-1 bg-green-800 hover:bg-green-900 text-white font-bold py-2 px-4 rounded-lg cursor-pointer text-center flex items-center justify-center"
                >
                  <span>Import Deck</span>
                  <input
                    type="file"
                    id="import-deck-data-input"
                    class="hidden"
                    accept=".json"
                  />
                </label>
              </div>
            </div>
            <div
              class="bg-red-900/50 border border-red-700 p-6 rounded-lg shadow-lg"
            >
              <h2 class="text-2xl font-semibold mb-4 text-red-300">
                Danger Zone
              </h2>
              <p class="text-red-200 mb-4">
                This action is irreversible and will permanently delete your
                entire collection and all your decks.
              </p>
              <button
                id="clear-data-btn"
                class="w-full sm:w-auto bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg"
              >
                Clear All Account Data
              </button>
            </div>
          </div>
        </main>
      </div>
    </div>

    <!-- Toast Container -->
    <div id="toast-container"></div>

    <!-- Modals -->

    <!-- Card Versions Modal (for search results) -->
    <div
      id="card-versions-modal"
      class="fixed inset-0 z-[60] hidden items-center justify-center p-4 modal-backdrop"
    >
      <div
        class="bg-gray-800 rounded-lg shadow-2xl max-w-6xl w-full h-[90vh] flex flex-col"
      >
        <div
          class="p-4 border-b border-gray-700 flex justify-between items-center"
        >
          <h3 id="card-versions-modal-title" class="text-xl font-bold">
            Select Card Version
          </h3>
          <button
            id="close-versions-modal-btn"
            class="text-gray-400 hover:text-white text-3xl"
          >
            &times;
          </button>
        </div>
        <div
          id="card-versions-grid"
          class="p-6 grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-4 overflow-y-auto no-scrollbar"
        >
          <!-- Card versions will be injected here -->
        </div>
        <div
          id="versions-loading"
          class="flex-grow flex items-center justify-center"
        >
          <div
            class="animate-spin rounded-full h-12 w-12 border-b-2 border-indigo-400"
          ></div>
        </div>
      </div>
    </div>

    <!-- Card Add Confirmation Modal -->
    <div
      id="card-confirmation-modal"
      class="fixed inset-0 z-[70] hidden items-center justify-center p-4 modal-backdrop"
    >
      <div class="bg-gray-800 rounded-lg shadow-2xl max-w-4xl w-full">
        <div
          id="card-confirmation-content"
          class="p-6 grid grid-cols-1 md:grid-cols-2 gap-6"
        >
          <!-- Content injected by JS -->
        </div>
      </div>
    </div>

    <!-- Card Details Modal -->
    <div
      id="card-details-modal"
      class="fixed inset-0 z-50 hidden items-center justify-center p-4 modal-backdrop overflow-y-auto"
    >
      <div
        id="card-details-modal-content-wrapper"
        class="bg-gray-800 rounded-lg shadow-2xl max-w-4xl w-full my-8 relative"
      >
        <div class="absolute top-2 right-4 flex items-center gap-4 z-10">
          <button
            id="edit-card-details-btn"
            class="text-gray-400 hover:text-white"
          >
            <svg
              class="w-6 h-6"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"
              ></path>
            </svg>
          </button>
          <button
            id="close-card-details-btn"
            class="text-gray-400 hover:text-white text-4xl font-bold"
          >
            &times;
          </button>
        </div>
        <div id="card-details-content" class="p-6">
          <!-- Content will be injected by JS -->
        </div>
      </div>
    </div>

    <!-- AI Suggestions Modal -->
    <div
      id="ai-suggestions-modal"
      class="fixed inset-0 z-50 hidden items-center justify-center p-4 modal-backdrop"
    >
      <div
        class="bg-gray-800 rounded-lg shadow-2xl max-w-2xl w-full h-[80vh] flex flex-col"
      >
        <div
          class="p-4 border-b border-gray-700 flex justify-between items-center"
        >
          <h3 id="ai-suggestions-title" class="text-xl font-bold">
            Gemini Deck Suggestions
          </h3>
          <button
            id="close-ai-modal-btn"
            class="text-gray-400 hover:text-white text-3xl"
          >
            &times;
          </button>
        </div>
        <div
          id="ai-chat-history"
          class="flex-grow p-4 space-y-4 overflow-y-auto no-scrollbar"
        >
          <!-- Chat messages will be injected here -->
        </div>
        <div class="p-4 border-t border-gray-700">
          <form id="ai-chat-form" class="flex gap-2">
            <input
              type="text"
              id="ai-chat-input"
              class="flex-grow bg-gray-700 border border-gray-600 rounded-lg px-4 py-2"
              placeholder="Ask a follow-up question..."
              required
            />
            <button
              type="submit"
              class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold p-2 rounded-lg"
            >
              Send
            </button>
          </form>
        </div>
      </div>
    </div>

    <!-- AI Blueprint Modal -->
    <div
      id="ai-blueprint-modal"
      class="fixed inset-0 z-[60] hidden items-center justify-center p-4 modal-backdrop"
    >
      <div
        class="bg-gray-800 rounded-lg shadow-2xl max-w-2xl w-full h-[80vh] flex flex-col"
      >
        <div
          class="p-4 border-b border-gray-700 flex justify-between items-center"
        >
          <h3 class="text-xl font-bold">AI Commander Blueprint</h3>
          <button
            id="close-blueprint-modal-btn"
            class="text-gray-400 hover:text-white text-3xl"
          >
            &times;
          </button>
        </div>
        <div class="flex-grow p-6 overflow-y-auto no-scrollbar space-y-4">
          <div id="ai-blueprint-content"></div>
        </div>
        <div class="p-4 flex justify-end gap-4 border-t border-gray-700">
          <button
            type="button"
            id="cancel-blueprint-btn"
            class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg"
          >
            Cancel
          </button>
          <button
            type="button"
            id="confirm-blueprint-btn"
            class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg"
          >
            Create Deck with this Strategy
          </button>
        </div>
      </div>
    </div>

    <!-- Deck Creation Modal -->
    <div
      id="deck-creation-modal"
      class="fixed inset-0 z-50 hidden items-center justify-center p-4 modal-backdrop"
    >
      <div class="bg-gray-800 rounded-lg shadow-2xl max-w-lg w-full">
        <form id="deck-creation-form">
          <div class="p-6">
            <h3 class="text-xl font-bold mb-4">Create a New Deck</h3>
            <div class="space-y-4">
              <div>
                <label
                  for="deck-name-input"
                  class="block text-sm font-medium text-gray-300 mb-1"
                  >Deck Name</label
                >
                <input
                  type="text"
                  id="deck-name-input"
                  class="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2"
                  placeholder="e.g., My Awesome Commander Deck"
                />
              </div>
              <div>
                <label
                  for="deck-format-select"
                  class="block text-sm font-medium text-gray-300 mb-1"
                  >Deck Format</label
                >
                <select
                  id="deck-format-select"
                  class="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2"
                >
                  <option value="commander">Commander</option>
                  <option value="standard">Standard</option>
                  <option value="modern">Modern</option>
                </select>
              </div>
              <!-- Commander Search - shown conditionally -->
              <div id="commander-selection-container" class="space-y-2 pt-2">
                <label class="block text-sm font-medium text-gray-300"
                  >Choose Commander</label
                >
                <div class="flex border-b border-gray-600">
                  <button
                    type="button"
                    id="commander-source-collection-btn"
                    class="commander-source-btn flex-1 p-2 border-b-2 border-indigo-500 text-white"
                  >
                    From Collection
                  </button>
                  <button
                    type="button"
                    id="commander-source-search-btn"
                    class="commander-source-btn flex-1 p-2 border-b-2 border-transparent text-gray-400"
                  >
                    Search New
                  </button>
                </div>
                <div id="commander-from-collection" class="mt-2">
                  <input
                    type="text"
                    id="commander-collection-filter"
                    class="w-full bg-gray-900/80 border border-gray-600 rounded-lg px-3 py-1 text-sm mb-2"
                    placeholder="Filter collection commanders..."
                  />
                  <div
                    id="commander-collection-list"
                    class="max-h-60 overflow-y-auto grid grid-cols-1 gap-1 p-1 bg-gray-900/50 rounded-md"
                  >
                    <!-- Legendary creatures from collection will be listed here -->
                  </div>
                </div>
                <div id="commander-from-search" class="hidden mt-2">
                  <div class="flex gap-2">
                    <input
                      type="text"
                      id="commander-search-input"
                      class="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2"
                      placeholder="Search Scryfall for a legendary creature..."
                    />
                    <button
                      type="button"
                      id="commander-search-btn"
                      class="bg-indigo-600 hover:bg-indigo-700 px-4 rounded-lg"
                    >
                      Search
                    </button>
                  </div>
                  <div
                    id="commander-search-results"
                    class="max-h-60 overflow-y-auto grid grid-cols-2 sm:grid-cols-3 gap-2 mt-2"
                  ></div>
                </div>
                <div
                  id="selected-commander-preview"
                  class="hidden items-center gap-4 p-2 bg-gray-900 rounded-lg mt-2"
                ></div>
              </div>
            </div>
            <div class="flex justify-end gap-4 mt-6">
              <button
                type="button"
                id="cancel-deck-btn"
                class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg"
              >
                Cancel
              </button>
              <button
                type="submit"
                id="save-deck-btn"
                class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg flex items-center justify-center"
              >
                <span id="save-deck-text">Create Deck</span>
                <div
                  id="save-deck-spinner"
                  class="hidden animate-spin rounded-full h-5 w-5 border-b-2 border-white"
                ></div>
              </button>
            </div>
          </div>
        </form>
      </div>
    </div>

    <!-- Generic Confirmation Modal -->
    <div
      id="confirmation-modal"
      class="fixed inset-0 z-[80] hidden items-center justify-center p-4 modal-backdrop"
    >
      <div class="bg-gray-800 rounded-lg shadow-2xl max-w-sm w-full">
        <div class="p-6 text-center">
          <h3 id="confirmation-title" class="text-xl font-bold mb-2">
            Are you sure?
          </h3>
          <p id="confirmation-message" class="text-gray-400 mb-6">
            This action cannot be undone.
          </p>
          <div class="flex justify-center gap-4">
            <button
              id="confirm-action-btn"
              class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-6 rounded-lg"
            >
              Confirm
            </button>
            <button
              id="cancel-action-btn"
              class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-6 rounded-lg"
            >
              Cancel
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- Deck Deletion Options Modal -->
    <div
      id="deck-delete-options-modal"
      class="fixed inset-0 z-[80] hidden items-center justify-center p-4 modal-backdrop"
    >
      <div class="bg-gray-800 rounded-lg shadow-2xl max-w-md w-full">
        <div class="p-6 text-center">
          <h3 class="text-xl font-bold mb-2">Delete Deck</h3>
          <p class="text-gray-400 mb-6">
            Do you also want to remove the cards from this deck from your
            collection?
          </p>
          <div class="flex flex-col gap-4">
            <button
              id="delete-deck-and-cards-btn"
              class="bg-red-800 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg"
            >
              Delete Deck & Remove Cards
            </button>
            <button
              id="delete-deck-only-btn"
              class="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg"
            >
              Delete Deck Only
            </button>
            <button
              id="cancel-delete-deck-btn"
              class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-6 rounded-lg"
            >
              Cancel
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- Rule Lookup Modal -->
    <div
      id="rule-lookup-modal"
      class="fixed inset-0 z-50 hidden items-center justify-center p-4 modal-backdrop"
    >
      <div
        class="bg-gray-800 rounded-lg shadow-2xl max-w-2xl w-full h-[80vh] flex flex-col"
      >
        <div
          class="p-4 border-b border-gray-700 flex justify-between items-center"
        >
          <h3 class="text-xl font-bold">Rule Lookup</h3>
          <button
            id="close-rule-lookup-modal-btn"
            class="text-gray-400 hover:text-white text-3xl"
          >
            &times;
          </button>
        </div>
        <div
          id="rule-lookup-history"
          class="flex-grow p-4 space-y-4 overflow-y-auto no-scrollbar"
        >
          <div class="bg-gray-700 p-3 rounded-lg">
            <p>
              Ask a Magic: The Gathering rule question below. For example, "What
              is banding?" or "How does cascade work?".
            </p>
          </div>
        </div>
        <div class="p-4 border-t border-gray-700">
          <form id="rule-lookup-form" class="flex gap-2">
            <input
              type="text"
              id="rule-lookup-input"
              class="flex-grow bg-gray-700 border border-gray-600 rounded-lg px-4 py-2"
              placeholder="Enter your rule question..."
              required
            />
            <button
              type="submit"
              class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold p-2 rounded-lg"
            >
              Ask
            </button>
          </form>
        </div>
      </div>
    </div>

    <!-- MTG Chat Modal -->
    <div
      id="mtg-chat-modal"
      class="fixed inset-0 z-50 hidden items-center justify-center p-4 modal-backdrop"
    >
      <div
        class="bg-gray-800 rounded-lg shadow-2xl max-w-2xl w-full h-[80vh] flex flex-col"
      >
        <div
          class="p-4 border-b border-gray-700 flex justify-between items-center"
        >
          <h3 class="text-xl font-bold">MTG Chat</h3>
          <button
            id="close-mtg-chat-modal-btn"
            class="text-gray-400 hover:text-white text-3xl"
          >
            &times;
          </button>
        </div>
        <div
          id="mtg-chat-history"
          class="flex-grow p-4 space-y-4 overflow-y-auto no-scrollbar"
        >
          <div class="bg-gray-700 p-3 rounded-lg">
            <p>
              Welcome! Ask me anything about MTG strategy, lore, deck building,
              or cards.
            </p>
          </div>
        </div>
        <div class="p-4 border-t border-gray-700">
          <form id="mtg-chat-form" class="flex gap-2">
            <input
              type="text"
              id="mtg-chat-input"
              class="flex-grow bg-gray-700 border border-gray-600 rounded-lg px-4 py-2"
              placeholder="Ask a question..."
              required
            />
            <button
              type="submit"
              class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold p-2 rounded-lg"
            >
              Send
            </button>
          </form>
        </div>
      </div>
    </div>

    <!-- New Player Guide Modal -->
    <div
      id="new-player-guide-modal"
      class="fixed inset-0 z-50 hidden items-center justify-center p-4 modal-backdrop"
    >
      <div
        class="bg-gray-800 rounded-lg shadow-2xl max-w-3xl w-full h-[80vh] flex flex-col"
      >
        <div
          class="p-4 border-b border-gray-700 flex justify-between items-center"
        >
          <h3 class="text-xl font-bold">New Player Guide</h3>
          <button
            id="close-new-player-guide-modal-btn"
            class="text-gray-400 hover:text-white text-3xl"
          >
            &times;
          </button>
        </div>
        <div class="flex-grow p-6 space-y-4 overflow-y-auto no-scrollbar">
          <details class="bg-gray-900/50 p-4 rounded-lg">
            <summary class="font-semibold text-lg hover:text-indigo-400">
              The Colors of Magic
            </summary>
            <div class="mt-4 space-y-3 text-gray-300">
              <p>
                <strong>White (W):</strong> The color of order, law, and
                community. White excels at creating armies of small creatures,
                protecting them with enchantments, gaining life, and using
                powerful spells that affect all players equally to level the
                playing field.
              </p>
              <p>
                <strong>Blue (U):</strong> The color of knowledge, manipulation,
                and deceit. Blue is the master of controlling the game by
                countering opponent's spells, drawing extra cards to find the
                right answers, and controlling the board with tricky creatures
                (often with flying) and illusions.
              </p>
              <p>
                <strong>Black (B):</strong> The color of ambition, death, and
                power at any cost. Black is willing to sacrifice anything—life,
                creatures, cards in hand—to win. It is the undisputed master of
                destroying creatures, forcing opponents to discard cards, and
                reanimating creatures from any graveyard.
              </p>
              <p>
                <strong>Red (R):</strong> The color of chaos, freedom, and
                impulse. Red wants to win, and it wants to win now. It uses
                direct damage spells ("burn") to destroy creatures or attack the
                opponent directly, and deploys fast creatures with haste to keep
                the pressure on.
              </p>
              <p>
                <strong>Green (G):</strong> The color of nature, growth, and
                brute force. Green is all about playing massive, powerful
                creatures. It excels at "ramping" its mana—getting more lands
                into play faster than normal—to cast its huge threats far ahead
                of schedule.
              </p>
            </div>
          </details>

          <details class="bg-gray-900/50 p-4 rounded-lg">
            <summary class="font-semibold text-lg hover:text-indigo-400">
              Anatomy of a Deck
            </summary>
            <div class="mt-4 space-y-3 text-gray-300">
              <p class="text-sm text-gray-400">
                Note: These are general guidelines. Ratios change dramatically
                based on strategy!
              </p>
              <h4 class="font-bold text-md text-indigo-300">
                Typical 60-Card Deck (Standard, Modern, etc.)
              </h4>
              <ul class="list-disc list-inside">
                <li>
                  <strong>~24 Lands:</strong> This is the most crucial number.
                  Too few and you won't be able to cast your spells; too many
                  and you'll run out of things to do.
                </li>
                <li>
                  <strong>~20-25 Creatures:</strong> The core of most
                  strategies. These are your attackers and blockers.
                </li>
                <li>
                  <strong>~11-16 Other Spells:</strong> This includes removal,
                  card draw, and any other spells that support your
                  creature-based game plan.
                </li>
              </ul>
              <h4 class="font-bold text-md text-indigo-300 mt-4">
                Typical 100-Card Deck (Commander/EDH)
              </h4>
              <ul class="list-disc list-inside">
                <li>
                  <strong>1 Commander:</strong> Your legendary creature that
                  defines the deck's colors and strategy.
                </li>
                <li>
                  <strong>~37-38 Lands:</strong> You need more lands in
                  Commander due to the higher mana costs and longer games.
                </li>
                <li>
                  <strong>~10-12 Ramp/Mana Rocks:</strong> Spells or artifacts
                  that help you generate extra mana. Crucial for keeping up.
                </li>
                <li>
                  <strong>~10 Card Draw:</strong> Spells that let you draw more
                  cards. Essential for not running out of gas in a long game.
                </li>
                <li>
                  <strong>~10-12 Interaction/Removal:</strong> Ways to deal with
                  your opponents' threats.
                </li>
                <li>
                  <strong>~28-30 "Theme" Cards:</strong> These are the
                  creatures, spells, and other cards that work with your
                  commander to execute your deck's main strategy.
                </li>
              </ul>
            </div>
          </details>

          <details class="bg-gray-900/50 p-4 rounded-lg">
            <summary class="font-semibold text-lg hover:text-indigo-400">
              Common Playstyles (Archetypes)
            </summary>
            <div class="mt-4 space-y-3 text-gray-300">
              <p>
                <strong>Aggro (Aggressive):</strong> The goal is to win as
                quickly as possible, usually by attacking with cheap, efficient
                creatures. Aggro decks try to overwhelm the opponent before they
                can execute their own, more powerful late-game strategy. They
                live by the motto, "the best defense is a good offense."
              </p>
              <p>
                <strong>Control:</strong> The polar opposite of Aggro. Control
                decks aim to survive the early game by countering the opponent's
                key spells and destroying their creatures. They win the game in
                the long run by using powerful spells, planeswalkers, or a
                single, hard-to-kill creature once the opponent has run out of
                resources.
              </p>
              <p>
                <strong>Midrange:</strong> The jack-of-all-trades. Midrange
                decks are flexible, able to play defensively against Aggro decks
                and then switch gears to be the aggressor against slower Control
                decks. They focus on playing individually powerful and efficient
                cards that are good in almost any situation.
              </p>
              <p>
                <strong>Combo (Combination):</strong> These decks aim to
                assemble a specific combination of two or more cards that
                results in an instant win or an insurmountable advantage. Combo
                decks often feel like they are "playing solitaire," as they can
                sometimes ignore what the opponent is doing to focus entirely on
                finding their winning pieces.
              </p>
              <p>
                <strong>Tempo:</strong> A close cousin of Aggro. Tempo decks
                play an early threat and then protect it by cheaply disrupting
                the opponent's game plan just long enough to win. They use
                spells to bounce creatures back to their owner's hand or tap
                them down to clear the way for attacks, keeping their opponent
                constantly off-balance.
              </p>
            </div>
          </details>
        </div>
      </div>
    </div>

    <!-- Notification Modal -->
    <div
      id="notification-modal"
      class="fixed inset-0 z-[90] hidden items-center justify-center p-4 modal-backdrop"
    >
      <div
        class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-sm text-center"
      >
        <h3
          id="notification-title"
          class="text-lg font-bold mb-2 text-red-400"
        ></h3>
        <p id="notification-message" class="text-gray-300"></p>
        <button
          id="notification-close-btn"
          class="mt-4 w-full bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg"
        >
          Close
        </button>
      </div>
    </div>

    <!-- Firebase and App Logic -->
    <script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
      import {
        getAuth,
        onAuthStateChanged,
        signOut,
        GoogleAuthProvider,
        signInWithPopup,
        createUserWithEmailAndPassword,
        signInWithEmailAndPassword,
        signInAnonymously,
        signInWithCustomToken,
      } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
      import {
        getFirestore,
        doc,
        getDoc,
        collection,
        onSnapshot,
        addDoc,
        deleteDoc,
        updateDoc,
        arrayUnion,
        writeBatch,
        getDocs,
      } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

      document.addEventListener("DOMContentLoaded", () => {
        console.log(
          "[DOMContentLoaded] Event fired. App is initializing. Find in <script> block."
        );

        // --- FIREBASE & APP CONFIG ---
        let db, auth;
        let userId = null;
        let collectionUnsubscribe = null;
        let decksUnsubscribe = null;

        const appId =
          typeof __app_id !== "undefined" ? __app_id : "mtg-forge-default";
        console.log(`[Config] App ID set to: ${appId}`);

        const firebaseConfig =
          typeof __firebase_config !== "undefined"
            ? JSON.parse(__firebase_config)
            : {
                apiKey: "AIzaSyAdqbFNjrB6y-8BrMEYYCT5ywiCgZVtMaE",
                authDomain: "mtglibrary-70b46.firebaseapp.com",
                projectId: "mtglibrary-70b46",
                storageBucket: "mtglibrary-70b46.firebasestorage.app",
                messagingSenderId: "602862103839",
                appId: "1:602862103839:web:23c64b7486c058c903d42a",
                measurementId: "G-EWELJJQ631",
              };
        console.log("[Config] Firebase config loaded.");

        const GEMINI_API_KEY = "AIzaSyDkbSsM1e4aN85G7ZVGw-XOs4HE8_E4Zig";
        const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${GEMINI_API_KEY}`;
        console.log("[Config] Gemini API URL configured.");

        // --- STATE ---
        let currentCardForAdd = null;
        let currentCommanderForAdd = null;
        let tempAiBlueprint = null;
        let localCollection = {};
        let localDecks = {};
        let cardDeckAssignments = {};
        let deckChartInstances = {};
        let collectionViewMode = "grid";
        let collectionGridSize = "md";
        let collectionSortState = { column: "name", direction: "asc" };
        let collectionCurrentPage = 1;
        const COLLECTION_PAGE_SIZE = 100;
        let currentSearchContext = {
          mode: "collection",
          deckId: null,
        };
        let modalVisibilitySettings = {};
        let activeAiChatHistory = [];
        let ruleLookupHistory = [];
        let mtgChatHistory = [];
        console.log("[State] Initial application state variables declared.");

        // --- DOM ELEMENTS ---
        const views = {
          collection: document.getElementById("collection-view"),
          decks: document.getElementById("decks-view"),
          singleDeck: document.getElementById("single-deck-view"),
          settings: document.getElementById("settings-view"),
        };

        const modalSettingOptions = {
          prices: "Prices",
          legalities: "Format Legality",
          printing: "Printing Details",
          flavor: "Flavor Text",
          rulings: "Rulings Link",
          purchase: "Purchase Links",
        };
        console.log("[DOM] View and settings option objects created.");

        // --- ALL FUNCTION DEFINITIONS ---

        // --- UI HELPERS (defining before they are called) ---
        function showToast(message, type = "info", duration = 5000) {
          console.log(
            `[Function: showToast] Displaying toast. Message: "${message}", Type: ${type}. Find in <script> block.`
          );
          const container = document.getElementById("toast-container");
          const toast = document.createElement("div");
          const id = `toast-${Date.now()}`;
          toast.id = id;

          let bgColor, icon;
          switch (type) {
            case "success":
              bgColor = "bg-green-600";
              icon = `<svg class="w-6 h-6 mr-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>`;
              break;
            case "error":
              bgColor = "bg-red-600";
              icon = `<svg class="w-6 h-6 mr-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>`;
              break;
            case "loading":
              bgColor = "bg-blue-600";
              icon = `<div class="animate-spin rounded-full h-5 w-5 border-b-2 border-white mr-3"></div>`;
              break;
            default:
              bgColor = "bg-gray-700";
              icon = `<svg class="w-6 h-6 mr-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>`;
              break;
          }

          toast.className = `toast text-white ${bgColor}`;
          toast.innerHTML = `${icon}<span>${message}</span>`;
          container.appendChild(toast);

          if (duration) {
            setTimeout(() => {
              toast.remove();
            }, duration + 500); // 500ms for slide out animation
          } else {
            toast.style.animation = "slideIn 0.5s forwards"; // No slide out
          }
          return id;
        }

        function updateToast(id, message, type) {
          console.log(
            `[Function: updateToast] Updating toast ID ${id}. Message: "${message}", Type: ${type}. Find in <script> block.`
          );
          const toast = document.getElementById(id);
          if (!toast) return;

          let bgColor, icon;
          switch (type) {
            case "success":
              bgColor = "bg-green-600";
              icon = `<svg class="w-6 h-6 mr-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>`;
              break;
            case "error":
              bgColor = "bg-red-600";
              icon = `<svg class="w-6 h-6 mr-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>`;
              break;
            default: // back to info
              bgColor = "bg-gray-700";
              icon = `<svg class="w-6 h-6 mr-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>`;
              break;
          }
          toast.className = `toast text-white ${bgColor}`;
          toast.style.animation = "none"; // reset animation
          toast.innerHTML = `${icon}<span>${message}</span>`;
          setTimeout(() => {
            // set new fade out
            toast.style.animation = "slideOut 0.5s forwards";
            setTimeout(() => toast.remove(), 500);
          }, 4500);
        }

        function loadUserData() {
          console.log(
            "[Function: loadUserData] Setting up Firestore listeners for collections and decks. Find in <script> block."
          );
          if (!userId) {
            console.warn(
              "[loadUserData] No user ID found, aborting data load."
            );
            return;
          }
          if (collectionUnsubscribe) collectionUnsubscribe();
          if (decksUnsubscribe) decksUnsubscribe();

          const collectionRef = collection(
            db,
            `artifacts/${appId}/users/${userId}/cards`
          );
          console.log(
            `[loadUserData] Attaching onSnapshot listener to path: ${collectionRef.path}`
          );
          collectionUnsubscribe = onSnapshot(
            collectionRef,
            (snapshot) => {
              console.log(
                `[onSnapshot: cards] Received update with ${snapshot.size} card documents.`
              );
              localCollection = {};
              snapshot.forEach((doc) => {
                localCollection[doc.id] = {
                  firestoreId: doc.id,
                  ...doc.data(),
                };
              });
            },
            (error) =>
              console.error(
                "[onSnapshot: cards] Collection snapshot error:",
                error
              )
          );

          const decksRef = collection(
            db,
            `artifacts/${appId}/users/${userId}/decks`
          );
          console.log(
            `[loadUserData] Attaching onSnapshot listener to path: ${decksRef.path}`
          );
          decksUnsubscribe = onSnapshot(
            decksRef,
            (snapshot) => {
              console.log(
                `[onSnapshot: decks] Received update with ${snapshot.size} deck documents.`
              );
              localDecks = {};
              snapshot.forEach((doc) => {
                localDecks[doc.id] = { id: doc.id, ...doc.data() };
              });
              updateCardDeckAssignments();
              renderCollection();
              renderDecks();
              renderSettingsPage();
              if (
                document.getElementById("single-deck-view").dataset.deckId &&
                !views.singleDeck.classList.contains("hidden")
              ) {
                console.log(
                  "[onSnapshot: decks] Active deck view detected. Re-rendering single deck view."
                );
                renderSingleDeck(
                  document.getElementById("single-deck-view").dataset.deckId
                );
              }
            },
            (error) =>
              console.error("[onSnapshot: decks] Decks snapshot error:", error)
          );
        }

        function updateCardDeckAssignments() {
          console.log(
            "[Function: updateCardDeckAssignments] Re-calculating card-to-deck assignments. Find in <script> block."
          );
          cardDeckAssignments = {};
          for (const deckId in localDecks) {
            const deck = localDecks[deckId];
            if (deck.commander?.firestoreId) {
              cardDeckAssignments[deck.commander.firestoreId] = {
                deckId,
                deckName: deck.name,
                isCommander: true,
              };
            }
            for (const cardKey in deck.cards) {
              const card = deck.cards[cardKey];
              if (card.firestoreId) {
                cardDeckAssignments[card.firestoreId] = {
                  deckId,
                  deckName: deck.name,
                  isCommander: false,
                };
              }
            }
          }
        }

        async function searchScryfall(cardName) {
          console.log(
            `[Function: searchScryfall] Searching for card "${cardName}" with context "${currentSearchContext.mode}". Find in <script> block.`
          );
          toggleSearchSpinner(
            true,
            currentSearchContext.mode === "deck"
              ? "deck-search-btn"
              : "search-card-btn"
          );
          document.getElementById("card-versions-grid").innerHTML = "";
          document.getElementById("versions-loading").style.display = "flex";
          const modalTitle = document.getElementById(
            "card-versions-modal-title"
          );

          let searchUrl = `https://api.scryfall.com/cards/search?unique=prints&q=${encodeURIComponent(
            cardName
          )}`;
          if (currentSearchContext.mode === "commander") {
            modalTitle.textContent = "Select Commander Version";
            searchUrl += `+t:legendary+t:creature`;
          } else if (currentSearchContext.mode === "deck") {
            modalTitle.textContent = "Select Card Version to Add to Deck";
          } else {
            modalTitle.textContent = "Select Card Version";
          }
          console.log(`[searchScryfall] Fetching from URL: ${searchUrl}`);
          showModal("card-versions-modal");

          try {
            const response = await fetch(searchUrl);
            if (!response.ok)
              throw new Error(
                `Card not found. Scryfall API responded with status: ${response.status}`
              );
            const data = await response.json();
            console.log(`[searchScryfall] Found ${data.data.length} versions.`);
            renderCardVersions(data.data);
          } catch (error) {
            console.error("[searchScryfall] Scryfall API error:", error);
            showNotification("Search Error", error.message);
            hideModal("card-versions-modal");
          } finally {
            toggleSearchSpinner(
              false,
              currentSearchContext.mode === "deck"
                ? "deck-search-btn"
                : "search-card-btn"
            );
            document.getElementById("versions-loading").style.display = "none";
          }
        }

        async function handleAiChat(deckId, userMessage = null) {
          console.log(
            `[Function: handleAiChat] Handling AI chat for deck ${deckId}. Find in <script> block.`
          );
          const deck = localDecks[deckId];
          if (!deck) {
            console.error(`[handleAiChat] Deck with ID ${deckId} not found.`);
            return;
          }

          if (!userMessage) {
            // Initial call
            console.log(
              "[handleAiChat] This is the initial call. Constructing initial prompt."
            );
            activeAiChatHistory = [];
            document.getElementById(
              "ai-chat-history"
            ).innerHTML = `<div class="flex justify-center items-center h-full"><div class="animate-spin rounded-full h-8 w-8 border-b-2 border-indigo-400"></div></div>`;
            showModal("ai-suggestions-modal");
            const cardList = Object.values(deck.cards || {})
              .map((c) => `${c.count}x ${c.name}`)
              .join("\n");
            const commanderLine = deck.commander
              ? `Commander: 1x ${deck.commander.name}\n`
              : "";
            const initialPrompt = `You are an expert Magic: The Gathering deck builder. Analyze the following decklist and provide suggestions for improvement. Focus on synergy, mana curve, and overall strategy. Suggest specific cards to add and remove. Format your response clearly with sections for "Analysis", "Cards to Add", and "Cards to Remove".\n\nDeck Name: ${deck.name}\n${commanderLine}Decklist:\n${cardList}`;
            activeAiChatHistory.push({
              role: "user",
              parts: [{ text: initialPrompt }],
            });
          } else {
            console.log(
              `[handleAiChat] Follow-up message from user: "${userMessage}"`
            );
            activeAiChatHistory.push({
              role: "user",
              parts: [{ text: userMessage }],
            });
          }

          renderAiChat();

          try {
            console.log(
              "[handleAiChat] Calling Gemini API for deck suggestions."
            );
            const response = await fetch(GEMINI_API_URL, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ contents: activeAiChatHistory }),
            });
            if (!response.ok)
              throw new Error(
                `Gemini API request failed with status ${response.status}`
              );
            const result = await response.json();
            const text = result.candidates?.[0]?.content?.parts?.[0]?.text;
            if (text) {
              console.log("[handleAiChat] Received response from Gemini.");
              activeAiChatHistory.push({ role: "model", parts: [{ text }] });
            } else {
              throw new Error("Invalid response from Gemini API.");
            }
          } catch (error) {
            console.error("[handleAiChat] Gemini API error:", error);
            activeAiChatHistory.push({
              role: "model",
              parts: [
                { text: `Sorry, I encountered an error: ${error.message}` },
              ],
            });
          } finally {
            renderAiChat();
          }
        }

        async function getAiDeckBlueprint(commanderCard, deckName) {
          console.log(
            `[Function: getAiDeckBlueprint] Requesting AI blueprint for commander "${commanderCard.name}". Find in <script> block.`
          );
          if (!GEMINI_API_KEY) {
            console.warn(
              "[getAiDeckBlueprint] Gemini API key is missing. Skipping AI deck blueprint generation."
            );
            return null;
          }
          const toastId = showToast(
            "Asking AI for a deck blueprint...",
            "loading",
            null
          );

          let namePromptPart = deckName
            ? `The user has named the deck "${deckName}".`
            : `The user has not provided a name. Suggest a creative deck name that is less than 5 words and includes mana symbols like {W}{U}{B}{R}{G} based on the commander's colors.`;

          const prompt = `You are an expert MTG Commander deck building strategist. For the commander "${commanderCard.name}", provide a recommended deck composition, strategy, and a deck name if one isn't provided. ${namePromptPart} Respond with ONLY a valid JSON object with the following structure: {"deckName": "Creative Name {U}{B}", "strategySynopsis": "A detailed multi-paragraph strategy guide...", "suggestedCounts": {"Land": 37, "Creature": 28, "Artifact": 12, "Enchantment": 8, "Instant": 6, "Sorcery": 6, "Planeswalker": 3}}. Do not include any text outside of the JSON object or use markdown.`;
          console.log("[getAiDeckBlueprint] Sending prompt to Gemini:", prompt);
          try {
            const response = await fetch(GEMINI_API_URL, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                contents: [{ parts: [{ text: prompt }] }],
              }),
            });
            if (!response.ok) throw new Error("Gemini API request failed.");

            const result = await response.json();
            const text = result.candidates?.[0]?.content?.parts?.[0]?.text;
            if (text) {
              updateToast(toastId, "Blueprint received!", "success");
              const blueprint = JSON.parse(text);
              console.log(
                "[getAiDeckBlueprint] Received and parsed blueprint:",
                blueprint
              );
              if (!deckName) {
                blueprint.generatedName = blueprint.deckName;
              } else {
                blueprint.deckName = deckName;
              }
              return blueprint;
            }
            throw new Error("Invalid response from Gemini API.");
          } catch (error) {
            console.error(
              "[getAiDeckBlueprint] Error getting AI deck blueprint:",
              error
            );
            updateToast(toastId, `Error: ${error.message}`, "error");
            return null;
          }
        }

        function renderAiChat() {
          console.log(
            "[Function: renderAiChat] Rendering AI suggestion chat history. Find in <script> block."
          );
          const chatContainer = document.getElementById("ai-chat-history");
          chatContainer.innerHTML = activeAiChatHistory
            .map((msg) => {
              if (msg.role === "model") {
                return `<div class="bg-gray-700 p-3 rounded-lg"><p class="whitespace-pre-wrap">${msg.parts[0].text}</p></div>`;
              }
              // Don't render the initial long prompt to the user
              if (activeAiChatHistory.indexOf(msg) > 0) {
                return `<div class="bg-indigo-900 p-3 rounded-lg text-right"><p class="font-semibold">${msg.parts[0].text}</p></div>`;
              }
              return "";
            })
            .join("");
          chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        function renderCardVersions(cards) {
          console.log(
            `[Function: renderCardVersions] Rendering ${cards.length} card versions in the modal. Find in <script> block.`
          );
          const grid = document.getElementById("card-versions-grid");
          grid.innerHTML = cards
            .map((card) => {
              const cardJson = escapeHtml(JSON.stringify(card));
              return `
                    <div class="cursor-pointer group relative" data-card='${cardJson}'>
                        <div class="card-image-container rounded-lg overflow-hidden shadow-lg transform group-hover:scale-105 transition-transform duration-300">
                            <img src="${
                              card.image_uris?.normal ||
                              "https://placehold.co/600x840/1f2937/9ca3af?text=No+Image"
                            }" alt="${card.name}" class="card-image">
                        </div>
                    </div>`;
            })
            .join("");
        }

        function renderCollection() {
          console.log(
            "[Function: renderCollection] Triggering a full re-render of the collection view. Find in <script> block."
          );
          collectionCurrentPage = 1;
          renderPaginatedCollection();
        }

        function renderPaginatedCollection() {
          console.log(
            `[Function: renderPaginatedCollection] Rendering page ${collectionCurrentPage} of the collection. Find in <script> block.`
          );
          const contentDiv = document.getElementById("collection-content");
          const paginationDiv = document.getElementById(
            "collection-pagination"
          );
          const noCardsMsg = document.getElementById("no-cards-msg");
          let cards = Object.values(localCollection);

          if (document.getElementById("hide-in-deck-checkbox").checked) {
            cards = cards.filter(
              (card) => !cardDeckAssignments[card.firestoreId]
            );
          }

          const filterText = document
            .getElementById("filter-text")
            .value.toLowerCase();
          if (filterText) {
            cards = cards.filter(
              (card) =>
                card.name.toLowerCase().includes(filterText) ||
                card.type_line.toLowerCase().includes(filterText)
            );
          }
          console.log(
            `[renderPaginatedCollection] After filtering, ${cards.length} cards remain.`
          );

          noCardsMsg.style.display = cards.length === 0 ? "block" : "none";

          const totalPages = Math.ceil(cards.length / COLLECTION_PAGE_SIZE);
          if (totalPages > 1) {
            const start = (collectionCurrentPage - 1) * COLLECTION_PAGE_SIZE;
            const end = start + COLLECTION_PAGE_SIZE;
            const paginatedCards = cards.slice(start, end);
            renderPaginationControls(totalPages);
            cards = paginatedCards;
          } else {
            paginationDiv.innerHTML = "";
          }

          if (collectionViewMode === "grid") {
            renderCollectionGrid(cards);
          } else {
            renderCollectionTable(cards);
          }
        }

        function renderPaginationControls(totalPages) {
          console.log(
            `[Function: renderPaginationControls] Rendering pagination controls. Current: ${collectionCurrentPage}, Total: ${totalPages}. Find in <script> block.`
          );
          const paginationDiv = document.getElementById(
            "collection-pagination"
          );
          let html = "";

          html += `<button data-page="${
            collectionCurrentPage - 1
          }" class="pagination-btn px-4 py-2 rounded-md ${
            collectionCurrentPage === 1
              ? "bg-gray-700 text-gray-500 cursor-not-allowed"
              : "bg-indigo-600 hover:bg-indigo-700 text-white"
          }" ${collectionCurrentPage === 1 ? "disabled" : ""}>Prev</button>`;
          html += `<span class="px-4 py-2 text-gray-300">Page ${collectionCurrentPage} of ${totalPages}</span>`;
          html += `<button data-page="${
            collectionCurrentPage + 1
          }" class="pagination-btn px-4 py-2 rounded-md ${
            collectionCurrentPage === totalPages
              ? "bg-gray-700 text-gray-500 cursor-not-allowed"
              : "bg-indigo-600 hover:bg-indigo-700 text-white"
          }" ${
            collectionCurrentPage === totalPages ? "disabled" : ""
          }>Next</button>`;

          paginationDiv.innerHTML = html;

          document.querySelectorAll(".pagination-btn").forEach((btn) => {
            btn.addEventListener("click", (e) => {
              collectionCurrentPage = parseInt(e.currentTarget.dataset.page);
              renderPaginatedCollection();
            });
          });
        }

        function renderCollectionGrid(cards) {
          console.log(
            `[Function: renderCollectionGrid] Rendering collection as a grid. Card count: ${cards.length}. Find in <script> block.`
          );
          const contentDiv = document.getElementById("collection-content");
          const groupBy = document.getElementById("collection-group-by").value;

          const sizeClasses = {
            sm: "grid-cols-4 sm:grid-cols-5 md:grid-cols-7 lg:grid-cols-9 xl:grid-cols-11",
            md: "grid-cols-3 sm:grid-cols-4 md:grid-cols-6 lg:grid-cols-7 xl:grid-cols-9",
            lg: "grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6",
          };
          const gridClass = sizeClasses[collectionGridSize] || sizeClasses.md;

          if (groupBy) {
            console.log(
              `[renderCollectionGrid] Grouping cards by "${groupBy}".`
            );
            const groups = cards.reduce((acc, card) => {
              let key;
              if (groupBy === "color_identity") {
                key = card.color_identity.join("") || "Colorless";
              } else if (groupBy === "type_line") {
                key = card.type_line.split(" — ")[0];
              } else {
                key = card[groupBy] ?? "Other";
              }
              (acc[key] = acc[key] || []).push(card);
              return acc;
            }, {});

            contentDiv.innerHTML = Object.keys(groups)
              .sort()
              .map(
                (groupName) => `
                        <div class="group-header">${groupName}</div>
                        <div class="grid ${gridClass} gap-4 p-4">
                            ${groups[groupName]
                              .map(renderCollectionCard)
                              .join("")}
                        </div>
                    `
              )
              .join("");
          } else {
            contentDiv.innerHTML = `<div class="grid ${gridClass} gap-4 p-4">
                        ${cards.map(renderCollectionCard).join("")}
                    </div>`;
          }
          addCollectionCardListeners();
        }

        function renderCollectionTable(cards) {
          console.log(
            `[Function: renderCollectionTable] Rendering collection as a table. Card count: ${cards.length}. Find in <script> block.`
          );
          const contentDiv = document.getElementById("collection-content");
          const renderTableRows = (cardGroup) =>
            cardGroup
              .map((card) => {
                const price =
                  card.finish === "foil"
                    ? card.prices?.usd_foil || "N/A"
                    : card.prices?.usd || "N/A";
                const assignment = cardDeckAssignments[card.firestoreId];
                let statusHtml = '<span class="text-gray-500">-</span>';
                if (assignment) {
                  statusHtml = `<span class="text-xs font-semibold px-2 py-1 rounded-full bg-purple-800 text-purple-200">${
                    assignment.isCommander ? "Cmdr" : "In Deck"
                  }: ${assignment.deckName}</span>`;
                }

                return `
                    <tr class="bg-gray-800 border-b border-gray-700 hover:bg-gray-600 collection-card-row" data-card='${escapeHtml(
                      JSON.stringify(card)
                    )}'>
                        <td class="px-6 py-4 font-medium whitespace-nowrap text-white cursor-pointer">
                            <div>${
                              card.name
                            } <span class="text-gray-400 text-xs">(${card.set.toUpperCase()})</span></div>
                            <div class="text-xs text-gray-400 flex items-center gap-2">
                                <span>${card.mana_cost || ""} (${
                  card.cmc
                })</span>
                                <span>|</span>
                                <span>${card.type_line}</span>
                                ${
                                  card.power
                                    ? `<span>| ${card.power}/${card.toughness}</span>`
                                    : ""
                                }
                            </div>
                        </td>
                        <td class="px-6 py-4">${card.count}</td>
                        <td class="px-6 py-4 capitalize">${card.finish}</td>
                        <td class="px-6 py-4 oracle-text-truncate text-xs">${
                          card.oracle_text || ""
                        }</td>
                        <td class="px-6 py-4">$${price}</td>
                        <td class="px-6 py-4">${statusHtml}</td>
                        <td class="px-6 py-4">
                            <button class="delete-button text-red-500 hover:text-red-400">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                            </button>
                        </td>
                    </tr>`;
              })
              .join("");

          const tableHeader = `
                    <thead class="text-xs text-gray-400 uppercase bg-gray-700">
                        <tr>
                            <th scope="col" class="px-6 py-3 sortable" data-sort="name">Name / Info</th>
                            <th scope="col" class="px-6 py-3 sortable" data-sort="count">#</th>
                            <th scope="col" class="px-6 py-3 sortable" data-sort="finish">Finish</th>
                            <th scope="col" class="px-6 py-3">Oracle Text</th>
                            <th scope="col" class="px-6 py-3 sortable" data-sort="prices.usd">Price</th>
                            <th scope="col" class="px-6 py-3">Status</th>
                            <th scope="col" class="px-6 py-3"></th>
                        </tr>
                    </thead>`;

          const groupBy = document.getElementById("collection-group-by").value;
          if (groupBy) {
            console.log(
              `[renderCollectionTable] Grouping cards by "${groupBy}".`
            );
            const groups = cards.reduce((acc, card) => {
              let key;
              if (groupBy === "color_identity")
                key = card.color_identity.join("") || "Colorless";
              else if (groupBy === "type_line")
                key = card.type_line.split(" — ")[0];
              else key = card[groupBy] ?? "Other";
              (acc[key] = acc[key] || []).push(card);
              return acc;
            }, {});
            contentDiv.innerHTML = Object.keys(groups)
              .sort()
              .map(
                (groupName) =>
                  `<div class="group-header">${groupName}</div>
                         <div class="overflow-x-auto bg-gray-800 rounded-lg">
                             <table class="w-full text-sm text-left text-gray-300">
                                 ${tableHeader}
                                 <tbody>${renderTableRows(
                                   groups[groupName]
                                 )}</tbody>
                             </table>
                         </div>`
              )
              .join("");
          } else {
            contentDiv.innerHTML = `
                     <div class="overflow-x-auto bg-gray-800 rounded-lg">
                         <table class="w-full text-sm text-left text-gray-300">
                             ${tableHeader}
                             <tbody>${renderTableRows(cards)}</tbody>
                         </table>
                     </div>`;
          }

          updateSortHeaders();
          addCollectionTableListeners();
        }

        function addCollectionCardListeners() {
          document.querySelectorAll(".collection-card").forEach((el) => {
            el.addEventListener("click", (e) => {
              const cardData = JSON.parse(e.currentTarget.dataset.card);
              if (e.target.closest(".delete-button")) {
                console.log(
                  `[Event: Click] Delete button clicked for card ${cardData.name} (${cardData.firestoreId}).`
                );
                handleDeleteCard(cardData.firestoreId);
              } else {
                showCardDetailsModal(cardData);
              }
            });
          });
        }

        function addCollectionTableListeners() {
          document.querySelectorAll(".sortable").forEach((th) => {
            th.addEventListener("click", () => {
              if (document.body.classList.contains("edit-mode")) return;
              const column = th.dataset.sort;
              console.log(
                `[Event: Click] Table sort requested for column "${column}".`
              );
              if (collectionSortState.column === column) {
                collectionSortState.direction =
                  collectionSortState.direction === "asc" ? "desc" : "asc";
              } else {
                collectionSortState.column = column;
                collectionSortState.direction = "asc";
              }
              renderCollection();
            });
          });
          document.querySelectorAll(".collection-card-row").forEach((row) => {
            row.addEventListener("click", (e) => {
              const cardData = JSON.parse(row.dataset.card);
              if (e.target.closest(".delete-button")) {
                console.log(
                  `[Event: Click] Delete button clicked for card ${cardData.name} (${cardData.firestoreId}) in table view.`
                );
                handleDeleteCard(cardData.firestoreId);
              } else {
                showCardDetailsModal(cardData);
              }
            });
          });
        }

        function renderCollectionCard(card) {
          const isFoil = card.finish === "foil";
          const cardJson = escapeHtml(JSON.stringify(card));
          const assignment = cardDeckAssignments[card.firestoreId];
          let statusBadge = "";
          if (assignment) {
            statusBadge = `<div class="absolute top-2 left-2 text-xs font-semibold px-2 py-1 rounded-full bg-purple-800 text-purple-200 z-10">${
              assignment.isCommander ? "Cmdr" : "In Deck"
            }</div>`;
          }

          return `
                    <div class="collection-card cursor-pointer group relative" data-card='${cardJson}'>
                        <div class="card-image-container rounded-lg overflow-hidden shadow-lg transform group-hover:scale-105 transition-transform duration-300 ${
                          isFoil ? "ring-2 ring-yellow-400" : ""
                        }">
                            ${statusBadge}
                            <img src="${
                              card.image_uris?.normal ||
                              "https://placehold.co/600x840/1f2937/9ca3af?text=No+Image"
                            }" alt="${card.name}" class="card-image">
                            <div class="absolute top-2 right-2 bg-gray-900/80 rounded-full h-8 w-8 flex items-center justify-center font-bold text-lg">${
                              card.count
                            }</div>
                            <button class="delete-button absolute bottom-2 right-2 bg-red-600 hover:bg-red-700 text-white p-2 rounded-full">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                            </button>
                        </div>
                        <p class="text-center text-sm mt-1 truncate">${
                          card.name
                        }</p>
                    </div>
                `;
        }

        function renderDecks() {
          console.log(
            "[Function: renderDecks] Rendering deck list. Find in <script> block."
          );
          const decksList = document.getElementById("decks-list");
          const noDecksMsg = document.getElementById("no-decks-msg");
          const deckIds = Object.keys(localDecks);
          noDecksMsg.style.display = deckIds.length === 0 ? "block" : "none";

          decksList.innerHTML = deckIds
            .map((id) => {
              const deck = localDecks[id];
              const cardCount =
                Object.values(deck.cards || {}).reduce(
                  (sum, card) => sum + (card.count || 1),
                  0
                ) + (deck.commander ? 1 : 0);
              const commanderImg =
                deck.commander?.image_uris?.art_crop ||
                "https://placehold.co/200x200/374151/9ca3af?text=No+Cmdr";

              return `
                    <div class="bg-gray-800 rounded-lg shadow-lg hover:shadow-indigo-500/30 transition-all duration-300 flex flex-col">
                        <div class="p-4 flex justify-between items-start">
                             <div>
                                <h3 class="text-xl font-bold">${deck.name}</h3>
                                <p class="text-gray-400 text-sm">${cardCount} cards | ${
                deck.format
              }</p>
                            </div>
                            ${
                              deck.format === "commander"
                                ? `<img src="${commanderImg}" class="w-12 h-12 rounded-full border-2 border-gray-600">`
                                : ""
                            }
                        </div>
                        <div class="mt-auto p-4 bg-gray-900/50 rounded-b-lg flex gap-2 justify-end">
                            <button class="view-deck-btn flex-grow bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg" data-id="${id}">View</button>
                            <button class="delete-button bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg" data-id="${id}">Delete</button>
                        </div>
                    </div>`;
            })
            .join("");
        }

        function renderSingleDeck(deckId) {
          console.log(
            `[Function: renderSingleDeck] Rendering single deck view for deck ID: ${deckId}. Find in <script> block.`
          );
          const deck = localDecks[deckId];
          if (!deck) {
            console.error(
              `[renderSingleDeck] Could not find deck with ID ${deckId}. Returning to decks view.`
            );
            showView("decks");
            return;
          }
          views.singleDeck.dataset.deckId = deckId;

          const allDeckCards = [...Object.values(deck.cards || {})];
          if (deck.commander)
            allDeckCards.push({ ...deck.commander, count: 1 });

          const cardCountsByType = allDeckCards.reduce((acc, card) => {
            const mainType = card.type_line.split(" — ")[0];
            const count = card.count || 1;
            if (mainType.includes("Creature"))
              acc["Creature"] = (acc["Creature"] || 0) + count;
            if (mainType.includes("Land"))
              acc["Land"] = (acc["Land"] || 0) + count;
            if (mainType.includes("Artifact"))
              acc["Artifact"] = (acc["Artifact"] || 0) + count;
            if (mainType.includes("Enchantment"))
              acc["Enchantment"] = (acc["Enchantment"] || 0) + count;
            if (mainType.includes("Instant"))
              acc["Instant"] = (acc["Instant"] || 0) + count;
            if (mainType.includes("Sorcery"))
              acc["Sorcery"] = (acc["Sorcery"] || 0) + count;
            if (mainType.includes("Planeswalker"))
              acc["Planeswalker"] = (acc["Planeswalker"] || 0) + count;
            return acc;
          }, {});

          const blueprint = deck.aiBlueprint?.suggestedCounts;
          const kpiData = [
            {
              label: "Creature",
              current: cardCountsByType["Creature"] || 0,
              target: blueprint?.Creature,
            },
            {
              label: "Land",
              current: cardCountsByType["Land"] || 0,
              target: blueprint?.Land,
            },
            {
              label: "Artifact",
              current: cardCountsByType["Artifact"] || 0,
              target: blueprint?.Artifact,
            },
            {
              label: "Instant",
              current: cardCountsByType["Instant"] || 0,
              target: blueprint?.Instant,
            },
            {
              label: "Sorcery",
              current: cardCountsByType["Sorcery"] || 0,
              target: blueprint?.Sorcery,
            },
            {
              label: "Enchantment",
              current: cardCountsByType["Enchantment"] || 0,
              target: blueprint?.Enchantment,
            },
            {
              label: "Planeswalker",
              current: cardCountsByType["Planeswalker"] || 0,
              target: blueprint?.Planeswalker,
            },
            {
              label: "Total",
              current: allDeckCards.reduce((acc, c) => acc + (c.count || 1), 0),
              target: 100,
            },
          ];

          const kpiHtml = kpiData
            .map((item) => {
              const { barClass, width } = getGradientColorForKpi(
                item.current,
                item.target
              );
              return `
                    <div class="bg-gray-800 p-4 rounded-lg text-center relative overflow-hidden">
                        <div class="text-2xl font-bold">${item.current}${
                item.target != null
                  ? ` / <span class="text-gray-400">${item.target}</span>`
                  : ""
              }</div>
                        <div class="text-sm text-gray-400">${item.label}</div>
                        ${
                          item.target != null
                            ? `<div class="kpi-gradient-bar ${barClass}" style="width: ${width}%;"></div>`
                            : ""
                        }
                    </div>`;
            })
            .join("");

          views.singleDeck.innerHTML = `
                    <button id="back-to-decks" class="mb-6 bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg">&larr; Back to Decks</button>
                    <div class="flex justify-between items-start mb-4">
                        <div>
                            <h2 class="text-3xl font-bold">${deck.name}</h2>
                            <p class="text-gray-400">${
                              deck.format.charAt(0).toUpperCase() +
                              deck.format.slice(1)
                            }</p>
                        </div>
                        <div class="flex gap-2">
                           ${
                             deck.aiBlueprint?.strategySynopsis
                               ? `<button id="view-ai-synopsis-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg">View AI Strategy</button>`
                               : ""
                           }
                           <button id="get-ai-suggestions-btn" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg" data-id="${deckId}">Chat with AI</button>
                        </div>
                    </div>
                    
                    <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
                        ${kpiHtml}
                    </div>

                    <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                        <div class="lg:col-span-1 bg-gray-800 p-4 rounded-lg self-start">
                            ${
                              deck.commander
                                ? `
                                <h3 class="text-lg font-bold">Commander</h3>
                                <div class="flex items-center gap-2 p-2 bg-gray-900 rounded-md">
                                    <img src="${deck.commander.image_uris.art_crop}" class="w-10 h-10 rounded-full">
                                    <span>1x ${deck.commander.name}</span>
                                </div>`
                                : ""
                            }
                             <div class="mt-4">
                                <h3 class="text-lg font-bold">Add Card to Deck</h3>
                                <div class="flex gap-2 mt-2">
                                    <input type="text" id="deck-card-search-input" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2" placeholder="Search for a card...">
                                    <button id="deck-search-btn" class="bg-indigo-600 hover:bg-indigo-700 px-4 rounded-lg flex items-center justify-center">
                                         <svg id="deck-search-icon" class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg>
                                    </button>
                                </div>
                            </div>
                            <div id="deck-card-list-container" class="mt-4">
                            </div>
                        </div>
                        <div class="lg:col-span-2 space-y-6">
                            <div class="bg-gray-800 p-4 rounded-lg"><h3 class="font-semibold mb-2">Mana Curve</h3><canvas id="mana-chart"></canvas></div>
                            <div class="bg-gray-800 p-6 rounded-lg">
                                <h3 class="font-semibold text-lg mb-4">Deck Notes</h3>
                                <div id="deck-notes-list" class="space-y-3 max-h-48 overflow-y-auto mb-4 pr-2">
                                    <!-- Notes will be rendered here -->
                                </div>
                                <textarea id="deck-note-input" class="w-full bg-gray-700 border border-gray-600 rounded-lg p-2 text-sm" rows="3" placeholder="Add a new note..."></textarea>
                                <button id="save-deck-note-btn" class="mt-2 w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 rounded-lg">Save Note</button>
                            </div>
                        </div>
                    </div>
                `;

          renderDeckCardList(deckId);
          renderDeckNotes(deckId);

          // Defer chart rendering to prevent context error
          setTimeout(() => {
            console.log("[renderSingleDeck] Rendering deck charts.");
            const manaChartEl = document.getElementById("mana-chart");
            const typeChartEl = document.getElementById("type-chart");
            const colorChartEl = document.getElementById("color-chart");

            if (manaChartEl) {
              // Simplified check since other charts were removed from HTML
              const { manaCurve, typeCounts, colorPipCounts } =
                calculateDeckStats(allDeckCards);
              destroyAllCharts();
              const chartOptions = {
                responsive: true,
                plugins: { legend: { labels: { color: "#D1D5DB" } } },
                scales: {
                  y: {
                    beginAtZero: true,
                    ticks: { color: "#D1D5DB", stepSize: 1 },
                  },
                  x: { ticks: { color: "#D1D5DB" } },
                },
              };

              const commanderColors = deck.commander?.color_identity || [
                "W",
                "U",
                "B",
                "R",
                "G",
              ];
              const filteredPipLabels = [
                "White",
                "Blue",
                "Black",
                "Red",
                "Green",
                "Colorless",
              ].filter((label, i) =>
                commanderColors.includes(["W", "U", "B", "R", "G", "C"][i])
              );
              const filteredPipData = Object.entries(colorPipCounts)
                .filter(([key, _]) => commanderColors.includes(key))
                .map(([_, val]) => val);
              const filteredPipColors = [
                "#F9FAFB",
                "#3B82F6",
                "#1F2937",
                "#EF4444",
                "#22C55E",
                "#9CA3AF",
              ].filter((_, i) =>
                commanderColors.includes(["W", "U", "B", "R", "G", "C"][i])
              );

              deckChartInstances.mana = new Chart(
                manaChartEl.getContext("2d"),
                {
                  type: "bar",
                  data: {
                    labels: ["0", "1", "2", "3", "4", "5", "6", "7+"],
                    datasets: [
                      {
                        label: "Mana Cost",
                        data: Object.values(manaCurve),
                        backgroundColor: "#4F46E5",
                      },
                    ],
                  },
                  options: chartOptions,
                }
              );
              // Other charts were removed from the provided HTML, so they are not rendered here.
            }
          }, 0);

          document
            .getElementById("back-to-decks")
            .addEventListener("click", () => {
              delete views.singleDeck.dataset.deckId;
              showView("decks");
            });
          const synopsisBtn = document.getElementById("view-ai-synopsis-btn");
          if (synopsisBtn) {
            synopsisBtn.addEventListener("click", () => {
              console.log("[Event: Click] View AI Strategy button clicked.");
              const modalContent = document.getElementById("ai-chat-history");
              document.getElementById("ai-suggestions-title").textContent =
                "AI Strategy Synopsis";
              modalContent.innerHTML = `<div class="p-4 bg-gray-700 rounded-lg"><p class="whitespace-pre-wrap">${deck.aiBlueprint.strategySynopsis}</p></div>`;
              document.getElementById("ai-chat-form").style.display = "none";
              showModal("ai-suggestions-modal");
            });
          }
          document
            .getElementById("get-ai-suggestions-btn")
            .addEventListener("click", (e) => {
              console.log("[Event: Click] Chat with AI button clicked.");
              document.getElementById("ai-suggestions-title").textContent =
                "Gemini Deck Suggestions";
              document.getElementById("ai-chat-form").style.display = "flex";
              handleAiChat(e.currentTarget.dataset.id);
            });
          document
            .getElementById("deck-search-btn")
            .addEventListener("click", () => {
              const query = document
                .getElementById("deck-card-search-input")
                .value.trim();
              if (!query) return;
              currentSearchContext = { mode: "deck", deckId: deckId };
              searchScryfall(query);
            });
          document
            .getElementById("deck-card-search-input")
            .addEventListener("keypress", (e) => {
              if (e.key === "Enter")
                document.getElementById("deck-search-btn").click();
            });
          document
            .getElementById("save-deck-note-btn")
            .addEventListener("click", () => handleSaveNote(deckId));
        }

        function renderDeckNotes(deckId) {
          console.log(
            `[Function: renderDeckNotes] Rendering notes for deck ID: ${deckId}. Find in <script> block.`
          );
          const deck = localDecks[deckId];
          const notesContainer = document.getElementById("deck-notes-list");
          if (!deck.notes || deck.notes.length === 0) {
            notesContainer.innerHTML = `<p class="text-gray-500 text-center text-sm">No notes yet.</p>`;
            return;
          }
          notesContainer.innerHTML = [...deck.notes]
            .reverse()
            .map(
              (note) => `
                    <div class="bg-gray-900/50 p-3 rounded-lg">
                        <p class="text-sm text-gray-300">${note.text}</p>
                        <p class="text-xs text-gray-500 text-right mt-1">${formatTimestamp(
                          note.timestamp.toDate()
                        )}</p>
                    </div>
                `
            )
            .join("");
        }

        async function handleSaveNote(deckId) {
          console.log(
            `[Function: handleSaveNote] Saving note for deck ID: ${deckId}. Find in <script> block.`
          );
          const input = document.getElementById("deck-note-input");
          const noteText = input.value.trim();
          if (!noteText) return;

          const newNote = {
            text: noteText,
            timestamp: new Date(),
          };

          try {
            console.log(
              `[handleSaveNote] Updating Firestore doc artifacts/${appId}/users/${userId}/decks/${deckId} with new note.`
            );
            await updateDoc(
              doc(db, `artifacts/${appId}/users/${userId}/decks`, deckId),
              {
                notes: arrayUnion(newNote),
              }
            );
            input.value = "";
          } catch (error) {
            console.error("[handleSaveNote] Error saving note:", error);
            showNotification("Error", "Could not save your note.");
          }
        }

        function calculateDeckStats(allDeckCards) {
          console.log(
            `[Function: calculateDeckStats] Calculating stats for ${allDeckCards.length} cards. Find in <script> block.`
          );
          const manaCurve = { 0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0 };
          const typeCounts = {};
          const colorPipCounts = { W: 0, U: 0, B: 0, R: 0, G: 0, C: 0 };

          allDeckCards.forEach((card) => {
            const count = card.count || 1;
            const mainType = card.type_line.split(" — ")[0];
            typeCounts[mainType] = (typeCounts[mainType] || 0) + count;
            if (!mainType.includes("Land")) {
              const cmc = Math.min(card.cmc || 0, 7);
              manaCurve[cmc] = (manaCurve[cmc] || 0) + count;
            }
            if (card.mana_cost) {
              for (const char of card.mana_cost.replace(/\{|\}/g, "")) {
                if ("WUBRGC".includes(char)) {
                  colorPipCounts[char] += count;
                }
              }
            }
          });
          return { manaCurve, typeCounts, colorPipCounts };
        }

        function getGradientColorForKpi(current, target) {
          if (target == null || target === 0) {
            return { barClass: "bg-gray-600", width: 0 };
          }
          const percent = Math.min((current / target) * 100, 100);
          let barClass = "bg-gradient-to-r from-red-500 to-red-700";
          if (percent > 95) {
            barClass = "bg-gradient-to-r from-green-400 to-green-600";
          } else if (percent > 70) {
            barClass = "bg-gradient-to-r from-yellow-400 to-yellow-600";
          }
          return { barClass, width: percent };
        }

        function renderDeckCardList(deckId) {
          console.log(
            `[Function: renderDeckCardList] Rendering card list for deck ID: ${deckId}. Find in <script> block.`
          );
          const deck = localDecks[deckId];
          const container = document.getElementById("deck-card-list-container");
          const cards = Object.values(deck.cards || {});

          const groups = cards.reduce((acc, card) => {
            const key = card.type_line.split(" — ")[0];
            (acc[key] = acc[key] || []).push(card);
            return acc;
          }, {});

          container.innerHTML = Object.keys(groups)
            .sort()
            .map(
              (groupName) => `
                    <h3 class="text-lg font-bold mt-4">${groupName} (${groups[
                groupName
              ].reduce((acc, c) => acc + c.count, 0)})</h3>
                    ${groups[groupName]
                      .map(
                        (card) => `
                        <div class="p-2 hover:bg-gray-700 rounded-md">
                            <div class="flex items-center justify-between">
                                <span class="text-sm">${card.count}x ${
                          card.name
                        }</span>
                                <div class="flex items-center gap-2">
                                     <span class="text-xs text-gray-400">${
                                       card.mana_cost || ""
                                     }</span>
                                     <button class="delete-button text-red-500 hover:text-red-400 text-lg" data-deck-id="${deckId}" data-card-id="${
                          card.firestoreId
                        }">&times;</button>
                                </div>
                            </div>
                            <p class="text-xs text-gray-500">${
                              card.type_line
                            } ${
                          card.power ? `| ${card.power}/${card.toughness}` : ""
                        }</p>
                        </div>
                    `
                      )
                      .join("")}
                `
            )
            .join("");

          container
            .querySelectorAll(".delete-button")
            .forEach((btn) =>
              btn.addEventListener("click", handleRemoveFromDeck)
            );
        }

        function renderSettingsPage() {
          console.log(
            "[Function: renderSettingsPage] Rendering settings page content. Find in <script> block."
          );
          const deckListContainer =
            document.getElementById("settings-deck-list");
          const deckIds = Object.keys(localDecks);
          if (deckIds.length === 0) {
            deckListContainer.innerHTML =
              '<p class="text-gray-500">No decks to manage.</p>';
          } else {
            deckListContainer.innerHTML = deckIds
              .map((id) => {
                const deck = localDecks[id];
                return `
                        <div class="bg-gray-700 p-3 rounded-lg flex justify-between items-center">
                            <p>${deck.name}</p>
                            <button class="delete-button bg-red-600 hover:bg-red-700 text-white font-bold py-1 px-3 rounded-lg" data-id="${id}">Delete</button>
                        </div>`;
              })
              .join("");
          }

          const settingsContainer = document.getElementById(
            "modal-visibility-settings"
          );
          settingsContainer.innerHTML = Object.entries(modalSettingOptions)
            .map(
              ([key, label]) => `
                    <div class="flex items-center">
                        <input id="setting-${key}" data-setting-key="${key}" type="checkbox" class="modal-setting-toggle h-4 w-4 rounded bg-gray-600 border-gray-500 text-indigo-600 focus:ring-indigo-500">
                        <label for="setting-${key}" class="ml-2 text-sm text-gray-300">${label}</label>
                    </div>
                `
            )
            .join("");
          updateSettingsCheckboxes();
          document
            .querySelectorAll(".modal-setting-toggle")
            .forEach((el) =>
              el.addEventListener("change", handleModalSettingChange)
            );
        }

        function loadModalSettings() {
          console.log(
            "[Function: loadModalSettings] Loading modal visibility settings from localStorage. Find in <script> block."
          );
          try {
            const storedSettings = localStorage.getItem(
              "mtgForgeModalSettings"
            );
            if (storedSettings) {
              modalVisibilitySettings = JSON.parse(storedSettings);
            } else {
              modalVisibilitySettings = Object.fromEntries(
                Object.keys(modalSettingOptions).map((key) => [key, true])
              );
            }
          } catch (e) {
            console.error(
              "[loadModalSettings] Error parsing settings from localStorage, using defaults.",
              e
            );
            modalVisibilitySettings = Object.fromEntries(
              Object.keys(modalSettingOptions).map((key) => [key, true])
            );
          }
        }

        function saveModalSettings() {
          console.log(
            "[Function: saveModalSettings] Saving modal visibility settings to localStorage. Find in <script> block."
          );
          localStorage.setItem(
            "mtgForgeModalSettings",
            JSON.stringify(modalVisibilitySettings)
          );
        }

        function updateSettingsCheckboxes() {
          for (const key in modalVisibilitySettings) {
            const checkbox = document.getElementById(`setting-${key}`);
            if (checkbox) {
              checkbox.checked = modalVisibilitySettings[key];
            }
          }
        }

        function handleModalSettingChange(e) {
          const key = e.target.dataset.settingKey;
          const isVisible = e.target.checked;
          console.log(
            `[Event: Change] Modal visibility setting changed for "${key}" to ${isVisible}.`
          );
          modalVisibilitySettings[key] = isVisible;
          saveModalSettings();
        }

        function showView(viewName) {
          console.log(
            `[Function: showView] Changing active view to "${viewName}". Find in <script> block.`
          );
          Object.values(views).forEach((v) => v.classList.add("hidden"));
          document.querySelectorAll(".nav-link").forEach((l) => {
            l.classList.remove("bg-indigo-600", "text-white");
            l.classList.add("text-gray-400", "hover:bg-gray-700");
          });

          let view, nav, title;
          if (viewName === "collection") {
            view = views.collection;
            nav = document.getElementById("nav-collection");
            title = "My Collection";
          } else if (viewName === "decks") {
            view = views.decks;
            nav = document.getElementById("nav-decks");
            title = "Decks";
          } else if (viewName === "singleDeck") {
            view = views.singleDeck;
            nav = document.getElementById("nav-decks");
            title = "Deck Details";
          } else if (viewName === "settings") {
            view = views.settings;
            nav = document.getElementById("nav-settings");
            title = "Settings";
          }

          if (view) view.classList.remove("hidden");
          if (nav) {
            nav.classList.add("bg-indigo-600", "text-white");
            nav.classList.remove("text-gray-400", "hover:bg-gray-700");
          }
          document.getElementById("page-title").textContent = title;
        }

        function setCollectionViewMode(mode) {
          console.log(
            `[Function: setCollectionViewMode] Setting collection view mode to "${mode}". Find in <script> block.`
          );
          collectionViewMode = mode;
          const gridBtn = document.getElementById("view-toggle-grid");
          const tableBtn = document.getElementById("view-toggle-table");

          if (mode === "grid") {
            gridBtn.classList.add("bg-indigo-600", "text-white");
            tableBtn.classList.remove("bg-indigo-600", "text-white");
            tableBtn.classList.add("text-gray-400");
          } else {
            // table
            tableBtn.classList.add("bg-indigo-600", "text-white");
            gridBtn.classList.remove("bg-indigo-600", "text-white");
            gridBtn.classList.add("text-gray-400");
          }
          renderCollection();
        }

        function showModal(modalId) {
          console.log(
            `[Function: showModal] Showing modal with ID: ${modalId}. Find in <script> block.`
          );
          document.getElementById(modalId).style.display = "flex";
        }
        function hideModal(modalId) {
          console.log(
            `[Function: hideModal] Hiding modal with ID: ${modalId}. Find in <script> block.`
          );
          document.getElementById(modalId).style.display = "none";
        }

        function showCardConfirmationModal(card) {
          console.log(
            `[Function: showCardConfirmationModal] Showing confirmation modal for card: ${card.name}. Find in <script> block.`
          );
          currentCardForAdd = card;
          const content = document.getElementById("card-confirmation-content");
          const finishes = card.finishes
            .map(
              (f) =>
                `<option value="${f}">${
                  f.charAt(0).toUpperCase() + f.slice(1)
                }</option>`
            )
            .join("");

          let buttonText = "Add to Collection";
          if (currentSearchContext.mode === "deck") {
            buttonText = "Add to Deck";
          }

          content.innerHTML = `
                    <div><img src="${card.image_uris.large}" alt="${card.name}" class="rounded-lg w-full"></div>
                    <div class="flex flex-col">
                        <h3 class="text-2xl font-bold">${card.name}</h3>
                        <p class="text-gray-400">${card.set_name}</p>
                        <div class="my-4 space-y-4">
                            <div>
                                <label for="card-finish" class="block text-sm font-medium text-gray-300">Finish</label>
                                <select id="card-finish" class="w-full mt-1 bg-gray-700 rounded-lg p-2">${finishes}</select>
                            </div>
                            <div>
                                <label for="card-count" class="block text-sm font-medium text-gray-300">Quantity</label>
                                <input type="number" id="card-count" value="1" min="1" class="w-full mt-1 bg-gray-700 rounded-lg p-2">
                            </div>
                        </div>
                        <div class="mt-auto flex justify-end gap-4">
                            <button id="cancel-add-card-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg">Cancel</button>
                            <button id="confirm-add-card-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg">${buttonText}</button>
                        </div>
                    </div>
                `;
          showModal("card-confirmation-modal");
        }

        function showCardDetailsModal(card, startInEditMode = false) {
          console.log(
            `[Function: showCardDetailsModal] Showing details modal for card: ${card.name}. Find in <script> block.`
          );
          const contentWrapper = document.getElementById(
            "card-details-modal-content-wrapper"
          );
          const content = document.getElementById("card-details-content");
          const na = (val) => (val != null ? val : "N/A");

          const legalitiesHTML = Object.entries(card.legalities || {})
            .map(
              ([format, legality]) => `
                    <span class="px-2 py-1 text-xs rounded-full ${
                      legality === "legal"
                        ? "bg-green-800 text-green-200"
                        : "bg-red-800 text-red-200"
                    }">${format.replace(/_/g, " ")}</span>`
            )
            .join("");

          content.innerHTML = `
                <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                    <div class="md:col-span-1">
                        <img src="${
                          card.image_uris?.large ||
                          "https://placehold.co/600x840/1f2937/9ca3af?text=No+Image"
                        }" alt="${card.name}" class="rounded-lg w-full">
                    </div>
                    <div class="md:col-span-2 space-y-4 max-h-[75vh] overflow-y-auto no-scrollbar pr-2" data-firestore-id="${
                      card.firestoreId
                    }">
                        <div class="flex justify-between items-start">
                             <div>
                                <h2 class="text-2xl font-bold">${card.name}</h2>
                                <p class="text-lg text-gray-400">${
                                  card.mana_cost || ""
                                }</p>
                            </div>
                            <div id="card-modal-edit-controls" class="hidden flex-shrink-0 ml-4">
                                <button id="cancel-card-edit-btn" class="bg-gray-600 text-xs px-2 py-1 rounded">Cancel</button>
                                <button id="save-card-edit-btn" class="bg-green-600 text-xs px-2 py-1 rounded ml-2">Save</button>
                            </div>
                        </div>
                        <p class="text-md font-semibold">${card.type_line}</p>
                        <p class="text-gray-300 whitespace-pre-wrap">${
                          card.oracle_text || ""
                        }</p>
                        ${
                          card.power
                            ? `<p class="font-bold text-lg">${card.power}/${card.toughness}</p>`
                            : ""
                        }
                        ${
                          card.loyalty
                            ? `<p class="font-bold text-lg">Loyalty: ${card.loyalty}</p>`
                            : ""
                        }
                        ${
                          modalVisibilitySettings.flavor && card.flavor_text
                            ? `<p class="text-gray-400 italic">"${card.flavor_text}"</p>`
                            : ""
                        }
                        
                        <div class="bg-gray-700 p-3 rounded-lg">
                            <h4 class="font-semibold mb-2">Your Card</h4>
                            <p><span class="text-gray-400">Quantity:</span> <span class="card-modal-value-display">${
                              card.count
                            }</span><input data-value-key="count" type="number" min="1" class="card-modal-value-input w-20 bg-gray-800 p-1 rounded" value="${
            card.count
          }"></p>
                            <p><span class="text-gray-400">Finish:</span> <span class="capitalize">${
                              card.finish
                            }</span></p>
                        </div>
                        
                        ${
                          modalVisibilitySettings.prices
                            ? `
                        <div class="bg-gray-700 p-3 rounded-lg">
                            <h4 class="font-semibold mb-2">Prices</h4>
                            <div class="grid grid-cols-2 gap-2 text-sm">
                                <p><span class="text-gray-400">USD:</span> <span class="card-modal-value-display">$${na(
                                  card.prices.usd
                                )}</span><input data-price-key="usd" type="number" class="card-modal-value-input w-full bg-gray-800 p-1 rounded" value="${
                                card.prices.usd || ""
                              }"></p>
                                <p><span class="text-gray-400">USD Foil:</span> <span class="card-modal-value-display">$${na(
                                  card.prices.usd_foil
                                )}</span><input data-price-key="usd_foil" type="number" class="card-modal-value-input w-full bg-gray-800 p-1 rounded" value="${
                                card.prices.usd_foil || ""
                              }"></p>
                                <p><span class="text-gray-400">EUR:</span> <span class="card-modal-value-display">€${na(
                                  card.prices.eur
                                )}</span><input data-price-key="eur" type="number" class="card-modal-value-input w-full bg-gray-800 p-1 rounded" value="${
                                card.prices.eur || ""
                              }"></p>
                                <p><span class="text-gray-400">EUR Foil:</span> <span class="card-modal-value-display">€${na(
                                  card.prices.eur_foil
                                )}</span><input data-price-key="eur_foil" type="number" class="card-modal-value-input w-full bg-gray-800 p-1 rounded" value="${
                                card.prices.eur_foil || ""
                              }"></p>
                            </div>
                        </div>`
                            : ""
                        }

                        ${
                          modalVisibilitySettings.printing
                            ? `
                        <div class="bg-gray-700 p-3 rounded-lg">
                            <h4 class="font-semibold mb-2">Printing Details</h4>
                            <div class="grid grid-cols-2 gap-2 text-sm">
                                <p><span class="text-gray-400">Rarity:</span> <span class="capitalize">${
                                  card.rarity
                                }</span></p>
                                <p><span class="text-gray-400">Set:</span> ${
                                  card.set_name
                                }</p>
                                <p><span class="text-gray-400">Collector #:</span> ${
                                  card.collector_number
                                }</p>
                                <p><span class="text-gray-400">Artist:</span> ${
                                  card.artist
                                }</p>
                                <p><span class="text-gray-400">Released:</span> ${
                                  card.released_at
                                }</p>
                                <p><span class="text-gray-400">EDHREC Rank:</span> ${
                                  card.edhrec_rank || "N/A"
                                }</p>
                            </div>
                        </div>`
                            : ""
                        }
                        
                        ${
                          modalVisibilitySettings.legalities
                            ? `
                        <div class="bg-gray-700 p-3 rounded-lg">
                            <h4 class="font-semibold mb-2">Format Legality</h4>
                            <div class="flex flex-wrap gap-2">${legalitiesHTML}</div>
                        </div>`
                            : ""
                        }

                         ${
                           modalVisibilitySettings.rulings
                             ? `<a href="${
                                 card.related_uris?.gatherer ||
                                 card.scryfall_uri
                               }" target="_blank" class="block w-full text-center bg-gray-600 hover:bg-gray-500 p-2 rounded-lg text-sm">View Rulings on Scryfall/Gatherer</a>`
                             : ""
                         }
                    </div>
                </div>`;
          showModal("card-details-modal");

          if (startInEditMode) {
            contentWrapper.classList.add("card-modal-edit-mode");
            document.getElementById("card-modal-edit-controls").style.display =
              "flex";
          }
        }

        function clearUI() {
          console.log(
            "[Function: clearUI] Clearing all dynamic UI content. Find in <script> block."
          );
          document.getElementById("collection-content").innerHTML = "";
          document.getElementById("decks-list").innerHTML = "";
          document.getElementById("single-deck-view").innerHTML = "";
          document.getElementById("settings-deck-list").innerHTML =
            '<p class="text-gray-500">No decks to manage.</p>';
          document.getElementById("no-cards-msg").style.display = "block";
          document.getElementById("no-decks-msg").style.display = "block";

          localCollection = {};
          localDecks = {};
        }

        function escapeHtml(str) {
          if (typeof str !== "string") return "";
          return str
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");
        }

        function toggleSearchSpinner(isLoading, btnId = "search-card-btn") {
          const searchBtn = document.getElementById(btnId);
          if (!searchBtn) return;
          const searchSpinner = searchBtn.querySelector("div");
          const searchIcon = searchBtn.querySelector("svg");
          const searchText = searchBtn.querySelector("span");

          if (searchSpinner)
            searchSpinner.style.display = isLoading ? "inline-block" : "none";
          if (searchIcon)
            searchIcon.style.display = isLoading ? "none" : "inline-block";
          if (searchText)
            searchText.style.display = isLoading ? "none" : "inline-block";
          if (searchBtn) searchBtn.disabled = isLoading;
        }

        function destroyAllCharts() {
          console.log(
            "[Function: destroyAllCharts] Destroying all active Chart.js instances. Find in <script> block."
          );
          Object.values(deckChartInstances).forEach((chart) => {
            if (chart) chart.destroy();
          });
          deckChartInstances = {};
        }

        function updateSortHeaders() {
          document.querySelectorAll(".sortable").forEach((th) => {
            th.classList.remove("sort-asc", "sort-desc");
            if (th.dataset.sort === collectionSortState.column) {
              th.classList.add(
                collectionSortState.direction === "asc"
                  ? "sort-asc"
                  : "sort-desc"
              );
            }
          });
        }

        function showConfirmationModal(title, message, onConfirm) {
          console.log(
            `[Function: showConfirmationModal] Showing confirmation modal. Title: "${title}". Find in <script> block.`
          );
          const modal = document.getElementById("confirmation-modal");
          document.getElementById("confirmation-title").textContent = title;
          document.getElementById("confirmation-message").textContent = message;

          const confirmBtn = document.getElementById("confirm-action-btn");
          const cancelBtn = document.getElementById("cancel-action-btn");

          const confirmHandler = () => {
            console.log(
              `[ConfirmationModal] User confirmed action: "${title}"`
            );
            onConfirm();
            hide();
          };

          const hide = () => {
            modal.style.display = "none";
            confirmBtn.removeEventListener("click", confirmHandler);
            cancelBtn.removeEventListener("click", hide);
          };

          confirmBtn.addEventListener("click", confirmHandler, { once: true });
          cancelBtn.addEventListener("click", hide, { once: true });
          modal.style.display = "flex";
        }

        function showNotification(title, message) {
          console.log(
            `[Function: showNotification] Showing notification modal. Title: "${title}", Message: "${message}". Find in <script> block.`
          );
          const modal = document.getElementById("notification-modal");
          modal.querySelector("#notification-title").textContent = title;
          modal.querySelector("#notification-message").textContent = message;
          modal.style.display = "flex";
        }

        async function handleAddCardToCollection() {
          console.log(
            "[Function: handleAddCardToCollection] Attempting to add card. Find in <script> block."
          );
          if (!userId || !currentCardForAdd) {
            console.error(
              "[handleAddCardToCollection] Aborting: userId or currentCardForAdd is missing."
            );
            return;
          }

          const finish = document.getElementById("card-finish").value;
          const count = parseInt(
            document.getElementById("card-count").value,
            10
          );
          if (isNaN(count) || count < 1) return;

          if (
            currentSearchContext.mode === "deck" &&
            currentSearchContext.deckId
          ) {
            console.log(
              `[handleAddCardToCollection] Context is 'deck'. Passing to handleAddCardToDeck for deck ID ${currentSearchContext.deckId}.`
            );
            await handleAddCardToDeck(
              currentCardForAdd,
              { finish, count },
              currentSearchContext.deckId
            );
          } else {
            console.log(`[handleAddCardToCollection] Context is 'collection'.`);
            const existingCard = Object.values(localCollection).find(
              (card) =>
                card.id === currentCardForAdd.id && card.finish === finish
            );
            try {
              if (existingCard) {
                const newCount = (existingCard.count || 1) + count;
                console.log(
                  `[handleAddCardToCollection] Card exists. Updating count to ${newCount} for Firestore doc ${existingCard.firestoreId}.`
                );
                await updateDoc(
                  doc(
                    db,
                    `artifacts/${appId}/users/${userId}/cards`,
                    existingCard.firestoreId
                  ),
                  {
                    count: newCount,
                  }
                );
              } else {
                const cardData = {
                  ...currentCardForAdd,
                  finish,
                  count,
                  deckId: null,
                  isCommander: false,
                };
                delete cardData.firestoreId;
                console.log(
                  `[handleAddCardToCollection] New card. Adding to Firestore.`,
                  cardData
                );
                await addDoc(
                  collection(db, `artifacts/${appId}/users/${userId}/cards`),
                  cardData
                );
              }
            } catch (error) {
              console.error(
                "[handleAddCardToCollection] Error adding card:",
                error
              );
              showNotification(
                "Error",
                "Could not add card to your collection."
              );
            }
          }

          hideModal("card-confirmation-modal");
          currentCardForAdd = null;
        }

        async function handleAddCardToDeck(card, options, deckId) {
          console.log(
            `[Function: handleAddCardToDeck] Adding card "${card.name}" to deck ${deckId}. Find in <script> block.`
          );
          if (!userId || !deckId) return;
          const deck = localDecks[deckId];
          if (!deck) return;

          const { finish, count } = options;

          let collectionCard = Object.values(localCollection).find(
            (c) => c.id === card.id && c.finish === finish
          );
          let collectionCardId;

          if (collectionCard) {
            collectionCardId = collectionCard.firestoreId;
            console.log(
              `[handleAddCardToDeck] Found existing card in collection with firestoreId ${collectionCardId}.`
            );
          } else {
            console.log(
              `[handleAddCardToDeck] Card not in collection. Adding it now.`
            );
            const cardData = {
              ...card,
              finish,
              count,
              deckId: null,
              isCommander: false,
            };
            delete cardData.firestoreId;
            const newDocRef = await addDoc(
              collection(db, `artifacts/${appId}/users/${userId}/cards`),
              cardData
            );
            collectionCardId = newDocRef.id;
            console.log(
              `[handleAddCardToDeck] New card added to collection with firestoreId ${collectionCardId}.`
            );
          }

          const updatedCards = { ...deck.cards };
          const deckCardKey = `${card.id}-${finish}`;

          if (updatedCards[deckCardKey]) {
            updatedCards[deckCardKey].count += count;
          } else {
            updatedCards[deckCardKey] = {
              firestoreId: collectionCardId,
              id: card.id,
              name: card.name,
              mana_cost: card.mana_cost,
              type_line: card.type_line,
              power: card.power || null,
              toughness: card.toughness || null,
              count: count,
            };
          }

          try {
            console.log(
              `[handleAddCardToDeck] Updating deck document ${deckId} in Firestore.`
            );
            await updateDoc(
              doc(db, `artifacts/${appId}/users/${userId}/decks`, deckId),
              {
                cards: updatedCards,
              }
            );
          } catch (e) {
            console.error(
              "[handleAddCardToDeck] Error adding card to deck:",
              e
            );
            showNotification("Error", "Could not add card to deck.");
          }
        }

        async function handleRemoveFromDeck(e) {
          const { deckId, cardId } = e.target.closest("button").dataset;
          console.log(
            `[Function: handleRemoveFromDeck] Removing card ${cardId} from deck ${deckId}. Find in <script> block.`
          );
          const deck = localDecks[deckId];
          if (!deck || !deck.cards) return;

          const cardKeyToRemove = Object.keys(deck.cards).find(
            (key) => deck.cards[key].firestoreId === cardId
          );

          if (!cardKeyToRemove) {
            console.error(
              "[handleRemoveFromDeck] Could not find card in deck to remove with firestoreId:",
              cardId
            );
            return;
          }

          const updatedCards = { ...deck.cards };
          if (updatedCards[cardKeyToRemove].count > 1) {
            updatedCards[cardKeyToRemove].count--;
          } else {
            delete updatedCards[cardKeyToRemove];
          }

          try {
            console.log(
              `[handleRemoveFromDeck] Updating deck document ${deckId} in Firestore.`
            );
            await updateDoc(
              doc(db, `artifacts/${appId}/users/${userId}/decks`, deckId),
              { cards: updatedCards }
            );
          } catch (error) {
            console.error(
              "[handleRemoveFromDeck] Error removing card from deck: ",
              error
            );
          }
        }

        function handleDeleteCard(firestoreId) {
          console.log(
            `[Function: handleDeleteCard] Initiating delete for card stack with firestoreId: ${firestoreId}. Find in <script> block.`
          );
          if (!userId || !firestoreId) return;
          showConfirmationModal(
            "Delete Card Stack?",
            "This will permanently remove this stack of cards from your collection.",
            async () => {
              try {
                console.log(
                  `[handleDeleteCard] User confirmed. Deleting doc artifacts/${appId}/users/${userId}/cards/${firestoreId}.`
                );
                await deleteDoc(
                  doc(
                    db,
                    `artifacts/${appId}/users/${userId}/cards`,
                    firestoreId
                  )
                );
              } catch (error) {
                console.error("[handleDeleteCard] Error deleting card:", error);
              }
            }
          );
        }

        async function handleSaveDeck(event) {
          event.preventDefault();
          console.log(
            "[Function: handleSaveDeck] Deck creation form submitted. Find in <script> block."
          );
          const deckName = document
            .getElementById("deck-name-input")
            .value.trim();
          const format = document.getElementById("deck-format-select").value;

          if (!userId) return;
          if (format === "commander" && !currentCommanderForAdd) {
            showNotification(
              "Error",
              "Please select a commander for your deck."
            );
            return;
          }

          if (format === "commander") {
            const blueprint = await getAiDeckBlueprint(
              currentCommanderForAdd,
              deckName
            );
            if (blueprint) {
              tempAiBlueprint = blueprint;
              hideModal("deck-creation-modal"); // Hide creation modal first
              document.getElementById("ai-blueprint-content").innerHTML = `
                            <h4 class="font-semibold mb-2 text-lg text-indigo-300">Strategy Synopsis</h4>
                            <p class="text-gray-300 whitespace-pre-wrap text-sm">${
                              blueprint.strategySynopsis
                            }</p>
                            <h4 class="font-semibold mb-2 mt-4 text-lg text-indigo-300">Suggested Card Counts</h4>
                            <ul class="list-disc list-inside text-sm">
                                ${Object.entries(blueprint.suggestedCounts)
                                  .map(
                                    ([type, count]) =>
                                      `<li>${type}: ${count}</li>`
                                  )
                                  .join("")}
                            </ul>
                        `;
              showModal("ai-blueprint-modal");
            } else {
              // If AI fails, create deck without blueprint
              console.log(
                "[handleSaveDeck] AI blueprint failed, creating deck without it."
              );
              await createDeckInFirestore(deckName, format, null);
            }
          } else {
            if (!deckName) {
              showNotification("Error", "Please enter a deck name.");
              return;
            }
            await createDeckInFirestore(deckName, format, null);
          }
        }

        async function createDeckInFirestore(name, format, blueprint) {
          console.log(
            `[Function: createDeckInFirestore] Creating new deck in Firestore. Name: "${name}". Find in <script> block.`
          );
          const newDeck = {
            name: name,
            format: format,
            cards: {},
            notes: [],
            commander: format === "commander" ? currentCommanderForAdd : null,
            aiBlueprint: blueprint,
            createdAt: new Date(),
          };

          try {
            const newDocRef = await addDoc(
              collection(db, `artifacts/${appId}/users/${userId}/decks`),
              newDeck
            );
            console.log(
              `[createDeckInFirestore] Successfully created deck with new ID: ${newDocRef.id}.`
            );
            hideModal("deck-creation-modal");
            hideModal("ai-blueprint-modal");
            // Wait a moment for firestore to update local state via onSnapshot
            setTimeout(() => {
              renderSingleDeck(newDocRef.id);
              showView("singleDeck");
            }, 500);
          } catch (error) {
            console.error(
              "[createDeckInFirestore] Error creating deck:",
              error
            );
            showNotification("Error", "Failed to create the deck.");
          }
        }

        function handleDeleteDeck(deckId) {
          console.log(
            `[Function: handleDeleteDeck] Showing delete options for deck ID: ${deckId}. Find in <script> block.`
          );
          if (!userId || !deckId) return;
          const modal = document.getElementById("deck-delete-options-modal");

          const deleteAndCardsBtn = document.getElementById(
            "delete-deck-and-cards-btn"
          );
          const deleteOnlyBtn = document.getElementById("delete-deck-only-btn");
          const cancelBtn = document.getElementById("cancel-delete-deck-btn");

          const cleanUp = () => {
            hideModal("deck-delete-options-modal");
            deleteAndCardsBtn.removeEventListener(
              "click",
              deleteAndCardsHandler
            );
            deleteOnlyBtn.removeEventListener("click", deleteOnlyHandler);
            cancelBtn.removeEventListener("click", cleanUp);
          };

          const deleteAndCardsHandler = () => {
            console.log(
              `[handleDeleteDeck] User chose to delete deck AND cards for deck ID: ${deckId}.`
            );
            deleteDeckAndCards(deckId);
            cleanUp();
          };
          const deleteOnlyHandler = () => {
            console.log(
              `[handleDeleteDeck] User chose to delete deck ONLY for deck ID: ${deckId}.`
            );
            deleteDeckOnly(deckId);
            cleanUp();
          };

          deleteAndCardsBtn.addEventListener("click", deleteAndCardsHandler, {
            once: true,
          });
          deleteOnlyBtn.addEventListener("click", deleteOnlyHandler, {
            once: true,
          });
          cancelBtn.addEventListener("click", cleanUp, { once: true });

          showModal("deck-delete-options-modal");
        }

        async function deleteDeckOnly(deckId) {
          console.log(
            `[Function: deleteDeckOnly] Deleting only the deck document for ID: ${deckId}. Find in <script> block.`
          );
          try {
            await deleteDoc(
              doc(db, `artifacts/${appId}/users/${userId}/decks`, deckId)
            );
          } catch (error) {
            console.error("[deleteDeckOnly] Error deleting deck:", error);
          }
        }

        async function deleteDeckAndCards(deckId) {
          console.log(
            `[Function: deleteDeckAndCards] Deleting deck AND associated cards from collection for deck ID: ${deckId}. Find in <script> block.`
          );
          const deck = localDecks[deckId];
          if (!deck) return;

          const batch = writeBatch(db);
          const cardsInDeck = Object.values(deck.cards || {});
          if (deck.commander) {
            cardsInDeck.push({
              ...deck.commander,
              count: 1,
              firestoreId: deck.commander.firestoreId,
            });
          }

          try {
            for (const deckCard of cardsInDeck) {
              const cardRef = doc(
                db,
                `artifacts/${appId}/users/${userId}/cards`,
                deckCard.firestoreId
              );
              const cardDoc = await getDoc(cardRef);
              if (cardDoc.exists()) {
                const collectionCard = cardDoc.data();
                const newCount = collectionCard.count - deckCard.count;
                if (newCount <= 0) {
                  console.log(
                    `[deleteDeckAndCards] Queuing deletion for card doc ${deckCard.firestoreId}.`
                  );
                  batch.delete(cardRef);
                } else {
                  console.log(
                    `[deleteDeckAndCards] Queuing update for card doc ${deckCard.firestoreId} to new count ${newCount}.`
                  );
                  batch.update(cardRef, { count: newCount });
                }
              }
            }

            console.log(
              `[deleteDeckAndCards] Queuing deletion for deck doc ${deckId}.`
            );
            batch.delete(
              doc(db, `artifacts/${appId}/users/${userId}/decks`, deckId)
            );
            await batch.commit();
            console.log(`[deleteDeckAndCards] Batch commit successful.`);
          } catch (error) {
            console.error(
              "[deleteDeckAndCards] Error deleting deck and cards:",
              error
            );
            showNotification("Error", "Could not fully delete deck and cards.");
          }
        }

        async function handleSaveCardDetails() {
          console.log(
            "[Function: handleSaveCardDetails] Saving edited card details. Find in <script> block."
          );
          const contentWrapper = document.getElementById(
            "card-details-modal-content-wrapper"
          );
          const cardDetailsDiv = contentWrapper.querySelector(
            "[data-firestore-id]"
          );
          if (!cardDetailsDiv) return;

          const firestoreId = cardDetailsDiv.dataset.firestoreId;
          const originalCard = localCollection[firestoreId];
          if (!originalCard) return;

          const updatedValues = {};

          const qtyInput = cardDetailsDiv.querySelector(
            'input[data-value-key="count"]'
          );
          const newCount = parseInt(qtyInput.value, 10);
          if (!isNaN(newCount) && newCount > 0) {
            updatedValues.count = newCount;
          } else {
            showNotification(
              "Invalid Input",
              "Quantity must be a number greater than 0."
            );
            return;
          }

          const updatedPrices = { ...originalCard.prices };
          cardDetailsDiv
            .querySelectorAll("input[data-price-key]")
            .forEach((input) => {
              const key = input.dataset.priceKey;
              const value = parseFloat(input.value);
              updatedPrices[key] = !isNaN(value) ? value : null;
            });
          updatedValues.prices = updatedPrices;

          try {
            console.log(
              `[handleSaveCardDetails] Updating Firestore doc ${firestoreId} with new data:`,
              updatedValues
            );
            await updateDoc(
              doc(db, `artifacts/${appId}/users/${userId}/cards`, firestoreId),
              updatedValues
            );
            contentWrapper.classList.remove("card-modal-edit-mode");
            document.getElementById("card-modal-edit-controls").style.display =
              "none";
          } catch (error) {
            console.error(
              "[handleSaveCardDetails] Error updating card details:",
              error
            );
            showNotification(
              "Update Failed",
              "Could not save the new card data."
            );
          }
        }

        function formatTimestamp(date) {
          if (!date) return "";
          const pad = (n) => (n < 10 ? "0" + n : n);
          const mm = pad(date.getMonth() + 1);
          const dd = pad(date.getDate());
          const yy = String(date.getFullYear()).slice(-2);
          const hh = pad(date.getHours());
          const min = pad(date.getMinutes());
          return `${mm}/${dd}/${yy} ${hh}:${min}`;
        }

        function setupEventListeners() {
          console.log(
            "[Function: setupEventListeners] Attaching event listeners to DOM elements. Find in <script> block."
          );
          // Login
          document
            .getElementById("login-with-google-btn")
            .addEventListener("click", () =>
              signInWithPopup(auth, new GoogleAuthProvider()).catch((err) =>
                showNotification("Login Failed", err.message)
              )
            );
          document
            .getElementById("email-login-btn")
            .addEventListener("click", () => {
              const e = document.getElementById("email").value,
                p = document.getElementById("password").value;
              if (e && p)
                signInWithEmailAndPassword(auth, e, p).catch((err) =>
                  showNotification("Login Failed", err.message)
                );
            });
          document
            .getElementById("signup-btn")
            .addEventListener("click", () => {
              const e = document.getElementById("email").value,
                p = document.getElementById("password").value;
              if (e && p)
                createUserWithEmailAndPassword(auth, e, p).catch((err) =>
                  showNotification("Sign Up Failed", err.message)
                );
            });
          document
            .getElementById("logout-btn")
            .addEventListener("click", () => {
              console.log("[Event: Click] Logout button clicked.");
              signOut(auth);
            });

          // Navigation
          document
            .getElementById("nav-collection")
            .addEventListener("click", () => showView("collection"));
          document
            .getElementById("nav-decks")
            .addEventListener("click", () => showView("decks"));
          document
            .getElementById("nav-settings")
            .addEventListener("click", () => showView("settings"));
          document
            .getElementById("nav-rule-lookup")
            .addEventListener("click", () => {
              console.log(
                "[Event: Click] 'Rule Lookup' navigation button clicked."
              );
              ruleLookupHistory = [];
              document.getElementById(
                "rule-lookup-history"
              ).innerHTML = `<div class="bg-gray-700 p-3 rounded-lg"><p>Ask a Magic: The Gathering rule question below. For example, "What is banding?" or "How does cascade work?".</p></div>`;
              showModal("rule-lookup-modal");
            });
          document
            .getElementById("nav-general-chat")
            .addEventListener("click", () => {
              console.log(
                "[Event: Click] 'MTG Chat' navigation button clicked."
              );
              mtgChatHistory = [];
              document.getElementById(
                "mtg-chat-history"
              ).innerHTML = `<div class="bg-gray-700 p-3 rounded-lg"><p>Welcome! Ask me anything about MTG strategy, lore, deck building, or cards.</p></div>`;
              showModal("mtg-chat-modal");
            });

          // Main Actions
          document
            .getElementById("new-player-guide-btn")
            .addEventListener("click", () => {
              console.log("[Event: Click] New Player Guide button clicked.");
              showModal("new-player-guide-modal");
            });
          document
            .getElementById("edit-mode-toggle")
            .addEventListener("click", () => {
              const isActive = document.body.classList.toggle("edit-mode");
              console.log(
                `[Event: Click] Edit Mode toggled. Is active: ${isActive}.`
              );
              const btn = document.getElementById("edit-mode-toggle");
              const btnText = document.getElementById("edit-mode-text");
              if (isActive) {
                btnText.textContent = "Exit Edit";
                btn.classList.replace("bg-yellow-600", "bg-red-600");
                btn.classList.replace(
                  "hover:bg-yellow-700",
                  "hover:bg-red-700"
                );
              } else {
                btnText.textContent = "Edit Mode";
                btn.classList.replace("bg-red-600", "bg-yellow-600");
                btn.classList.replace(
                  "hover:bg-red-700",
                  "hover:bg-yellow-700"
                );
              }
              renderCollection(); // Re-render to enable/disable sorting
            });
          document
            .getElementById("search-card-btn")
            .addEventListener("click", () => {
              currentSearchContext.mode = "collection";
              const q = document
                .getElementById("card-search-input")
                .value.trim();
              if (q) searchScryfall(q);
            });
          document
            .getElementById("card-search-input")
            .addEventListener("keypress", (e) => {
              if (e.key === "Enter")
                document.getElementById("search-card-btn").click();
            });

          // Collection View Toggles & Filters
          document.querySelectorAll(".grid-size-btn").forEach((btn) =>
            btn.addEventListener("click", (e) => {
              collectionGridSize = e.currentTarget.dataset.size;
              document.querySelectorAll(".grid-size-btn").forEach((b) => {
                b.classList.remove("bg-indigo-600", "text-white");
                b.classList.add("text-gray-400");
              });
              e.currentTarget.classList.add("bg-indigo-600", "text-white");
              e.currentTarget.classList.remove("text-gray-400");
              saveViewSettings();
              renderCollection();
            })
          );
          document
            .getElementById("view-toggle-grid")
            .addEventListener("click", () => {
              setCollectionViewMode("grid");
              saveViewSettings();
            });
          document
            .getElementById("view-toggle-table")
            .addEventListener("click", () => {
              setCollectionViewMode("table");
              saveViewSettings();
            });
          document
            .getElementById("filter-text")
            .addEventListener("input", renderCollection);
          document
            .getElementById("collection-group-by")
            .addEventListener("change", renderCollection);
          document
            .getElementById("hide-in-deck-checkbox")
            .addEventListener("change", () => {
              saveViewSettings();
              renderCollection();
            });
          document
            .getElementById("reset-filters-btn")
            .addEventListener("click", () => {
              console.log("[Event: Click] Reset filters button clicked.");
              document.getElementById("filter-text").value = "";
              document.getElementById("collection-group-by").value = "";
              document.getElementById("hide-in-deck-checkbox").checked = false;
              renderCollection();
            });

          // Modals
          document.querySelectorAll(".modal-backdrop").forEach((modal) => {
            modal.addEventListener("click", (e) => {
              if (e.target === modal) hideModal(modal.id);
            });
          });
          document.addEventListener("keydown", (e) => {
            if (e.key === "Escape") {
              document
                .querySelectorAll(".modal-backdrop")
                .forEach((m) => hideModal(m.id));
            }
          });
          document
            .getElementById("notification-close-btn")
            .addEventListener("click", () => hideModal("notification-modal"));

          // Card Versions Modal
          document
            .getElementById("close-versions-modal-btn")
            .addEventListener("click", () => hideModal("card-versions-modal"));
          document
            .getElementById("card-versions-grid")
            .addEventListener("click", (e) => {
              const cardElement = e.target.closest(".group");
              if (cardElement) {
                const cardData = JSON.parse(cardElement.dataset.card);
                console.log(
                  `[Event: Click] Card version selected: ${cardData.name} (${cardData.set}).`
                );
                hideModal("card-versions-modal");
                if (currentSearchContext.mode === "commander") {
                  selectCommander(cardData);
                } else {
                  showCardConfirmationModal(cardData);
                }
              }
            });

          // Card Confirmation Modal
          document.addEventListener("click", (e) => {
            if (e.target.id === "cancel-add-card-btn")
              hideModal("card-confirmation-modal");
            if (e.target.id === "confirm-add-card-btn")
              handleAddCardToCollection();
          });

          // AI Suggestions Modal
          document
            .getElementById("close-ai-modal-btn")
            .addEventListener("click", () => hideModal("ai-suggestions-modal"));
          document
            .getElementById("ai-chat-form")
            .addEventListener("submit", (e) => {
              e.preventDefault();
              const input = document.getElementById("ai-chat-input");
              const message = input.value.trim();
              const singleDeckView =
                document.getElementById("single-deck-view");
              const deckId = singleDeckView.dataset.deckId;
              if (message && deckId) {
                handleAiChat(deckId, message);
                input.value = "";
              }
            });

          // Rule Lookup Modal
          document
            .getElementById("close-rule-lookup-modal-btn")
            .addEventListener("click", () => hideModal("rule-lookup-modal"));
          document
            .getElementById("rule-lookup-form")
            .addEventListener("submit", (e) => {
              e.preventDefault();
              console.log("[Event: Submit] Rule lookup form submitted.");
              const input = document.getElementById("rule-lookup-input");
              const query = input.value.trim();
              if (query) {
                handleRuleLookup(query);
                input.value = "";
              }
            });

          // MTG Chat Modal
          document
            .getElementById("close-mtg-chat-modal-btn")
            .addEventListener("click", () => hideModal("mtg-chat-modal"));
          document
            .getElementById("mtg-chat-form")
            .addEventListener("submit", (e) => {
              e.preventDefault();
              console.log("[Event: Submit] MTG chat form submitted.");
              const input = document.getElementById("mtg-chat-input");
              const message = input.value.trim();
              if (message) {
                handleMtgChat(message);
                input.value = "";
              }
            });

          // New Player Guide Modal
          document
            .getElementById("close-new-player-guide-modal-btn")
            .addEventListener("click", () =>
              hideModal("new-player-guide-modal")
            );

          // Card Details Modal
          document
            .getElementById("close-card-details-btn")
            .addEventListener("click", () => hideModal("card-details-modal"));
          document
            .getElementById("edit-card-details-btn")
            .addEventListener("click", () => {
              console.log("[Event: Click] Edit Card Details button clicked.");
              const contentWrapper = document.getElementById(
                "card-details-modal-content-wrapper"
              );
              contentWrapper.classList.add("card-modal-edit-mode");
              document.getElementById(
                "card-modal-edit-controls"
              ).style.display = "flex";
            });
          document.addEventListener("click", (e) => {
            if (e.target.id === "save-card-edit-btn") handleSaveCardDetails();
            if (e.target.id === "cancel-card-edit-btn") {
              const contentWrapper = document.getElementById(
                "card-details-modal-content-wrapper"
              );
              contentWrapper.classList.remove("card-modal-edit-mode");
              document.getElementById(
                "card-modal-edit-controls"
              ).style.display = "none";
            }
          });

          // Deck Creation Modal
          document
            .getElementById("create-deck-btn")
            .addEventListener("click", () => {
              console.log("[Event: Click] Create New Deck button clicked.");
              currentCommanderForAdd = null;
              const form = document.getElementById("deck-creation-form");
              if (form) form.reset();
              document.getElementById(
                "selected-commander-preview"
              ).style.display = "none";
              document.getElementById("commander-search-results").innerHTML =
                "";
              document
                .getElementById("deck-format-select")
                .dispatchEvent(new Event("change"));
              showModal("deck-creation-modal");
              renderCommandersFromCollection();
            });
          document
            .getElementById("cancel-deck-btn")
            .addEventListener("click", () => hideModal("deck-creation-modal"));
          document
            .getElementById("deck-creation-form")
            .addEventListener("submit", handleSaveDeck);

          // AI Blueprint Modal
          document
            .getElementById("close-blueprint-modal-btn")
            .addEventListener("click", () => hideModal("ai-blueprint-modal"));
          document
            .getElementById("cancel-blueprint-btn")
            .addEventListener("click", () => {
              hideModal("ai-blueprint-modal");
              showModal("deck-creation-modal");
            });
          document
            .getElementById("confirm-blueprint-btn")
            .addEventListener("click", () => {
              console.log(
                "[Event: Click] Confirmed AI blueprint for deck creation."
              );
              const deckName =
                tempAiBlueprint.generatedName ||
                document.getElementById("deck-name-input").value.trim();
              const format =
                document.getElementById("deck-format-select").value;
              createDeckInFirestore(deckName, format, tempAiBlueprint);
            });

          document
            .getElementById("deck-format-select")
            .addEventListener("change", (e) => {
              document.getElementById(
                "commander-selection-container"
              ).style.display =
                e.target.value === "commander" ? "block" : "none";
            });
          document
            .getElementById("commander-search-btn")
            .addEventListener("click", () => {
              currentSearchContext.mode = "commander";
              const query = document
                .getElementById("commander-search-input")
                .value.trim();
              if (query) searchScryfall(query);
            });

          document.querySelectorAll(".commander-source-btn").forEach((btn) => {
            btn.addEventListener("click", (e) => {
              document
                .querySelectorAll(".commander-source-btn")
                .forEach((b) =>
                  b.classList.replace("border-indigo-500", "border-transparent")
                );
              e.currentTarget.classList.replace(
                "border-transparent",
                "border-indigo-500"
              );
              const isCollection =
                e.currentTarget.id === "commander-source-collection-btn";
              document.getElementById(
                "commander-from-collection"
              ).style.display = isCollection ? "block" : "none";
              document.getElementById("commander-from-search").style.display =
                isCollection ? "none" : "block";
            });
          });
          document
            .getElementById("commander-collection-list")
            .addEventListener("click", (e) => {
              const cardEl = e.target.closest("[data-card]");
              if (cardEl) {
                const cardData = JSON.parse(cardEl.dataset.card);
                selectCommander(cardData);
              }
            });
          document
            .getElementById("commander-collection-filter")
            .addEventListener("input", renderCommandersFromCollection);

          // Deck Lists (delegated)
          document
            .getElementById("decks-list")
            .addEventListener("click", (e) => {
              const viewBtn = e.target.closest(".view-deck-btn");
              const deleteBtn = e.target.closest(".delete-button");
              if (viewBtn) {
                renderSingleDeck(viewBtn.dataset.id);
                showView("singleDeck");
              }
              if (deleteBtn) {
                handleDeleteDeck(deleteBtn.dataset.id);
              }
            });

          // Settings
          document
            .getElementById("settings-deck-list")
            .addEventListener("click", (e) => {
              if (e.target.closest(".delete-button")) {
                handleDeleteDeck(e.target.closest(".delete-button").dataset.id);
              }
            });
          document
            .getElementById("clear-data-btn")
            .addEventListener("click", () => {
              console.log(
                "[Event: Click] 'Clear All Account Data' button clicked."
              );
              showConfirmationModal(
                "Delete ALL Data?",
                "This is irreversible. Your entire collection and all decks will be permanently erased. Are you absolutely sure?",
                clearAllUserData
              );
            });
          document
            .getElementById("export-all-data-btn")
            .addEventListener("click", handleExportAllData);
          document
            .getElementById("import-all-data-input")
            .addEventListener("change", handleImportAllData);
        }

        function selectCommander(cardData) {
          console.log(
            `[Function: selectCommander] Selected commander: ${cardData.name}. Find in <script> block.`
          );
          currentCommanderForAdd = cardData;
          const preview = document.getElementById("selected-commander-preview");
          preview.innerHTML = `<img src="${currentCommanderForAdd.image_uris.art_crop}" class="w-10 h-10 rounded-full"><p>${currentCommanderForAdd.name}</p>`;
          preview.style.display = "flex";
          document.getElementById("commander-search-results").innerHTML = "";
        }

        function renderCommandersFromCollection() {
          const listContainer = document.getElementById(
            "commander-collection-list"
          );
          const filterText = document
            .getElementById("commander-collection-filter")
            .value.toLowerCase();
          let commanders = Object.values(localCollection).filter(
            (c) =>
              c.type_line.includes("Legendary") &&
              c.type_line.includes("Creature")
          );

          if (filterText) {
            commanders = commanders.filter((c) =>
              c.name.toLowerCase().includes(filterText)
            );
          }

          if (commanders.length === 0) {
            listContainer.innerHTML = `<p class="text-gray-500 p-4 col-span-full text-center">No matching legendary creatures found.</p>`;
            return;
          }

          listContainer.innerHTML = commanders
            .map(
              (card) => `
                    <div class="flex items-center gap-2 p-1 rounded-md hover:bg-indigo-800 cursor-pointer" data-card='${escapeHtml(
                      JSON.stringify(card)
                    )}'>
                        <img src="${
                          card.image_uris.art_crop
                        }" class="w-8 h-8 rounded-full">
                        <span class="text-sm truncate">${card.name}</span>
                    </div>
                `
            )
            .join("");
        }

        // --- DATA IMPORT/EXPORT ---
        function downloadJSON(data, fileName) {
          console.log(
            `[Function: downloadJSON] Creating download for file: ${fileName}. Find in <script> block.`
          );
          const dataStr =
            "data:text/json;charset=utf-8," +
            encodeURIComponent(JSON.stringify(data, null, 2));
          const downloadAnchorNode = document.createElement("a");
          downloadAnchorNode.setAttribute("href", dataStr);
          downloadAnchorNode.setAttribute("download", fileName);
          document.body.appendChild(downloadAnchorNode);
          downloadAnchorNode.click();
          downloadAnchorNode.remove();
        }

        function handleExportAllData() {
          console.log(
            "[Function: handleExportAllData] Exporting all user data. Find in <script> block."
          );
          const data = {
            collection: Object.values(localCollection),
            decks: Object.values(localDecks),
            settings: { modalVisibility: modalVisibilitySettings },
          };
          downloadJSON(
            data,
            `mtg-forge-backup-${new Date().toISOString().slice(0, 10)}.json`
          );
        }

        function handleImportAllData(event) {
          console.log(
            "[Function: handleImportAllData] Handling data import from file. Find in <script> block."
          );
          const file = event.target.files[0];
          if (!file) return;

          const reader = new FileReader();
          reader.onload = (e) => {
            try {
              const data = JSON.parse(e.target.result);
              if (!data.collection || !data.decks) {
                throw new Error("Invalid backup file format.");
              }
              showConfirmationModal(
                "Overwrite All Data?",
                "This will replace your entire collection and all decks with the data from this file. This cannot be undone.",
                async () => {
                  console.log(
                    "[handleImportAllData] User confirmed import. Starting batch write process."
                  );
                  const batch = writeBatch(db);
                  // Delete old data
                  console.log(
                    "[handleImportAllData] Queuing deletion of old data."
                  );
                  Object.keys(localCollection).forEach((id) =>
                    batch.delete(
                      doc(db, `artifacts/${appId}/users/${userId}/cards`, id)
                    )
                  );
                  Object.keys(localDecks).forEach((id) =>
                    batch.delete(
                      doc(db, `artifacts/${appId}/users/${userId}/decks`, id)
                    )
                  );

                  // Add new data
                  console.log(
                    "[handleImportAllData] Queuing addition of new data."
                  );
                  data.collection.forEach((card) => {
                    const newCardRef = doc(
                      collection(db, `artifacts/${appId}/users/${userId}/cards`)
                    );
                    batch.set(newCardRef, card);
                  });
                  data.decks.forEach((deck) => {
                    const newDeckRef = doc(
                      collection(db, `artifacts/${appId}/users/${userId}/decks`)
                    );
                    batch.set(newDeckRef, deck);
                  });

                  await batch.commit();
                  console.log("[handleImportAllData] Batch commit successful.");

                  if (data.settings?.modalVisibility) {
                    modalVisibilitySettings = data.settings.modalVisibility;
                    saveViewSettings();
                  }
                  showToast("Import successful!", "success");
                }
              );
            } catch (error) {
              console.error(
                "[handleImportAllData] Error processing import file:",
                error
              );
              showNotification("Import Error", error.message);
            } finally {
              event.target.value = ""; // Reset file input
            }
          };
          reader.readAsText(file);
        }

        function loadViewSettings() {
          console.log(
            "[Function: loadViewSettings] Loading view settings from localStorage. Find in <script> block."
          );
          const settings = localStorage.getItem("mtgForgeViewSettings");
          if (settings) {
            const parsed = JSON.parse(settings);
            collectionViewMode = parsed.view || "grid";
            collectionGridSize = parsed.size || "md";
            document.getElementById("hide-in-deck-checkbox").checked =
              parsed.hideInDeck || false;

            setCollectionViewMode(collectionViewMode);
            document.querySelectorAll(".grid-size-btn").forEach((b) => {
              const isSelected = b.dataset.size === collectionGridSize;
              b.classList.toggle("bg-indigo-600", isSelected);
              b.classList.toggle("text-white", isSelected);
              b.classList.toggle("text-gray-400", !isSelected);
            });
          }
        }

        function saveViewSettings() {
          console.log(
            "[Function: saveViewSettings] Saving view settings to localStorage. Find in <script> block."
          );
          const settings = {
            view: collectionViewMode,
            size: collectionGridSize,
            hideInDeck: document.getElementById("hide-in-deck-checkbox")
              .checked,
          };
          localStorage.setItem(
            "mtgForgeViewSettings",
            JSON.stringify(settings)
          );
        }

        // --- NEW FUNCTIONALITY ---

        async function clearAllUserData() {
          console.log(
            "[Function: clearAllUserData] Starting process to clear all user data. Find in <script> block."
          );
          if (!userId) {
            console.error("[clearAllUserData] No user ID found. Aborting.");
            return;
          }

          const toastId = showToast(
            "Deleting all your data... This may take a moment.",
            "loading",
            null
          );

          try {
            const batch = writeBatch(db);

            console.log(
              `[clearAllUserData] Fetching cards from collection: artifacts/${appId}/users/${userId}/cards`
            );
            const cardsCollectionRef = collection(
              db,
              `artifacts/${appId}/users/${userId}/cards`
            );
            const cardsSnapshot = await getDocs(cardsCollectionRef);
            cardsSnapshot.forEach((doc) => {
              console.log(
                `[clearAllUserData] Queuing card for deletion: ${doc.id}`
              );
              batch.delete(doc.ref);
            });

            console.log(
              `[clearAllUserData] Fetching decks from collection: artifacts/${appId}/users/${userId}/decks`
            );
            const decksCollectionRef = collection(
              db,
              `artifacts/${appId}/users/${userId}/decks`
            );
            const decksSnapshot = await getDocs(decksCollectionRef);
            decksSnapshot.forEach((doc) => {
              console.log(
                `[clearAllUserData] Queuing deck for deletion: ${doc.id}`
              );
              batch.delete(doc.ref);
            });

            console.log(
              "[clearAllUserData] Committing batch delete operation."
            );
            await batch.commit();

            clearUI();
            updateToast(
              toastId,
              "All your data has been permanently deleted.",
              "success"
            );
            console.log(
              "[clearAllUserData] Successfully cleared all user data."
            );
          } catch (error) {
            console.error(
              "[clearAllUserData] Error during data deletion:",
              error
            );
            updateToast(toastId, `Error: ${error.message}`, "error");
          }
        }

        async function handleRuleLookup(query) {
          console.log(
            `[Function: handleRuleLookup] Looking up rule: "${query}". Find in <script> block.`
          );

          ruleLookupHistory.push({ role: "user", parts: [{ text: query }] });
          renderRuleLookupChat();

          const prompt = `You are a Magic: The Gathering Level 3 Judge and rules expert. Your knowledge is comprehensive and up-to-date. Answer the following rules question accurately and clearly. If possible, cite the relevant Comprehensive Rule number(s). Keep your answer focused on the rules question asked.\n\nQuestion: ${query}`;

          const apiHistory = [{ role: "user", parts: [{ text: prompt }] }];

          try {
            console.log(
              "[handleRuleLookup] Calling Gemini API for rule lookup."
            );
            const response = await fetch(GEMINI_API_URL, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ contents: apiHistory }),
            });

            if (!response.ok) {
              const errorBody = await response.text();
              throw new Error(
                `Gemini API request failed with status ${response.status}: ${errorBody}`
              );
            }

            const result = await response.json();
            const text = result.candidates?.[0]?.content?.parts?.[0]?.text;

            if (text) {
              console.log("[handleRuleLookup] Received response from Gemini.");
              ruleLookupHistory.push({ role: "model", parts: [{ text }] });
            } else {
              console.error(
                "[handleRuleLookup] Invalid response from Gemini API:",
                result
              );
              throw new Error(
                "Received an invalid or empty response from the AI."
              );
            }
          } catch (error) {
            console.error("[handleRuleLookup] Gemini API error:", error);
            ruleLookupHistory.push({
              role: "model",
              parts: [
                {
                  text: `Sorry, I encountered an error trying to look that up: ${error.message}`,
                },
              ],
            });
          } finally {
            renderRuleLookupChat();
          }
        }

        function renderRuleLookupChat() {
          console.log(
            "[Function: renderRuleLookupChat] Rendering rule lookup chat history. Find in <script> block."
          );
          const chatContainer = document.getElementById("rule-lookup-history");
          chatContainer.innerHTML = ruleLookupHistory
            .map((msg) => {
              if (msg.role === "model") {
                return `<div class="bg-gray-700 p-3 rounded-lg"><p class="whitespace-pre-wrap">${msg.parts[0].text}</p></div>`;
              }
              return `<div class="bg-indigo-900 p-3 rounded-lg text-right"><p class="font-semibold">${msg.parts[0].text}</p></div>`;
            })
            .join("");

          if (
            ruleLookupHistory.length > 0 &&
            ruleLookupHistory[ruleLookupHistory.length - 1].role === "user"
          ) {
            chatContainer.innerHTML += `<div class="bg-gray-700 p-3 rounded-lg"><div class="flex items-center gap-2"><div class="animate-spin rounded-full h-5 w-5 border-b-2 border-indigo-400"></div><span>Consulting the rules...</span></div></div>`;
          }

          chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        async function handleMtgChat(userMessage) {
          console.log(
            `[Function: handleMtgChat] Handling user chat message: "${userMessage}". Find in <script> block.`
          );

          mtgChatHistory.push({ role: "user", parts: [{ text: userMessage }] });
          renderMtgChat();

          const systemPrompt =
            "You are MTG Forge, an expert AI assistant for all things Magic: The Gathering. You are knowledgeable about card interactions, deck building strategies, the latest meta, MTG lore, and tournament results. You are friendly and helpful. Do not mention that you are an AI model.";

          const apiHistory = [
            { role: "user", parts: [{ text: systemPrompt }] },
            {
              role: "model",
              parts: [
                {
                  text: "Understood. I'm ready to help with any MTG questions.",
                },
              ],
            },
            ...mtgChatHistory,
          ];

          try {
            console.log("[handleMtgChat] Calling Gemini API for MTG chat.");
            const response = await fetch(GEMINI_API_URL, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ contents: apiHistory }),
            });

            if (!response.ok) {
              const errorBody = await response.text();
              throw new Error(
                `Gemini API request failed with status ${response.status}: ${errorBody}`
              );
            }

            const result = await response.json();
            const text = result.candidates?.[0]?.content?.parts?.[0]?.text;

            if (text) {
              console.log("[handleMtgChat] Received response from Gemini.");
              mtgChatHistory.push({ role: "model", parts: [{ text }] });
            } else {
              console.error(
                "[handleMtgChat] Invalid response from Gemini API:",
                result
              );
              throw new Error(
                "Received an invalid or empty response from the AI."
              );
            }
          } catch (error) {
            console.error("[handleMtgChat] Gemini API error:", error);
            mtgChatHistory.push({
              role: "model",
              parts: [
                { text: `Sorry, I encountered an error: ${error.message}` },
              ],
            });
          } finally {
            renderMtgChat();
          }
        }

        function renderMtgChat() {
          console.log(
            "[Function: renderMtgChat] Rendering MTG chat history. Find in <script> block."
          );
          const chatContainer = document.getElementById("mtg-chat-history");
          let html = mtgChatHistory
            .map((msg) => {
              if (msg.role === "model") {
                return `<div class="bg-gray-700 p-3 rounded-lg"><p class="whitespace-pre-wrap">${msg.parts[0].text}</p></div>`;
              }
              return `<div class="bg-indigo-900 p-3 rounded-lg text-right"><p class="font-semibold">${msg.parts[0].text}</p></div>`;
            })
            .join("");

          if (
            mtgChatHistory.length > 0 &&
            mtgChatHistory[mtgChatHistory.length - 1].role === "user"
          ) {
            html += `<div class="bg-gray-700 p-3 rounded-lg"><div class="flex items-center gap-2"><div class="animate-spin rounded-full h-5 w-5 border-b-2 border-indigo-400"></div><span>Thinking...</span></div></div>`;
          }

          // If there's no history, show the default welcome message
          if (mtgChatHistory.length === 0) {
            html = `<div class="bg-gray-700 p-3 rounded-lg"><p>Welcome! Ask me anything about MTG strategy, lore, deck building, or cards.</p></div>`;
          }

          chatContainer.innerHTML = html;
          chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        // --- APP INITIALIZATION ---

        // Initialize Firebase
        try {
          const app = initializeApp(firebaseConfig);
          db = getFirestore(app);
          auth = getAuth(app);
          console.log("[Firebase] Initialization successful.");
        } catch (error) {
          console.error("[Firebase] Initialization failed:", error);
          document.getElementById(
            "app-content"
          ).innerHTML = `<div class="p-6 text-center text-red-500">Error: Firebase configuration is missing or invalid. Please check your Firebase credentials.</div>`;
          document.getElementById("app-wrapper").style.display = "flex";
          document.getElementById("login-screen").style.display = "none";
          return;
        }

        // Setup Auth State Listener
        onAuthStateChanged(auth, (user) => {
          if (user) {
            console.log(
              `[onAuthStateChanged] User is signed in. UID: ${user.uid}`
            );
            userId = user.uid;
            document.getElementById("user-email").textContent =
              user.email || `UID: ${userId}`;
            document.getElementById("login-screen").style.display = "none";
            document.getElementById("app-wrapper").style.display = "flex";
            loadModalSettings();
            loadViewSettings();
            loadUserData();
          } else {
            console.log("[onAuthStateChanged] User is signed out.");
            userId = null;
            if (collectionUnsubscribe) collectionUnsubscribe();
            if (decksUnsubscribe) decksUnsubscribe();
            document.getElementById("login-screen").style.display = "flex";
            document.getElementById("app-wrapper").style.display = "none";
            clearUI();
          }
        });

        // --- Initial App Start ---
        setupEventListeners();
        (async () => {
          try {
            if (
              typeof __initial_auth_token !== "undefined" &&
              __initial_auth_token
            ) {
              console.log(
                "[Auth] Found initial auth token. Signing in with custom token."
              );
              await signInWithCustomToken(auth, __initial_auth_token);
            } else {
              console.log("[Auth] No initial auth token found.");
            }
          } catch (error) {
            console.error("[Auth] Custom token sign-in failed:", error);
          }
        })();
      });
    </script>
  </body>
</html>
