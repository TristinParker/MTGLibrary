<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MTG Forge - Deck & Collection Manager</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
      body {
        font-family: "Inter", sans-serif;
      }
      .card-image-container {
        position: relative;
        width: 100%;
        /* Use aspect-ratio so the image box scales naturally with the grid cell */
        aspect-ratio: 2 / 3; /* portrait card */
        overflow: hidden;
      }

      /* Collection grid card item: ensure each grid cell has a stable height
         so rows expand to the card's displayed height and cannot overlap. */
      .collection-card-item {
        position: relative;
        display: block; /* let grid manage layout */
        aspect-ratio: 2 / 3; /* match card portrait */
        width: 100%;
        overflow: hidden;
        border-radius: 0.5rem;
      }

      /* Explicit image class for collection items (absolute fill) */
      .collection-card-img {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: block;
      }
      .oracle-text-truncate {
        overflow: hidden;
        display: -webkit-box;
        -webkit-line-clamp: 2;
        line-clamp: 2;
        -webkit-box-orient: vertical;
      }
      .kpi-gradient-bar {
        position: absolute;
        bottom: 0;
        left: 0;
        height: 4px;
        border-radius: 0 0 0.5rem 0.5rem;
        transition: width 0.5s ease-in-out;
      }
      /* Toast Notifications */
      #toast-container {
        position: fixed;
        bottom: 1.5rem;
        right: 1.5rem;
        z-index: 100;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }
      .toast {
        display: flex;
        align-items: center;
        padding: 1rem;
        border-radius: 0.5rem;
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1),
          0 4px 6px -2px rgba(0, 0, 0, 0.05);
        min-width: 300px;
        max-width: 400px;
        transform: translateX(120%);
        animation: slideIn 0.5s forwards, slideOut 0.5s 4.5s forwards;
      }
      @keyframes slideIn {
        from {
          transform: translateX(120%);
        }
        to {
          transform: translateX(0);
        }
      }
      @keyframes slideOut {
        from {
          transform: translateX(0);
        }
        to {
          transform: translateX(120%);
        }
      }

      /* Accordion styles */
      details > summary {
        list-style: none;
        cursor: pointer;
      }
      details > summary::-webkit-details-marker {
        display: none;
      }
      details summary:before {
        content: "+";
        margin-right: 0.5rem;
        font-weight: bold;
      }
      details[open] summary:before {
        content: "-";
      }
    </style>
  </head>
  <body class="bg-gray-900 text-gray-200">
    <!-- Login Screen -->
    <div
      id="login-screen"
      class="fixed inset-0 z-[100] flex items-center justify-center bg-gray-900"
    >
      <div class="p-8 bg-gray-800 rounded-lg shadow-2xl max-w-sm w-full">
        <h1
          class="text-3xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-pink-600 mb-2 text-center"
        >
          MTG Forge
        </h1>
        <p class="text-gray-400 mb-6 text-center">
          Your personal MTG collection manager.
        </p>
        <form id="email-login-form" class="space-y-4">
          <div>
            <label
              for="email"
              class="block text-sm font-medium text-left text-gray-300"
              >Email</label
            >
            <input
              type="email"
              id="email"
              required
              class="mt-1 w-full p-2 border rounded-md bg-gray-700 border-gray-600 text-white"
            />
          </div>
          <div>
            <label
              for="password"
              class="block text-sm font-medium text-left text-gray-300"
              >Password</label
            >
            <input
              type="password"
              id="password"
              required
              class="mt-1 w-full p-2 border rounded-md bg-gray-700 border-gray-600 text-white"
            />
          </div>
          <div class="flex space-x-2">
            <button
              type="button"
              id="email-login-btn"
              class="w-full bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 transition"
            >
              Login
            </button>
            <button
              type="button"
              id="signup-btn"
              class="w-full bg-gray-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-gray-500 transition"
            >
              Sign Up
            </button>
          </div>
        </form>
        <div class="relative flex py-5 items-center">
          <div class="flex-grow border-t border-gray-600"></div>
          <span class="flex-shrink mx-4 text-gray-500">Or</span>
          <div class="flex-grow border-t border-gray-600"></div>
        </div>
        <button
          id="login-with-google-btn"
          class="w-full flex items-center justify-center bg-gray-200 border border-gray-400 text-gray-800 font-bold py-3 px-4 rounded-lg hover:bg-gray-300 transition"
        >
          <svg
            class="w-5 h-5 mr-3"
            viewBox="0 0 48 48"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path
              fill-rule="evenodd"
              clip-rule="evenodd"
              d="M48 24C48 22.0435 47.2107 20.1692 45.8284 18.7869C44.4461 17.4046 42.5717 16.6152 40.6154 16.6152H24V29.5385H37.8462C37.4308 32.6154 35.8462 35.2615 33.2308 36.9231V43.8462H41.6923C45.5077 40.2462 48 34.8 48 24Z"
              fill="#4285F4"
            ></path>
            <path
              fill-rule="evenodd"
              clip-rule="evenodd"
              d="M24 48C30.6 48 36.2769 45.8769 40.6154 42.1846L33.2308 36.9231C31.1077 38.3077 28.1538 39.2308 24 39.2308C17.6308 39.2308 12.1846 34.9846 10.3385 29.2615H1.56923V36.4615C5.90769 43.4769 14.3077 48 24 48Z"
              fill="#34A853"
            ></path>
            <path
              fill-rule="evenodd"
              clip-rule="evenodd"
              d="M10.3385 29.2615C9.87692 27.8769 9.6 26.3077 9.6 24.5538C9.6 22.8 9.87692 21.2308 10.3385 19.8462V12.6462H1.56923C-0.553846 16.7077 -0.553846 21.8462 1.56923 35.9077L10.3385 29.2615Z"
              fill="#FBBC05"
            ></path>
            <path
              fill-rule="evenodd"
              clip-rule="evenodd"
              d="M24 9.87692C27.3231 9.87692 30.0923 11 32.3077 12.9231L39.8769 5.35385C35.6308 1.84615 30.0923 0 24 0C14.3077 0 5.90769 4.52308 1.56923 11.5385L10.3385 18.2308C12.1846 12.5077 17.6308 9.87692 24 9.87692Z"
              fill="#EA4335"
            ></path>
          </svg>
          Sign in with Google
        </button>
      </div>
    </div>

    <!-- Main Application Container -->
    <div id="app-wrapper" class="hidden w-full h-screen flex">
      <!-- Sidebar Navigation -->
      <nav class="w-64 bg-gray-800 flex-shrink-0 flex flex-col p-4">
        <div class="flex items-center gap-3 mb-8">
          <svg
            class="w-10 h-10 text-purple-400"
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 24 24"
            fill="currentColor"
          >
            <path
              d="M5 22V8H3V6L12 1L21 6V8H19V22H15V14H9V22H5ZM7 20H11V12H13V20H17V8.825L12 5.5L7 8.825V20Z"
            />
          </svg>
          <h1
            class="text-2xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-pink-600"
          >
            MTG Forge
          </h1>
        </div>
        <div class="space-y-2 flex-grow">
          <button
            id="nav-collection"
            class="nav-link w-full text-left flex items-center gap-3 px-3 py-2 rounded-lg bg-indigo-600 text-white"
          >
            <svg
              class="w-5 h-5"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"
              ></path>
            </svg>
            My Collection
          </button>
          <button
            id="nav-decks"
            class="nav-link w-full text-left flex items-center gap-3 px-3 py-2 rounded-lg text-gray-400 hover:bg-gray-700 hover:text-white"
          >
            <svg
              class="w-5 h-5"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z"
              ></path>
            </svg>
            Decks
          </button>
          <div class="border-t border-gray-700 my-4"></div>
          <button
            id="nav-rule-lookup"
            class="nav-link w-full text-left flex items-center gap-3 px-3 py-2 rounded-lg text-gray-400 hover:bg-gray-700 hover:text-white"
          >
            <svg
              class="w-5 h-5"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.79 4 4s-1.79 4-4 4c-1.742 0-3.223-.835-3.772-2M12 5v.01M12 19v.01"
              ></path>
            </svg>
            Rule Lookup
          </button>
          <button
            id="nav-general-chat"
            class="nav-link w-full text-left flex items-center gap-3 px-3 py-2 rounded-lg text-gray-400 hover:bg-gray-700 hover:text-white"
          >
            <svg
              class="w-5 h-5"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"
              ></path>
            </svg>
            MTG Chat
          </button>
        </div>
        <div class="space-y-2">
          <button
            id="nav-settings"
            class="nav-link w-full text-left flex items-center gap-3 px-3 py-2 rounded-lg text-gray-400 hover:bg-gray-700 hover:text-white"
          >
            <svg
              class="w-5 h-5"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"
              ></path>
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"
              ></path>
            </svg>
            Settings
          </button>
        </div>
      </nav>

      <!-- Main Content -->
      <div
        id="app-content"
        class="flex-1 flex flex-col h-screen overflow-y-auto"
      >
        <header
          class="bg-gray-800/80 backdrop-blur-sm sticky top-0 z-10 p-4 flex justify-between items-center border-b border-gray-700"
        >
          <h2 id="page-title" class="text-2xl font-bold">My Collection</h2>
          <div class="flex items-center gap-4">
            <button
              id="new-player-guide-btn"
              class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300 flex items-center gap-2"
            >
              <svg
                class="w-5 h-5"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
                xmlns="http://www.w3.org/2000/svg"
              >
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  stroke-width="2"
                  d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.79 4 4s-1.79 4-4 4c-1.742 0-3.223-.835-3.772-2M12 5v.01M12 19v.01"
                ></path>
              </svg>
              New Player Guide
            </button>
            <button
              id="edit-mode-toggle"
              class="bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300 flex items-center gap-2"
            >
              <svg
                class="w-5 h-5"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  stroke-width="2"
                  d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"
                ></path>
              </svg>
              <span id="edit-mode-text">Edit Mode</span>
            </button>
          </div>
        </header>

        <main id="main-content" class="p-6 space-y-6">
          <!-- Collection View -->
          <div id="collection-view">
            <!-- Add Card Section -->
              <div id="add-card-section-wrapper">
                <div class="bg-gray-900/80 p-4 rounded-2xl shadow-lg mb-4 flex flex-col sm:flex-row items-center gap-4">
                  <input
                    type="text"
                    id="card-search-input"
                    class="flex-grow bg-gray-800 border border-gray-700 rounded-xl px-5 py-3 text-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 placeholder-gray-400"
                    placeholder="Add card by name (e.g., Sol Ring)"
                  />
                  <button
                    id="search-card-btn"
                    class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold px-6 py-3 rounded-xl flex items-center gap-2 shadow-md transition"
                    aria-label="Add Card"
                  >
                    <svg id="search-icon" class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" /></svg>
                    <span id="search-text" class="hidden sm:inline">Add Card</span>
                    <div id="search-spinner" class="hidden animate-spin rounded-full h-6 w-6 border-b-2 border-white ml-2"></div>
                  </button>
                </div>
              </div>

            <!-- Collection Filters & Grouping -->
            <div class="bg-gray-900/80 p-4 rounded-2xl shadow-lg mb-6 flex flex-col sm:flex-row gap-4 items-center">
              <div class="flex-grow min-w-[180px]">
                <label for="filter-text" class="text-sm text-gray-400 mb-2 block">Quick Filter</label>
                <input
                  type="text"
                  id="filter-text"
                  class="w-full bg-gray-800 border border-gray-700 rounded-xl px-5 py-3 text-base focus:outline-none focus:ring-2 focus:ring-indigo-500 placeholder-gray-400"
                  placeholder="e.g., Goblin, Instant..."
                />
              </div>
              <div class="flex-grow flex gap-4 min-w-[320px]">
                <div class="flex-1">
                  <label for="collection-group-by-1" class="text-sm text-gray-400 mb-2 block">Group By</label>
                  <select
                    id="collection-group-by-1"
                    class="collection-group-select w-full bg-gray-800 border border-gray-700 rounded-xl px-5 py-3 text-base focus:outline-none focus:ring-2 focus:ring-indigo-500"
                  >
                    <option value="">None</option>
                    <option value="type_line">Type</option>
                    <option value="rarity">Rarity</option>
                    <option value="color_identity">Color</option>
                    <option value="cmc">Mana Value</option>
                    <option value="set_name">Set</option>
                    <option value="deck">Deck</option>
                  </select>
                </div>
                <div class="flex-1">
                  <label for="collection-group-by-2" class="text-sm text-gray-400 mb-2 block">Then By</label>
                  <select
                    id="collection-group-by-2"
                    class="collection-group-select w-full bg-gray-800 border border-gray-700 rounded-xl px-5 py-3 text-base focus:outline-none focus:ring-2 focus:ring-indigo-500"
                  >
                    <option value="">None</option>
                    <option value="type_line">Type</option>
                    <option value="rarity">Rarity</option>
                    <option value="color_identity">Color</option>
                    <option value="cmc">Mana Value</option>
                    <option value="set_name">Set</option>
                    <option value="deck">Deck</option>
                  </select>
                </div>
              </div>
              <!-- Advanced View Builder -->
              <div id="advanced-view-builder" class="w-full bg-gray-800 p-3 rounded-lg">
                <div class="flex items-center justify-between gap-2">
                  <div class="flex items-center gap-2">
                    <label class="text-sm text-gray-400">Saved Views</label>
                    <select id="saved-views-select" class="bg-gray-700 border border-gray-600 rounded-lg px-3 py-1 text-sm">
                      <option value="">(Default)</option>
                    </select>
                    <button id="manage-views-btn" class="text-sm text-indigo-400 underline ml-2">Manage</button>
                  </div>
                  <div class="flex items-center gap-2">
                    <button id="open-view-builder-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white text-sm font-bold py-1 px-3 rounded">Edit View</button>
                    <button id="save-view-btn" class="bg-green-600 hover:bg-green-700 text-white text-sm font-bold py-1 px-3 rounded hidden">Save View</button>
                  </div>
                </div>
                <div id="view-builder-panel" class="mt-3 hidden">
                  <div id="filters-list" class="space-y-2">
                    <!-- Filter rules will be appended here -->
                  </div>
                  <div class="flex gap-2 mt-2">
                    <select id="filter-column-select" class="bg-gray-700 border border-gray-600 rounded-lg px-2 py-1 text-sm">
                      <option value="name">Name</option>
                      <option value="type_line">Type</option>
                      <option value="rarity">Rarity</option>
                      <option value="color_identity">Color Identity</option>
                      <option value="cmc">Mana Value</option>
                      <option value="set_name">Set</option>
                      <option value="count">Count</option>
                      <option value="deck">Deck</option>
                    </select>
                    <select id="filter-op-select" class="bg-gray-700 border border-gray-600 rounded-lg px-2 py-1 text-sm">
                      <option value="contains">contains</option>
                      <option value="equals">equals</option>
                      <option value="gt">&gt;</option>
                      <option value="lt">&lt;</option>
                    </select>
                    <input id="filter-value-input" class="flex-1 bg-gray-700 border border-gray-600 rounded-lg px-2 py-1 text-sm" placeholder="value">
                    <button id="add-filter-rule-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white text-sm font-bold py-1 px-3 rounded">Add</button>
                  </div>

                  <div class="mt-4">
                    <label class="text-sm text-gray-400">Sort Rules (top priority first)</label>
                    <div id="sorts-list" class="space-y-2 mt-2"></div>
                    <div class="flex gap-2 mt-2">
                      <select id="sort-column-select" class="bg-gray-700 border border-gray-600 rounded-lg px-2 py-1 text-sm">
                        <option value="name">Name</option>
                        <option value="count">Count</option>
                        <option value="cmc">Mana Value</option>
                        <option value="rarity">Rarity</option>
                        <option value="price">Price</option>
                      </select>
                      <select id="sort-dir-select" class="bg-gray-700 border border-gray-600 rounded-lg px-2 py-1 text-sm">
                        <option value="asc">asc</option>
                        <option value="desc">desc</option>
                      </select>
                      <button id="add-sort-rule-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white text-sm font-bold py-1 px-3 rounded">Add</button>
                    </div>
                  </div>
                  <div class="mt-4 flex items-center gap-2">
                    <label class="text-sm text-gray-400">Group By</label>
                    <select id="view-group-by-1" class="bg-gray-700 border border-gray-600 rounded-lg px-2 py-1 text-sm">
                      <option value="">None</option>
                      <option value="type_line">Type</option>
                      <option value="rarity">Rarity</option>
                      <option value="color_identity">Color</option>
                      <option value="cmc">Mana Value</option>
                      <option value="set_name">Set</option>
                      <option value="deck">Deck</option>
                    </select>
                    <select id="view-group-by-2" class="bg-gray-700 border border-gray-600 rounded-lg px-2 py-1 text-sm">
                      <option value="">None</option>
                      <option value="type_line">Type</option>
                      <option value="rarity">Rarity</option>
                      <option value="color_identity">Color</option>
                      <option value="cmc">Mana Value</option>
                      <option value="set_name">Set</option>
                      <option value="deck">Deck</option>
                    </select>
                    <label class="text-sm text-gray-400 ml-4">Hide In Decks</label>
                    <input type="checkbox" id="view-hide-in-deck">
                  </div>
                  <div class="mt-4 flex items-center gap-2">
                    <input id="view-name-input" placeholder="View name" class="bg-gray-700 border border-gray-600 rounded-lg px-2 py-1 text-sm">
                    <label class="text-sm text-gray-400 flex items-center gap-2"><input type="checkbox" id="view-default-checkbox"> Set as default</label>
                  </div>
                  <div class="mt-3 flex items-center gap-4">
                    <div>
                      <label class="text-sm text-gray-400 block">View Mode</label>
                      <select id="view-view-mode" class="bg-gray-700 border border-gray-600 rounded-lg px-2 py-1 text-sm">
                        <option value="grid">Grid</option>
                        <option value="table">Table</option>
                      </select>
                    </div>
                    <div>
                      <label class="text-sm text-gray-400 block">Grid Size</label>
                      <select id="view-grid-size" class="bg-gray-700 border border-gray-600 rounded-lg px-2 py-1 text-sm">
                        <option value="sm">Small</option>
                        <option value="md">Medium</option>
                        <option value="lg">Large</option>
                      </select>
                    </div>
                    <div class="flex-1 text-right">
                      <button id="save-view-confirm-btn" class="bg-green-600 hover:bg-green-700 text-white text-sm font-bold py-1 px-3 rounded">Save</button>
                      <button id="cancel-view-builder-btn" class="bg-gray-600 hover:bg-gray-700 text-white text-sm font-bold py-1 px-3 rounded ml-2">Cancel</button>
                    </div>
                  </div>
                </div>
              </div>
              <div class="flex items-center space-x-2">
                <input
                  type="checkbox"
                  id="hide-in-deck-checkbox"
                  class="h-4 w-4 rounded bg-gray-700 border-gray-600 text-indigo-600 focus:ring-indigo-500"
                />
                <label for="hide-in-deck-checkbox" class="text-sm text-gray-300"
                  >Hide Cards in Decks</label
                >
              </div>
              <div class="flex-shrink-0">
                <label class="text-sm text-gray-400">Grid Size</label>
                <div class="mt-1 flex items-center rounded-lg bg-gray-700 p-1">
                  <button
                    class="grid-size-btn p-2 rounded-md text-gray-400"
                    data-size="sm"
                    title="Small"
                  >
                    S
                  </button>
                  <button
                    class="grid-size-btn p-2 rounded-md bg-indigo-600 text-white"
                    data-size="md"
                    title="Medium"
                  >
                    M
                  </button>
                  <button
                    class="grid-size-btn p-2 rounded-md text-gray-400"
                    data-size="lg"
                    title="Large"
                  >
                    L
                  </button>
                </div>
              </div>
              <div class="flex-shrink-0">
                <label class="text-sm text-gray-400">View</label>
                <div class="mt-1 flex items-center rounded-lg bg-gray-700 p-1">
                  <button
                    id="view-toggle-grid"
                    class="view-toggle p-2 rounded-md bg-indigo-600 text-white"
                    title="Grid View"
                  >
                    <svg
                      class="w-5 h-5"
                      fill="none"
                      stroke="currentColor"
                      viewBox="0 0 24 24"
                    >
                      <path
                        stroke-linecap="round"
                        stroke-linejoin="round"
                        stroke-width="2"
                        d="M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z"
                      ></path>
                    </svg>
                  </button>
                  <button
                    id="view-toggle-table"
                    class="view-toggle p-2 rounded-md text-gray-400"
                    title="Table View"
                  >
                    <svg
                      class="w-5 h-5"
                      fill="none"
                      stroke="currentColor"
                      viewBox="0 0 24 24"
                    >
                      <path
                        stroke-linecap="round"
                        stroke-linejoin="round"
                        stroke-width="2"
                        d="M4 6h16M4 10h16M4 14h16M4 18h16"
                      ></path>
                    </svg>
                  </button>
                </div>
              </div>
              <button
                id="reset-filters-btn"
                class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg"
              >
                Reset
              </button>
            </div>

            <!-- Collection Content -->
            <div id="collection-content">
              <!-- Grouped or Table content will be injected here -->
            </div>
            <div
              id="collection-pagination"
              class="flex justify-center items-center space-x-2 mt-6"
            >
              <!-- Pagination controls will be injected here -->
            </div>
            <p id="no-cards-msg" class="text-center text-gray-500 mt-8">
              Your collection is empty. Use the search bar above to add cards!
            </p>
          </div>

          <!-- Decks View -->
          <div id="decks-view" class="hidden">
            <div
              class="bg-gray-800 p-4 rounded-lg shadow-lg mb-6 flex flex-col md:flex-row justify-between items-center gap-4"
            >
              <h2 class="text-2xl font-semibold">My Decks</h2>
              <button
                id="create-deck-btn"
                class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition duration-300"
              >
                Create New Deck
              </button>
            </div>
            <div
              id="decks-list"
              class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6"
            >
              <!-- Deck items will be dynamically inserted here -->
            </div>
            <p id="no-decks-msg" class="text-center text-gray-500 mt-8">
              You haven't created any decks yet. Click the button above to start
              building!
            </p>
          </div>

          <!-- Single Deck View -->
          <div id="single-deck-view" class="hidden">
            <!-- Will be populated by JS -->
          </div>

          <!-- Settings View -->
          <div id="settings-view" class="hidden space-y-8">
            <div class="bg-gray-800 p-6 rounded-lg shadow-lg">
              <h2
                class="text-2xl font-semibold mb-4 border-b border-gray-700 pb-2"
              >
                Account
              </h2>
              <div class="space-y-4">
                <div>
                  <label class="text-sm text-gray-400">User Email</label>
                  <p
                    id="user-email"
                    class="text-lg bg-gray-700 p-2 rounded-md"
                  ></p>
                </div>
                <button
                  id="logout-btn"
                  class="w-full sm:w-auto bg-red-800 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg flex items-center justify-center gap-2"
                >
                  <svg
                    class="w-5 h-5"
                    fill="none"
                    stroke="currentColor"
                    viewBox="0 0 24 24"
                  >
                    <path
                      stroke-linecap="round"
                      stroke-linejoin="round"
                      stroke-width="2"
                      d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1"
                    ></path>
                  </svg>
                  Logout
                </button>
              </div>
            </div>
            <div class="bg-gray-800 p-6 rounded-lg shadow-lg">
              <h2
                class="text-2xl font-semibold mb-4 border-b border-gray-700 pb-2"
              >
                Card Modal Display
              </h2>
              <div
                id="modal-visibility-settings"
                class="grid grid-cols-2 sm:grid-cols-3 gap-4"
              >
                <!-- Checkboxes will be injected here -->
              </div>
            </div>
            <div class="bg-gray-800 p-6 rounded-lg shadow-lg">
              <h2
                class="text-2xl font-semibold mb-4 border-b border-gray-700 pb-2"
              >
                Deck Management
              </h2>
              <p class="text-gray-400 mb-4">
                Enable "Edit Mode" from the top bar to delete decks.
              </p>
              <div id="settings-deck-list" class="space-y-4">
                <!-- Deck list for deletion will be populated here -->
              </div>
            </div>
            <div class="bg-gray-800 p-6 rounded-lg shadow-lg">
              <h2
                class="text-2xl font-semibold mb-4 border-b border-gray-700 pb-2"
              >
                Data Management
              </h2>
              <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                <button
                  id="export-all-data-btn"
                  class="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg"
                >
                  Export All Data
                </button>
                <label
                  class="flex-1 bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg cursor-pointer text-center flex items-center justify-center"
                >
                  <span>Import All Data</span>
                  <input
                    type="file"
                    id="import-all-data-input"
                    class="hidden"
                    accept=".json"
                  />
                </label>
                <!-- Export Deck moved to single deck view for better UX -->
                <label
                  class="flex-1 bg-green-800 hover:bg-green-900 text-white font-bold py-2 px-4 rounded-lg cursor-pointer text-center flex items-center justify-center"
                >
                  <span>Import Deck</span>
                  <input
                    type="file"
                    id="import-deck-data-input"
                    class="hidden"
                    accept=".txt,.json"
                  />
                </label>
              </div>
            </div>
            <div
              class="bg-red-900/50 border border-red-700 p-6 rounded-lg shadow-lg"
            >
              <h2 class="text-2xl font-semibold mb-4 text-red-300">
                Danger Zone
              </h2>
              <p class="text-red-200 mb-4">
                This action is irreversible and will permanently delete your
                entire collection and all your decks.
              </p>
              <button
                id="clear-data-btn"
                class="w-full sm:w-auto bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg"
              >
                Clear All Account Data
              </button>
            </div>
          </div>
        </main>
      </div>
    </div>

    <!-- Toast Container -->
    <div id="toast-container"></div>

    <!-- Modals -->

    <!-- Add Cards to Deck Modal -->
    <div id="add-cards-to-deck-modal" class="fixed inset-0 z-[60] hidden items-center justify-center p-4 modal-backdrop">
        <div class="bg-gray-800 rounded-lg shadow-2xl max-w-4xl w-full h-[90vh] flex flex-col">
            <div class="p-4 border-b border-gray-700 flex justify-between items-center">
                <h3 id="add-cards-modal-title" class="text-xl font-bold">Add Cards to Deck</h3>
                <button id="close-add-cards-modal-btn" class="text-gray-400 hover:text-white text-3xl">&times;</button>
            </div>

            <div class="flex-grow p-4 overflow-y-auto no-scrollbar">
                <div class="mb-4">
                    <input type="text" id="add-card-modal-filter" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2" placeholder="Filter cards by name...">
                </div>
                <div class="overflow-auto" style="max-height: calc(80vh - 150px);">
                    <table class="w-full text-sm text-left text-gray-300">
                        <thead class="text-xs text-gray-400 uppercase bg-gray-700 sticky top-0">
                            <tr>
                                <th scope="col" class="p-4">
                                    <div class="flex items-center">
                                        <input id="add-cards-select-all" type="checkbox" class="w-4 h-4 text-blue-600 bg-gray-700 border-gray-600 rounded focus:ring-blue-600 ring-offset-gray-800 focus:ring-2">
                                        <label for="add-cards-select-all" class="sr-only">checkbox</label>
                                    </div>
                                </th>
                                <th scope="col" class="px-6 py-3">Card</th>
                                <th scope="col" class="px-6 py-3">Type</th>
                                <th scope="col" class="px-6 py-3 text-center">Available</th>
                            </tr>
                        </thead>
                        <tbody id="add-cards-modal-table-body">
                            <!-- Rows will be injected here -->
                        </tbody>
                    </table>
                </div>
            </div>

            <div class="p-4 border-t border-gray-700 flex justify-between items-center">
                <span id="add-cards-selected-count" class="text-gray-400">0 cards selected</span>
                <div>
                    <button id="cancel-add-cards-to-deck-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg">Cancel</button>
                    <button id="confirm-add-cards-to-deck-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg ml-2">Add Selected Cards</button>
                </div>
            </div>
        </div>
    </div>


    <!-- Card Versions Modal (for search results) -->
    <div
      id="card-versions-modal"
      class="fixed inset-0 z-[60] hidden items-center justify-center p-4 modal-backdrop"
    >
      <div
        class="bg-gray-800 rounded-lg shadow-2xl max-w-6xl w-full h-[90vh] flex flex-col"
      >
        <div
          class="p-4 border-b border-gray-700 flex justify-between items-center"
        >
          <h3 id="card-versions-modal-title" class="text-xl font-bold">
            Select Card Version
          </h3>
          <button
            id="close-versions-modal-btn"
            class="text-gray-400 hover:text-white text-3xl"
          >
            &times;
          </button>
        </div>
        <div
              <!-- Combined Add Card + Filter/Group Row -->
              <div id="collection-toolbar" class="bg-gray-900/80 p-4 rounded-2xl shadow-lg mb-6 flex flex-col md:flex-row items-center gap-4">
                <!-- Add Card -->
                <div class="flex flex-col md:flex-row items-center gap-3 flex-1">
                  <input
                    type="text"
                    id="card-search-input"
                    class="flex-grow bg-gray-800 border border-gray-700 rounded-xl px-5 py-3 text-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 placeholder-gray-400"
                    placeholder="Add card by name (e.g., Sol Ring)"
                  />
                  <button
                    id="search-card-btn"
                    class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold px-6 py-3 rounded-xl flex items-center gap-2 shadow-md transition"
                    aria-label="Add Card"
                  >
                    <svg id="search-icon" class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" /></svg>
                    <span id="search-text" class="hidden sm:inline">Add Card</span>
                    <div id="search-spinner" class="hidden animate-spin rounded-full h-6 w-6 border-b-2 border-white ml-2"></div>
                  </button>
                </div>
                <!-- Filter/Group Controls -->
                <div class="flex flex-col md:flex-row items-center gap-3 flex-1">
                  <div class="flex flex-col md:flex-row gap-3 flex-1">
                    <div class="flex flex-col">
                      <label for="filter-text" class="text-sm text-gray-400 mb-2 block">Quick Filter</label>
                      <input
                        type="text"
                        id="filter-text"
                        class="w-full bg-gray-800 border border-gray-700 rounded-xl px-5 py-3 text-base focus:outline-none focus:ring-2 focus:ring-indigo-500 placeholder-gray-400"
                        placeholder="e.g., Goblin, Instant..."
                      />
                    </div>
                    <div class="flex flex-col">
                      <label for="collection-group-by-1" class="text-sm text-gray-400 mb-2 block">Group By</label>
                      <select
                        id="collection-group-by-1"
                        class="collection-group-select w-full bg-gray-800 border border-gray-700 rounded-xl px-5 py-3 text-base focus:outline-none focus:ring-2 focus:ring-indigo-500"
                      >
                        <option value="">None</option>
                        <option value="type_line">Type</option>
                        <option value="rarity">Rarity</option>
                        <option value="color_identity">Color</option>
                        <option value="cmc">Mana Value</option>
                        <option value="set_name">Set</option>
                        <option value="deck">Deck</option>
                      </select>
                    </div>
                    <div class="flex flex-col">
                      <label for="collection-group-by-2" class="text-sm text-gray-400 mb-2 block">Then By</label>
                      <select
                        id="collection-group-by-2"
                        class="collection-group-select w-full bg-gray-800 border border-gray-700 rounded-xl px-5 py-3 text-base focus:outline-none focus:ring-2 focus:ring-indigo-500"
                      >
                        <option value="">None</option>
                        <option value="type_line">Type</option>
                        <option value="rarity">Rarity</option>
                        <option value="color_identity">Color</option>
                        <option value="cmc">Mana Value</option>
                        <option value="set_name">Set</option>
                        <option value="deck">Deck</option>
                      </select>
                    </div>
                  </div>
                  <!-- Saved Views Row -->
                  <div class="flex flex-row items-center gap-2">
                    <label for="saved-views-select" class="text-sm text-gray-400">Saved Views</label>
                    <select id="saved-views-select" class="bg-gray-800 border border-gray-700 rounded-xl px-3 py-2 text-base focus:outline-none focus:ring-2 focus:ring-indigo-500">
                      <!-- Options populated dynamically -->
                    </select>
                    <a href="#" id="manage-views-link" class="text-indigo-400 hover:underline text-sm" onclick="openViewSettingsModal(event)">Manage</a>
                    <button id="edit-view-btn" class="bg-indigo-600 hover:bg-indigo-700 text-white px-3 py-2 rounded-lg text-sm font-bold">Edit View</button>
                    <button id="save-view-btn" class="bg-green-600 hover:bg-green-700 text-white px-3 py-2 rounded-lg text-sm font-bold">Save View</button>
                    <!-- Advanced settings popover -->
                    <div class="relative group">
                      <button class="ml-2 px-2 py-2 rounded-lg bg-gray-800 text-gray-300 hover:bg-gray-700" aria-label="Show advanced settings">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v6m0 6h.01" /></svg>
                      </button>
                      <div class="absolute z-10 right-0 mt-2 w-max bg-gray-900 border border-gray-700 rounded-xl shadow-lg p-4 hidden group-hover:block">
                        <label class="flex items-center gap-2 text-sm text-gray-400 mb-2">
                          <input type="checkbox" id="hide-cards-in-decks" class="form-checkbox" /> Hide Cards in Decks
                        </label>
                        <div class="flex items-center gap-2 mb-2">
                          <span class="text-sm text-gray-400">Grid Size</span>
                          <button id="grid-size-s" class="px-2 py-1 rounded-lg bg-gray-800 text-indigo-400">S</button>
                          <button id="grid-size-m" class="px-2 py-1 rounded-lg bg-indigo-600 text-white">M</button>
                          <button id="grid-size-l" class="px-2 py-1 rounded-lg bg-gray-800 text-indigo-400">L</button>
                        </div>
                        <div class="flex items-center gap-2 mb-2">
                          <span class="text-sm text-gray-400">View</span>
                          <button id="view-mode-grid" class="px-2 py-1 rounded-lg bg-indigo-600 text-white"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><rect x="4" y="4" width="16" height="16" rx="2" /></svg></button>
                          <button id="view-mode-list" class="px-2 py-1 rounded-lg bg-gray-800 text-indigo-400"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><rect x="4" y="8" width="16" height="8" rx="2" /></svg></button>
                        </div>
                        <button id="reset-view-btn" class="bg-gray-700 hover:bg-gray-600 text-white px-3 py-2 rounded-lg text-sm font-bold">Reset</button>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
              <!-- Modal for View Settings -->
              <div id="view-settings-modal" class="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-60 hidden">
                <div class="bg-gray-900 rounded-2xl shadow-2xl p-8 w-full max-w-lg relative">
                  <button onclick="closeViewSettingsModal()" class="absolute top-4 right-4 text-gray-400 hover:text-white text-2xl">&times;</button>
                  <h2 class="text-xl font-bold text-white mb-4">View Settings</h2>
                  <div class="mb-4">
                    <label for="modal-saved-views-select" class="text-sm text-gray-400 mb-2 block">Select Saved View</label>
                    <select id="modal-saved-views-select" class="w-full bg-gray-800 border border-gray-700 rounded-xl px-5 py-3 text-base focus:outline-none focus:ring-2 focus:ring-indigo-500">
                      <!-- Options populated dynamically -->
                    </select>
                  </div>
                  <!-- Advanced settings inside modal -->
                  <div id="modal-advanced-settings">
                    <!-- Place advanced settings here if needed -->
                  </div>
                  <div class="flex justify-end gap-2 mt-6">
                    <button onclick="closeViewSettingsModal()" class="bg-gray-700 hover:bg-gray-600 text-white px-4 py-2 rounded-lg">Cancel</button>
                    <button id="modal-save-view-btn" class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-lg font-bold">Save</button>
                  </div>
                </div>
              </div>
            class="text-gray-400 hover:text-white text-4xl font-bold"
          >
            &times;
          </button>
        </div>
        <div id="card-details-content" class="p-6">
          <!-- Content will be injected by JS -->
        </div>
      </div>
    </div>

    <!-- AI Suggestions Modal (For Deck Improvement) -->
    <div
      id="ai-suggestions-modal"
      class="fixed inset-0 z-50 hidden items-center justify-center p-4 modal-backdrop"
    >
      <div
        class="bg-gray-800 rounded-lg shadow-2xl max-w-2xl w-full h-[80vh] flex flex-col"
      >
        <div
          class="p-4 border-b border-gray-700 flex justify-between items-center"
        >
          <h3 id="ai-suggestions-title" class="text-xl font-bold">
            Gemini Deck Suggestions
          </h3>
          <button
            id="close-ai-modal-btn"
            class="text-gray-400 hover:text-white text-3xl"
          >
            &times;
          </button>
        </div>
        <div
          id="ai-chat-history"
          class="flex-grow p-4 space-y-4 overflow-y-auto no-scrollbar"
        >
          <!-- Chat messages will be injected here -->
        </div>
        <div class="p-4 border-t border-gray-700">
          <form id="ai-chat-form" class="flex gap-2">
            <input
              type="text"
              id="ai-chat-input"
              class="flex-grow bg-gray-700 border border-gray-600 rounded-lg px-4 py-2"
              placeholder="Ask a follow-up question..."
              required
            />
            <button
              type="submit"
              class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold p-2 rounded-lg"
            >
              Send
            </button>
          </form>
        </div>
      </div>
    </div>

    <!-- AI Blueprint Modal (For Deck Creation & Viewing Strategy) -->
    <div
      id="ai-blueprint-modal"
      class="fixed inset-0 z-[60] hidden items-center justify-center p-4 modal-backdrop"
    >
      <div
        class="bg-gray-800 rounded-lg shadow-2xl max-w-3xl w-full h-[90vh] flex flex-col"
      >
        <div
          class="p-4 border-b border-gray-700 flex justify-between items-center"
        >
          <h3 id="ai-blueprint-title" class="text-xl font-bold">AI Commander Blueprint</h3>
          <button
            id="close-blueprint-modal-btn"
            class="text-gray-400 hover:text-white text-3xl"
          >
            &times;
          </button>
        </div>
        <div id="ai-blueprint-content" class="flex-grow p-6 overflow-y-auto no-scrollbar space-y-4">
          <!-- Content Injected by JS -->
        </div>
        <div id="ai-blueprint-footer" class="p-4 flex justify-end gap-4 border-t border-gray-700">
          <button
            type="button"
            id="cancel-blueprint-btn"
            class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg"
          >
            Cancel
          </button>
          <button
            type="button"
            id="confirm-blueprint-btn"
            class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg"
          >
            Create Deck with this Strategy
          </button>
        </div>
      </div>
    </div>

    <!-- Deck Creation Modal -->
    <div
      id="deck-creation-modal"
      class="fixed inset-0 z-50 hidden items-center justify-center p-4 modal-backdrop"
    >
      <div class="bg-gray-800 rounded-lg shadow-2xl max-w-lg w-full">
        <form id="deck-creation-form">
          <div class="p-6">
            <h3 class="text-xl font-bold mb-4">Create a New Deck</h3>
            <div class="space-y-4">
              <div>
                <label
                  for="deck-name-input"
                  class="block text-sm font-medium text-gray-300 mb-1"
                  >Deck Name (Optional)</label
                >
                <input
                  type="text"
                  id="deck-name-input"
                  class="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2"
                  placeholder="Gemini will name it if left blank"
                />
              </div>
              <div>
                <label
                  for="deck-format-select"
                  class="block text-sm font-medium text-gray-300 mb-1"
                  >Deck Format</label
                >
                <select
                  id="deck-format-select"
                  class="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2"
                >
                  <option value="commander">Commander</option>
                  <option value="standard">Standard</option>
                  <option value="modern">Modern</option>
                </select>
              </div>
              <!-- Commander Search - shown conditionally -->
              <div id="commander-selection-container" class="space-y-2 pt-2">
                <label class="block text-sm font-medium text-gray-300"
                  >Choose Commander</label
                >
                <div class="flex border-b border-gray-600">
                  <button
                    type="button"
                    id="commander-source-collection-btn"
                    class="commander-source-btn flex-1 p-2 border-b-2 border-indigo-500 text-white"
                  >
                    From Collection
                  </button>
                  <button
                    type="button"
                    id="commander-source-search-btn"
                    class="commander-source-btn flex-1 p-2 border-b-2 border-transparent text-gray-400"
                  >
                    Search New
                  </button>
                </div>
                <div id="commander-from-collection" class="mt-2">
                  <input
                    type="text"
                    id="commander-collection-filter"
                    class="w-full bg-gray-900/80 border border-gray-600 rounded-lg px-3 py-1 text-sm mb-2"
                    placeholder="Filter collection commanders..."
                  />
                  <div
                    id="commander-collection-list"
                    class="max-h-60 overflow-y-auto grid grid-cols-1 gap-1 p-1 bg-gray-900/50 rounded-md"
                  >
                    <!-- Legendary creatures from collection will be listed here -->
                  </div>
                </div>
                <div id="commander-from-search" class="hidden mt-2">
                  <div class="flex gap-2">
                    <input
                      type="text"
                      id="commander-search-input"
                      class="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2"
                      placeholder="Search Scryfall for a legendary creature..."
                    />
                    <button
                      type="button"
                      id="commander-search-btn"
                      class="bg-indigo-600 hover:bg-indigo-700 px-4 rounded-lg"
                    >
                      Search
                    </button>
                  </div>
                  <div
                    id="commander-search-results"
                    class="max-h-60 overflow-y-auto grid grid-cols-2 sm:grid-cols-3 gap-2 mt-2"
                  ></div>
                </div>
                <div
                  id="selected-commander-preview"
                  class="hidden items-center gap-4 p-2 bg-gray-900 rounded-lg mt-2"
                ></div>
              </div>
            </div>
            <div class="flex justify-end gap-4 mt-6">
              <button
                type="button"
                id="cancel-deck-btn"
                class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg"
              >
                Cancel
              </button>
              <button
                type="submit"
                id="save-deck-btn"
                class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg flex items-center justify-center"
              >
                <span id="save-deck-text">Get AI Blueprint</span>
                <div
                  id="save-deck-spinner"
                  class="hidden animate-spin rounded-full h-5 w-5 border-b-2 border-white"
                ></div>
              </button>
            </div>
          </div>
        </form>
      </div>
    </div>

    <!-- Generic Confirmation Modal -->
    <div
      id="confirmation-modal"
      class="fixed inset-0 z-[80] hidden items-center justify-center p-4 modal-backdrop"
    >
      <div class="bg-gray-800 rounded-lg shadow-2xl max-w-sm w-full">
        <div class="p-6 text-center">
          <h3 id="confirmation-title" class="text-xl font-bold mb-2">
            Are you sure?
          </h3>
          <p id="confirmation-message" class="text-gray-400 mb-6">
            This action cannot be undone.
          </p>
          <div class="flex justify-center gap-4">
            <button
              id="confirm-action-btn"
              class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-6 rounded-lg"
            >
              Confirm
            </button>
            <button
              id="cancel-action-btn"
              class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-6 rounded-lg"
            >
              Cancel
            </button>
          </div>
        </div>
      </div>
    </div>

      <!-- Data Import Options Modal -->
    <div
      id="data-import-options-modal"
      class="fixed inset-0 z-[80] hidden items-center justify-center p-4 modal-backdrop"
    >
      <div class="bg-gray-800 rounded-lg shadow-2xl max-w-md w-full">
        <div class="p-6 text-center">
          <h3 class="text-xl font-bold mb-2">Import Data</h3>
          <p class="text-gray-400 mb-6">
            How would you like to import the data from your backup file?
          </p>
          <div class="flex flex-col gap-4">
            <button
              id="import-merge-btn"
              class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg"
            >
              Merge with Existing Data
            </button>
            <button
              id="import-replace-btn"
              class="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg"
            >
              Replace All Current Data
            </button>
            <button
              id="cancel-import-btn"
              class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-6 rounded-lg"
            >
              Cancel
            </button>
          </div>
        </div>
      </div>
    </div>


    <!-- Deck Deletion Options Modal -->
    <div
      id="deck-delete-options-modal"
      class="fixed inset-0 z-[80] hidden items-center justify-center p-4 modal-backdrop"
    >
      <div class="bg-gray-800 rounded-lg shadow-2xl max-w-md w-full">
        <div class="p-6 text-center">
          <h3 class="text-xl font-bold mb-2">Delete Deck</h3>
          <p class="text-gray-400 mb-6">
            Do you also want to remove the cards from this deck from your
            collection?
          </p>
          <div class="flex flex-col gap-4">
            <button
              id="delete-deck-and-cards-btn"
              class="bg-red-800 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg"
            >
              Delete Deck & Remove Cards
            </button>
            <button
              id="delete-deck-only-btn"
              class="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg"
            >
              Delete Deck Only
            </button>
            <button
              id="cancel-delete-deck-btn"
              class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-6 rounded-lg"
            >
              Cancel
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- Rule Lookup Modal -->
    <div
      id="rule-lookup-modal"
      class="fixed inset-0 z-50 hidden items-center justify-center p-4 modal-backdrop"
    >
      <div
        class="bg-gray-800 rounded-lg shadow-2xl max-w-2xl w-full h-[80vh] flex flex-col"
      >
        <div
          class="p-4 border-b border-gray-700 flex justify-between items-center"
        >
          <h3 class="text-xl font-bold">Rule Lookup</h3>
          <button
            id="close-rule-lookup-modal-btn"
            class="text-gray-400 hover:text-white text-3xl"
          >
            &times;
          </button>
        </div>
        <div
          id="rule-lookup-history"
          class="flex-grow p-4 space-y-4 overflow-y-auto no-scrollbar"
        >
          <div class="bg-gray-700 p-3 rounded-lg">
            <p>
              Ask a Magic: The Gathering rule question below. For example, "What
              is banding?" or "How does cascade work?".
            </p>
          </div>
        </div>
        <div class="p-4 border-t border-gray-700">
          <form id="rule-lookup-form" class="flex gap-2">
            <input
              type="text"
              id="rule-lookup-input"
              class="flex-grow bg-gray-700 border border-gray-600 rounded-lg px-4 py-2"
              placeholder="Enter your rule question..."
              required
            />
            <button
              type="submit"
              class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold p-2 rounded-lg"
            >
              Ask
            </button>
          </form>
        </div>
      </div>
    </div>

    <!-- MTG Chat Modal -->
    <div
      id="mtg-chat-modal"
      class="fixed inset-0 z-50 hidden items-center justify-center p-4 modal-backdrop"
    >
      <div
        class="bg-gray-800 rounded-lg shadow-2xl max-w-2xl w-full h-[80vh] flex flex-col"
      >
        <div
          class="p-4 border-b border-gray-700 flex justify-between items-center"
        >
          <h3 class="text-xl font-bold">MTG Chat</h3>
          <button
            id="close-mtg-chat-modal-btn"
            class="text-gray-400 hover:text-white text-3xl"
          >
            &times;
          </button>
        </div>
        <div
          id="mtg-chat-history"
          class="flex-grow p-4 space-y-4 overflow-y-auto no-scrollbar"
        >
          <div class="bg-gray-700 p-3 rounded-lg">
            <p>
              Welcome! Ask me anything about MTG strategy, lore, deck building,
              or cards.
            </p>
          </div>
        </div>
        <div class="p-4 border-t border-gray-700">
          <form id="mtg-chat-form" class="flex gap-2">
            <input
              type="text"
              id="mtg-chat-input"
              class="flex-grow bg-gray-700 border border-gray-600 rounded-lg px-4 py-2"
              placeholder="Ask a question..."
              required
            />
            <button
              type="submit"
              class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold p-2 rounded-lg"
            >
              Send
            </button>
          </form>
        </div>
      </div>
    </div>

    <!-- New Player Guide Modal -->
    <div
      id="new-player-guide-modal"
      class="fixed inset-0 z-50 hidden items-center justify-center p-4 modal-backdrop"
    >
      <div
        class="bg-gray-800 rounded-lg shadow-2xl max-w-3xl w-full h-[80vh] flex flex-col"
      >
        <div
          class="p-4 border-b border-gray-700 flex justify-between items-center"
        >
          <h3 class="text-xl font-bold">New Player Guide</h3>
          <button
            id="close-new-player-guide-modal-btn"
            class="text-gray-400 hover:text-white text-3xl"
          >
            &times;
          </button>
        </div>
        <div class="flex-grow p-6 space-y-4 overflow-y-auto no-scrollbar">
          <details class="bg-gray-900/50 p-4 rounded-lg">
            <summary class="font-semibold text-lg hover:text-indigo-400">
              The Colors of Magic
            </summary>
            <div class="mt-4 space-y-3 text-gray-300">
              <p>
                <strong>White (W):</strong> The color of order, law, and
                community. White excels at creating armies of small creatures,
                protecting them with enchantments, gaining life, and using
                powerful spells that affect all players equally to level the
                playing field.
              </p>
              <p>
                <strong>Blue (U):</strong> The color of knowledge, manipulation,
                and deceit. Blue is the master of controlling the game by
                countering opponent's spells, drawing extra cards to find the
                right answers, and controlling the board with tricky creatures
                (often with flying) and illusions.
              </p>
              <p>
                <strong>Black (B):</strong> The color of ambition, death, and
                power at any cost. Black is willing to sacrifice anything—life,
                creatures, cards in hand—to win. It is the undisputed master of
                destroying creatures, forcing opponents to discard cards, and
                reanimating creatures from any graveyard.
              </p>
              <p>
                <strong>Red (R):</strong> The color of chaos, freedom, and
                impulse. Red wants to win, and it wants to win now. It uses
                direct damage spells ("burn") to destroy creatures or attack the
                opponent directly, and deploys fast creatures with haste to keep
                the pressure on.
              </p>
              <p>
                <strong>Green (G):</strong> The color of nature, growth, and
                brute force. Green is all about playing massive, powerful
                creatures. It excels at "ramping" its mana—getting more lands
                into play faster than normal—to cast its huge threats far ahead
                of schedule.
              </p>
            </div>
          </details>

          <details class="bg-gray-900/50 p-4 rounded-lg">
            <summary class="font-semibold text-lg hover:text-indigo-400">
              Anatomy of a Deck
            </summary>
            <div class="mt-4 space-y-3 text-gray-300">
              <p class="text-sm text-gray-400">
                Note: These are general guidelines. Ratios change dramatically
                based on strategy!
              </p>
              <h4 class="font-bold text-md text-indigo-300">
                Typical 60-Card Deck (Standard, Modern, etc.)
              </h4>
              <ul class="list-disc list-inside">
                <li>
                  <strong>~24 Lands:</strong> This is the most crucial number.
                  Too few and you won't be able to cast your spells; too many
                  and you'll run out of things to do.
                </li>
                <li>
                  <strong>~20-25 Creatures:</strong> The core of most
                  strategies. These are your attackers and blockers.
                </li>
                <li>
                  <strong>~11-16 Other Spells:</strong> This includes removal,
                  card draw, and any other spells that support your
                  creature-based game plan.
                </li>
              </ul>
              <h4 class="font-bold text-md text-indigo-300 mt-4">
                Typical 100-Card Deck (Commander/EDH)
              </h4>
              <ul class="list-disc list-inside">
                <li>
                  <strong>1 Commander:</strong> Your legendary creature that
                  defines the deck's colors and strategy.
                </li>
                <li>
                  <strong>~37-38 Lands:</strong> You need more lands in
                  Commander due to the higher mana costs and longer games.
                </li>
                <li>
                  <strong>~10-12 Ramp/Mana Rocks:</strong> Spells or artifacts
                  that help you generate extra mana. Crucial for keeping up.
                </li>
                <li>
                  <strong>~10 Card Draw:</strong> Spells that let you draw more
                  cards. Essential for not running out of gas in a long game.
                </li>
                <li>
                  <strong>~10-12 Interaction/Removal:</strong> Ways to deal with
                  your opponents' threats.
                </li>
                <li>
                  <strong>~28-30 "Theme" Cards:</strong> These are the
                  creatures, spells, and other cards that work with your
                  commander to execute your deck's main strategy.
                </li>
              </ul>
            </div>
          </details>

          <details class="bg-gray-900/50 p-4 rounded-lg">
            <summary class="font-semibold text-lg hover:text-indigo-400">
              Common Playstyles (Archetypes)
            </summary>
            <div class="mt-4 space-y-3 text-gray-300">
              <p>
                <strong>Aggro (Aggressive):</strong> The goal is to win as
                quickly as possible, usually by attacking with cheap, efficient
                creatures. Aggro decks try to overwhelm the opponent before they
                can execute their own, more powerful late-game strategy. They
                live by the motto, "the best defense is a good offense."
              </p>
              <p>
                <strong>Control:</strong> The polar opposite of Aggro. Control
                decks aim to survive the early game by countering the opponent's
                key spells and destroying their creatures. They win the game in
                the long run by using powerful spells, planeswalkers, or a
                single, hard-to-kill creature once the opponent has run out of
                resources.
              </p>
              <p>
                <strong>Midrange:</strong> The jack-of-all-trades. Midrange
                decks are flexible, able to play defensively against Aggro decks
                and then switch gears to be the aggressor against slower Control
                decks. They focus on playing individually powerful and efficient
                cards that are good in almost any situation.
              </p>
              <p>
                <strong>Combo (Combination):</strong> These decks aim to
                assemble a specific combination of two or more cards that
                results in an instant win or an insurmountable advantage. Combo
                decks often feel like they are "playing solitaire," as they can
                sometimes ignore what the opponent is doing to focus entirely on
                finding their winning pieces.
              </p>
              <p>
                <strong>Tempo:</strong> A close cousin of Aggro. Tempo decks
                play an early threat and then protect it by cheaply disrupting
                the opponent's game plan just long enough to win. They use
                spells to bounce creatures back to their owner's hand or tap
                them down to clear the way for attacks, keeping their opponent
                constantly off-balance.
              </p>
            </div>
          </details>
        </div>
      </div>
    </div>

    <!-- Card Hover Preview -->
    <div id="card-hover-preview" class="fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 z-[80] hidden pointer-events-none transition-all duration-200">
        <img src="" class="rounded-xl shadow-2xl shadow-black/50" style="max-height: 85vh; max-width: 85vw; object-fit: contain;">
    </div>

    <!-- Notification Modal -->
    <div
      id="notification-modal"
      class="fixed inset-0 z-[90] hidden items-center justify-center p-4 modal-backdrop"
    >
      <div
        class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-sm text-center"
      >
        <h3
          id="notification-title"
          class="text-lg font-bold mb-2 text-red-400"
        ></h3>
        <p id="notification-message" class="text-gray-300"></p>
        <button
          id="notification-close-btn"
          class="mt-4 w-full bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg"
        >
          Close
        </button>
      </div>
    </div>

    <!-- Firebase and App Logic -->
    <script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
      import {
        getAuth,
        onAuthStateChanged,
        signOut,
        GoogleAuthProvider,
        signInWithPopup,
        createUserWithEmailAndPassword,
        signInWithEmailAndPassword,
        signInAnonymously,
        signInWithCustomToken,
      } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
      import {
        getFirestore,
        doc,
        getDoc,
        collection,
        onSnapshot,
        addDoc,
        deleteDoc,
        updateDoc,
        writeBatch,
        getDocs,
        setDoc,
        deleteField,
        runTransaction,
      } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

      document.addEventListener("DOMContentLoaded", () => {
        console.log(
          "[DOMContentLoaded] Event fired. App is initializing. Find in <script> block."
        );

        // UI module cached loader used by delegators
        let __uiModulePromise = null;
        async function getUIModule() {
          if (window.__UI) return window.__UI;
          if (__uiModulePromise) return __uiModulePromise;
          __uiModulePromise = import('./js/lib/ui.js')
            .then(m => { window.__UI = m; return m; })
            .catch(err => { __uiModulePromise = null; throw err; });
          return __uiModulePromise;
        }

  // UI helpers are provided by `Public/js/lib/ui.js`. See Public/README.md for delegation and testing guidance.

        // Attach a debounced resize/scroll handler so table header offsets update when layout changes
        (function attachTableHeaderResizeHandler() {
          let timer = null;
          const handler = () => {
            document.querySelectorAll('.overflow-x-auto').forEach(container => {
              computeTableHeaderTop(container);
            });
          };
          window.addEventListener('resize', () => {
            clearTimeout(timer);
            timer = setTimeout(handler, 120);
          });
          window.addEventListener('scroll', () => {
            if (timer) return;
            timer = setTimeout(() => {
              handler();
              timer = null;
            }, 150);
          }, { passive: true });
        })();

        // --- FIREBASE & APP CONFIG ---
        let db, auth;
        let userId = null;
        let collectionUnsubscribe = null;
        let decksUnsubscribe = null;

        const appId =
          typeof __app_id !== "undefined" ? __app_id : "mtg-forge-default";
        console.log(`[Config] App ID set to: ${appId}`);

        const firebaseConfig =
          typeof __firebase_config !== "undefined"
            ? JSON.parse(__firebase_config)
            : {
                apiKey: "AIzaSyAdqbFNjrB6y-8BrMEYYCT5ywiCgZVtMaE",
                authDomain: "mtglibrary-70b46.firebaseapp.com",
                projectId: "mtglibrary-70b46",
                storageBucket: "mtglibrary-70b46.firebasestorage.app",
                messagingSenderId: "602862103839",
                appId: "1:602862103839:web:23c64b7486c058c903d42a",
                measurementId: "G-EWELJJQ631",
              };
        console.log("[Config] Firebase config loaded.");

        const app = initializeApp(firebaseConfig);
        db = getFirestore(app);
        auth = getAuth(app);
        
        // IMPORTANT: The user must provide their own Gemini API key for this app to function.
        // The key is left empty here as a placeholder.
        const GEMINI_API_KEY = "AIzaSyDkbSsM1e4aN85G7ZVGw-XOs4HE8_E4Zig";
        const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${GEMINI_API_KEY}`;
        console.log("[Config] Gemini API URL configured.");

        // --- STATE ---
        let currentCardForAdd = null;
        let currentCommanderForAdd = null;
        let tempAiBlueprint = null;
        let localCollection = {};
        let localDecks = {};
        let cardDeckAssignments = {};
        let deckChartInstances = {};
        let collectionViewMode = "grid";
        let collectionGridSize = "md";
        let collectionSortState = { column: "name", direction: "asc" };
        let collectionCurrentPage = 1;
        const COLLECTION_PAGE_SIZE = 100;
        let currentSearchContext = {
          mode: "collection",
          deckId: null,
        };
        // Counter used to generate unique IDs for group toggle elements
        let groupUidCounter = 0;
  // Saved view templates (loaded/saved to Firestore under user settings)
  let savedViews = []; // array of view objects { id, name, filters, sorts, groupBy, hideInDecks, viewMode, gridSize, isDefault }
  let activeViewId = null; // id of currently selected saved view
  // Working lists for the advanced builder
  let viewFilterRules = []; // [{column, operator, value}]
  let viewSortRules = []; // [{column, direction}]
        let modalVisibilitySettings = {};
        let activeAiChatHistory = [];
        let ruleLookupHistory = [];
        let mtgChatHistory = [];
        let tempImportedData = null; // Used to hold data for import confirmation
        console.log("[State] Initial application state variables declared.");

        // --- DOM ELEMENTS ---
        const views = {
          collection: document.getElementById("collection-view"),
          decks: document.getElementById("decks-view"),
          singleDeck: document.getElementById("single-deck-view"),
          settings: document.getElementById("settings-view"),
        };

        const navLinks = {
          collection: document.getElementById("nav-collection"),
          decks: document.getElementById("nav-decks"),
          settings: document.getElementById("nav-settings"),
          ruleLookup: document.getElementById("nav-rule-lookup"),
          generalChat: document.getElementById("nav-general-chat"),
        };

        // --- INITIALIZATION ---

        onAuthStateChanged(auth, async (user) => {
          if (user) {
            userId = user.uid;
            console.log(`[Auth] User is signed in. UID: ${userId}`);
            document.getElementById("user-email").textContent =
              user.email || "Anonymous User";
            document.getElementById("login-screen").classList.add("hidden");
            document.getElementById("app-wrapper").classList.remove("hidden");
            await loadSettings(); // Ensure settings are loaded before first render
            setupListeners();
            // Load user saved views after listeners and settings are ready
            await loadSavedViewsFromFirestore();
          } else {
            console.log(
              "[Auth] No user signed in. Attempting custom token or anonymous sign-in."
            );
            try {
              if (typeof __initial_auth_token !== "undefined") {
                await signInWithCustomToken(auth, __initial_auth_token);
                console.log("[Auth] Successfully signed in with custom token.");
              } else {
                await signInAnonymously(auth);
                console.log("[Auth] Successfully signed in anonymously.");
              }
            } catch (error) {
              console.error("Error during sign-in:", error);
              document.getElementById("login-screen").classList.remove("hidden");
              document.getElementById("app-wrapper").classList.add("hidden");
            }
          }
        });

        // --- DATA FUNCTIONS ---

        function setupListeners() {
          console.log(
            "[Function: setupListeners] Setting up Firestore listeners. Find in <script> block."
          );
          if (collectionUnsubscribe) collectionUnsubscribe();
          const collectionRef = collection(db, `artifacts/${appId}/users/${userId}/collection`);
          collectionUnsubscribe = onSnapshot(
            collectionRef,
            (querySnapshot) => {
              let updatedCollection = {};
              querySnapshot.forEach((doc) => {
                updatedCollection[doc.id] = { firestoreId: doc.id, ...doc.data() };
              });
              localCollection = updatedCollection;
              console.log(
                `[Firestore: Collection] Snapshot received. ${
                  Object.keys(localCollection).length
                } cards loaded.`
              );
              updateCardAssignments();
              renderCollection();
              // Re-render deck if visible to update card counts from collection
              const activeDeckId = views.singleDeck.dataset.deckId;
              if (
                !views.singleDeck.classList.contains("hidden") &&
                activeDeckId
              ) {
                renderSingleDeck(activeDeckId);
              }
            },
            (error) => {
              console.error("Error listening to collection changes:", error);
            }
          );

          if (decksUnsubscribe) decksUnsubscribe();
          const decksRef = collection(db, `artifacts/${appId}/users/${userId}/decks`);
          decksUnsubscribe = onSnapshot(
            decksRef,
            (querySnapshot) => {
              let updatedDecks = {};
              querySnapshot.forEach((doc) => {
                updatedDecks[doc.id] = { id: doc.id, ...doc.data() };
              });
              localDecks = updatedDecks;
              console.log(
                `[Firestore: Decks] Snapshot received. ${
                  Object.keys(localDecks).length
                } decks loaded.`
              );
              updateCardAssignments();
              if (!views.decks.classList.contains("hidden")) {
                renderDecksList();
              }
                const activeDeckId = views.singleDeck.dataset.deckId;
              if (
                !views.singleDeck.classList.contains("hidden") &&
                activeDeckId && localDecks[activeDeckId] // Check if deck still exists
              ) {
                renderSingleDeck(activeDeckId);
              } else if (!views.singleDeck.classList.contains("hidden") && !localDecks[activeDeckId]) {
                  // If the currently viewed deck was deleted, switch back to the decks view
                  showToast("The deck you were viewing has been deleted.", "info");
                  showView('decks');
              }
            },
            (error) => {
              console.error("Error listening to deck changes:", error);
            }
          );
        }

        async function saveSettings() {
            if (!userId) return;
            const userSettingsRef = doc(db, `artifacts/${appId}/users/${userId}`);
            const settings = { modalVisibility: modalVisibilitySettings };
            try {
                await setDoc(userSettingsRef, { settings }, { merge: true });
                showToast("Settings saved successfully.", "success");
            } catch (error) {
                console.error("Error saving settings:", error);
                showToast("Failed to save settings.", "error");
            }
        }


        async function loadSettings() {
          if (!userId) return;
          try {
            const userDocRef = doc(db, `artifacts/${appId}/users/${userId}`);
            const userDoc = await getDoc(userDocRef);
            if (userDoc.exists()) {
              const settings = userDoc.data().settings;
              if (settings && settings.modalVisibility) {
                modalVisibilitySettings = settings.modalVisibility;
                console.log(
                  "[Settings] Loaded modal visibility settings:",
                  modalVisibilitySettings
                );
              }
            }
          } catch (e) {
            console.error("Error loading settings:", e);
          }
          // Ensure defaults are set if settings are missing
            const allFields = ['count', 'finish', 'condition', 'purchasePrice', 'notes', 'deckAssignments'];
            allFields.forEach(field => {
                if (modalVisibilitySettings[field] === undefined) {
                    modalVisibilitySettings[field] = true;
                }
            });
          renderModalVisibilitySettings();
        }

        // --- Saved Views / Advanced Filters ---

        function renderSavedViewsSelect() {
          const select = document.getElementById('saved-views-select');
          if (!select) return;
          select.innerHTML = '<option value="">(Default)</option>' + savedViews.map(v => {
            const mode = v.viewMode ? `, ${v.viewMode}` : '';
            const size = v.gridSize ? `, ${v.gridSize.toUpperCase()}` : '';
            return `<option value="${v.id}">${v.name}${v.isDefault ? ' (Default)' : ''}${mode}${size}</option>`;
          }).join('');
          select.value = activeViewId || '';
        }

        async function loadSavedViewsFromFirestore() {
          if (!userId) return;
          try {
            const userDocRef = doc(db, `artifacts/${appId}/users/${userId}`);
            const userDoc = await getDoc(userDocRef);
            if (userDoc.exists()) {
              const settings = (userDoc.data().settings) || {};
              savedViews = settings.savedViews || [];
              activeViewId = settings.activeViewId || null;
            } else {
              savedViews = [];
              activeViewId = null;
            }
          } catch (e) {
            console.error('Error loading saved views:', e);
            savedViews = [];
            activeViewId = null;
          }
          renderSavedViewsSelect();
          // If no activeViewId but a saved default exists, use it
          if (!activeViewId) {
            const def = savedViews.find(v => v.isDefault);
            if (def) {
              activeViewId = def.id;
            }
          }
          // If we have an activeViewId, load that view into working state and re-render
          if (activeViewId) {
            setActiveViewById(activeViewId);
          } else {
            renderSavedViewsSelect();
          }
        }

        async function persistSavedViewsToFirestore() {
          if (!userId) return;
          try {
            const userDocRef = doc(db, `artifacts/${appId}/users/${userId}`);
            await setDoc(userDocRef, { settings: { ...( (await getDoc(userDocRef)).data()?.settings || {} ), savedViews, activeViewId } }, { merge: true });
            showToast('Views saved.', 'success');
          } catch (e) {
            console.error('Error saving views:', e);
            showToast('Failed to save view settings.', 'error');
          }
        }

        function buildFilterPredicate(rule) {
          // rule: {column, operator, value}
          return (card) => {
            const col = rule.column;
            const val = rule.value;
            const op = rule.operator;
            let cardVal = card[col];
            if (col === 'color_identity') cardVal = (card.color_identity || []).join('');
            if (col === 'type_line') cardVal = (card.type_line || '').split(' — ')[0];
            if (col === 'deck') {
              const assignment = (cardDeckAssignments[card.firestoreId] || [])[0];
              cardVal = assignment ? assignment.deckName : 'Not in a Deck';
            }
            if (cardVal === undefined || cardVal === null) cardVal = '';
            cardVal = (typeof cardVal === 'string') ? cardVal.toLowerCase() : cardVal;
            const cmp = (v) => (typeof v === 'string' ? v.toLowerCase() : v);
            switch(op) {
              case 'contains':
                return String(cardVal).includes(String(val).toLowerCase());
              case 'equals':
                return String(cardVal) === String(val).toLowerCase();
              case 'gt':
                return Number(cardVal) > Number(val);
              case 'lt':
                return Number(cardVal) < Number(val);
              default:
                return true;
            }
          };
        }

        function applyActiveView(cardsArr) {
          // returns a filtered/sorted array based on viewFilterRules and viewSortRules
          let result = [...cardsArr];
          // Apply filters
          for (const rule of viewFilterRules) {
            const pred = buildFilterPredicate(rule);
            result = result.filter(pred);
          }
          // Apply sorts: sorts are applied as chained comparisons using reduce
          if (viewSortRules.length > 0) {
            result.sort((a,b) => {
              for (const s of viewSortRules) {
                const col = s.column;
                const dir = s.direction === 'asc' ? 1 : -1;
                let valA = a[col] ?? '';
                let valB = b[col] ?? '';
                if (col === 'price') { valA = parseFloat(a.prices?.usd||0); valB = parseFloat(b.prices?.usd||0); }
                if (col === 'count') { valA = a.count||1; valB = b.count||1; }
                if (typeof valA === 'string') valA = valA.toLowerCase();
                if (typeof valB === 'string') valB = valB.toLowerCase();
                if (valA < valB) return -1 * dir;
                if (valA > valB) return 1 * dir;
              }
              return 0;
            });
          }
          return result;
        }

        async function saveViewToFirestore(view) {
          // view: { id, name, filters, sorts, groupBy, hideInDecks, viewMode, gridSize, isDefault }
          if (!view.id) view.id = `view_${Date.now()}`;
          const existingIndex = savedViews.findIndex(v => v.id === view.id);
          if (existingIndex >= 0) savedViews[existingIndex] = view; else savedViews.push(view);
          // If marked default, unset others
          if (view.isDefault) {
            savedViews.forEach(v => { if (v.id !== view.id) v.isDefault = false; });
            activeViewId = view.id;
          }
          await persistSavedViewsToFirestore();
          renderSavedViewsSelect();
          showToast(`View "${view.name}" saved.`, 'success');
        }

        async function deleteViewFromFirestore(viewId) {
          savedViews = savedViews.filter(v => v.id !== viewId);
          if (activeViewId === viewId) activeViewId = null;
          await persistSavedViewsToFirestore();
          renderSavedViewsSelect();
          showToast('View deleted.', 'success');
        }

        function setActiveViewById(viewId) {
          activeViewId = viewId || null;
          // load view into working editor
          const view = savedViews.find(v => v.id === viewId);
          if (view) {
            viewFilterRules = (view.filters || []).map(f => ({...f}));
            viewSortRules = (view.sorts || []).map(s => ({...s}));
            // Populate builder fields
            document.getElementById('view-group-by-1').value = (view.groupBy && view.groupBy[0]) || '';
            document.getElementById('view-group-by-2').value = (view.groupBy && view.groupBy[1]) || '';
            document.getElementById('view-hide-in-deck').checked = !!view.hideInDecks;
            document.getElementById('view-name-input').value = view.name || '';
            // Populate builder's view-mode and grid-size controls if present
            if (document.getElementById('view-view-mode')) document.getElementById('view-view-mode').value = view.viewMode || collectionViewMode;
            if (document.getElementById('view-grid-size')) document.getElementById('view-grid-size').value = view.gridSize || collectionGridSize;

            // Apply view to the live UI controls so visuals update immediately
            try {
              // Group selects used by the main render
              const g1 = document.getElementById('collection-group-by-1');
              const g2 = document.getElementById('collection-group-by-2');
              if (g1) g1.value = (view.groupBy && view.groupBy[0]) || '';
              if (g2) g2.value = (view.groupBy && view.groupBy[1]) || '';

              // Hide-in-deck checkbox used by the main render
              const hideCheckbox = document.getElementById('hide-in-deck-checkbox');
              if (hideCheckbox) hideCheckbox.checked = !!view.hideInDecks;

              // Apply view mode and grid size
              if (view.viewMode) {
                collectionViewMode = view.viewMode;
                const gridBtn = document.getElementById('view-toggle-grid');
                const tableBtn = document.getElementById('view-toggle-table');
                if (gridBtn && tableBtn) {
                  if (collectionViewMode === 'grid') {
                    gridBtn.classList.add('bg-indigo-600','text-white');
                    tableBtn.classList.remove('bg-indigo-600','text-white');
                  } else {
                    tableBtn.classList.add('bg-indigo-600','text-white');
                    gridBtn.classList.remove('bg-indigo-600','text-white');
                  }
                }
              }
              if (view.gridSize) {
                collectionGridSize = view.gridSize;
                document.querySelectorAll('.grid-size-btn').forEach(b => {
                  b.classList.remove('bg-indigo-600','text-white');
                  if (b.dataset.size === collectionGridSize) b.classList.add('bg-indigo-600','text-white');
                });
              }

              // If view defines sorts, apply primary sort to global collectionSortState so table header sorting reflects it
              if (Array.isArray(view.sorts) && view.sorts.length > 0) {
                const primary = view.sorts[0];
                collectionSortState = { column: primary.column, direction: primary.direction };
                // update sortable header UI classes if present
                document.querySelectorAll('.sortable').forEach(th => {
                  th.classList.remove('sorted-asc','sorted-desc');
                  if (th.dataset.sort === collectionSortState.column) th.classList.add(collectionSortState.direction === 'asc' ? 'sorted-asc' : 'sorted-desc');
                });
              }
            } catch (err) {
              console.warn('Could not apply saved view to live UI controls', err);
            }
          } else {
            viewFilterRules = [];
            viewSortRules = [];
            document.getElementById('view-group-by-1').value = '';
            document.getElementById('view-group-by-2').value = '';
            document.getElementById('view-hide-in-deck').checked = false;
            document.getElementById('view-name-input').value = '';
          }
          renderViewBuilderLists();
          renderSavedViewsSelect();
          // Trigger a re-render of collection
          // Use renderPaginatedCollection which is the canonical entry for collection rendering
          renderPaginatedCollection();
          // Inform user the saved view was applied (useful for programmatic switches)
          if (view && view.name) showToast(`Applied view: ${view.name}`, 'success');
        }

        function renderViewBuilderLists() {
          const filtersList = document.getElementById('filters-list');
          const sortsList = document.getElementById('sorts-list');
          filtersList.innerHTML = viewFilterRules.map((r, i) => `<div class="flex items-center gap-2"><span class="text-sm text-gray-200">${r.column} ${r.operator} "${r.value}"</span><button data-i="${i}" class="remove-filter-btn text-sm text-red-400 ml-2">Remove</button></div>`).join('') || '<div class="text-sm text-gray-500">No filters</div>';
          sortsList.innerHTML = viewSortRules.map((s, i) => `<div class="flex items-center gap-2"><span class="text-sm text-gray-200">${i+1}. ${s.column} ${s.direction}</span><button data-i="${i}" class="remove-sort-btn text-sm text-red-400 ml-2">Remove</button></div>`).join('') || '<div class="text-sm text-gray-500">No sorts</div>';

          // Attach remove handlers
          document.querySelectorAll('.remove-filter-btn').forEach(btn => btn.addEventListener('click', (e) => {
            const idx = Number(e.currentTarget.dataset.i);
            viewFilterRules.splice(idx,1);
            renderViewBuilderLists();
          }));
          document.querySelectorAll('.remove-sort-btn').forEach(btn => btn.addEventListener('click', (e) => {
            const idx = Number(e.currentTarget.dataset.i);
            viewSortRules.splice(idx,1);
            renderViewBuilderLists();
          }));
        }

        // Apply active saved view filters/sorts before grouping/pagination in render flow
        function applySavedViewToCards(cards) {
          if (!activeViewId) return cards;
          // If working rules are empty, attempt to hydrate from the savedViews entry (handles load-order race)
          if ((viewFilterRules.length === 0 && viewSortRules.length === 0)) {
            const v = savedViews.find(s => s.id === activeViewId);
            if (v) {
              viewFilterRules = (v.filters || []).map(f => ({...f}));
              viewSortRules = (v.sorts || []).map(s => ({...s}));
            }
          }
          return applyActiveView(cards);
        }

        function updateCardAssignments() {
          cardDeckAssignments = {}; // This should be keyed by firestoreId
          Object.values(localDecks).forEach((deck) => {
            const allDeckCardsFirestoreIds = Object.keys(deck.cards || {});
            if (deck.commander && deck.commander.firestoreId) {
                allDeckCardsFirestoreIds.push(deck.commander.firestoreId);
            }

            allDeckCardsFirestoreIds.forEach(firestoreId => {
                if (!cardDeckAssignments[firestoreId]) {
                    cardDeckAssignments[firestoreId] = [];
                }
                const existingAssignment = cardDeckAssignments[firestoreId].find(a => a.deckId === deck.id);
                if (!existingAssignment) {
                    cardDeckAssignments[firestoreId].push({
                        deckId: deck.id,
                        deckName: deck.name,
                    });
                }
            });
          });
          console.log("[State] Card to deck assignments updated.");
        }

        // --- RENDER FUNCTIONS ---

        function renderCollection() {
          console.log(
            "[Function: renderCollection] Triggering a full re-render of the collection view. Find in <script> block."
          );
          renderPaginatedCollection();
        }

        function groupCardsRecursively(cards, groupByKeys) {
          if (!groupByKeys || !groupByKeys.length) {
            return cards;
          }

          const currentKey = groupByKeys[0];
          const remainingKeys = groupByKeys.slice(1);

          const groups = cards.reduce((acc, card) => {
            let key;
            if (currentKey === "color_identity") {
              const colors = card.color_identity.join("");
              key = colors === "" ? "Colorless" : colors;
            } else if (currentKey === "type_line") {
              key = card.type_line.split(" — ")[0];
            } else if (currentKey === 'deck') {
              const assignment = (cardDeckAssignments[card.firestoreId] || [])[0];
              key = assignment ? assignment.deckName : 'Not in a Deck';
            }
            else {
              key = card[currentKey] ?? "Other";
            }
            (acc[key] = acc[key] || []).push(card);
            return acc;
          }, {});

          if (remainingKeys.length > 0) {
            for (const groupName in groups) {
              groups[groupName] = groupCardsRecursively(
                groups[groupName],
                remainingKeys
              );
            }
          }

          return groups;
        }

        // Helper: sort an array of card objects according to collectionSortState
        function sortCards(cards) {
          const { column, direction } = collectionSortState;
          const sorted = [...cards].sort((a, b) => {
            let valA, valB;

            if (column === "price") {
              valA = parseFloat(a.prices?.usd || 0);
              valB = parseFloat(b.prices?.usd || 0);
            } else if (column === "count") {
              valA = a.count || 1;
              valB = b.count || 1;
            } else {
              valA = a[column] ?? "";
              valB = b[column] ?? "";
            }

            if (typeof valA === "string") valA = valA.toLowerCase();
            if (typeof valB === "string") valB = valB.toLowerCase();

            if (valA < valB) return direction === "asc" ? -1 : 1;
            if (valA > valB) return direction === "asc" ? 1 : -1;
            return 0;
          });
          return sorted;
        }

        // Helper: sort an array according to active view sort rules if present, otherwise fall back to sortCards
        function sortGroupContent(cards) {
          if (viewSortRules && viewSortRules.length > 0) {
            // perform chained sort similar to applyActiveView's sort logic
            const sorted = [...cards].sort((a,b) => {
              for (const s of viewSortRules) {
                const col = s.column;
                const dir = s.direction === 'asc' ? 1 : -1;
                let valA = a[col] ?? '';
                let valB = b[col] ?? '';
                if (col === 'price') { valA = parseFloat(a.prices?.usd||0); valB = parseFloat(b.prices?.usd||0); }
                if (col === 'count') { valA = a.count||1; valB = b.count||1; }
                if (typeof valA === 'string') valA = valA.toLowerCase();
                if (typeof valB === 'string') valB = valB.toLowerCase();
                if (valA < valB) return -1 * dir;
                if (valA > valB) return 1 * dir;
              }
              return 0;
            });
            return sorted;
          }
          return sortCards(cards);
        }

        // Helper: compute counts for a group (unique items and total copies)
        function computeGroupCounts(items) {
          // items can be an array of cards or a nested object of groups
          if (!items) return { unique: 0, copies: 0 };
          if (Array.isArray(items)) {
            const unique = items.length;
            const copies = items.reduce((acc, c) => acc + (c.count || 1), 0);
            return { unique, copies };
          }
          // Nested groups: accumulate counts from children
          let totalUnique = 0;
          let totalCopies = 0;
          for (const key of Object.keys(items)) {
            const child = items[key];
            const childCounts = computeGroupCounts(child);
            totalUnique += childCounts.unique;
            totalCopies += childCounts.copies;
          }
          return { unique: totalUnique, copies: totalCopies };
        }

        function renderPaginatedCollection() {
          console.log(
            `[Function: renderPaginatedCollection] Rendering page ${collectionCurrentPage} of the collection. Find in <script> block.`
          );
          const contentDiv = document.getElementById("collection-content");
          const paginationDiv = document.getElementById("collection-pagination");
          const noCardsMsg = document.getElementById("no-cards-msg");
          let cards = Object.values(localCollection);

          if (document.getElementById("hide-in-deck-checkbox").checked) {
            cards = cards.filter((card) => !cardDeckAssignments[card.firestoreId]);
          }

          // Apply saved view filters/sorts if a view is active
          cards = applySavedViewToCards(cards);

          if (cards.length === 0) {
            contentDiv.innerHTML = "";
            paginationDiv.innerHTML = "";
            noCardsMsg.classList.remove("hidden");
            return;
          }
          noCardsMsg.classList.add("hidden");

          const filterText = document
            .getElementById("filter-text")
            .value.toLowerCase();
          if (filterText) {
            cards = cards.filter(
              (card) =>
                card.name.toLowerCase().includes(filterText) ||
                card.type_line.toLowerCase().includes(filterText)
            );
          }

          // Get grouping keys
          const groupByKeys = [
            document.getElementById("collection-group-by-1").value,
            document.getElementById("collection-group-by-2").value,
          ].filter(Boolean); // filter(Boolean) removes empty strings

          // When grouping is active we apply grouping first and then sort within each group.
          // Also disable pagination when grouping is active (show full groups).
          if (groupByKeys.length > 0) {
            // Clear pagination UI when grouped
            paginationDiv.innerHTML = "";
          } else {
            // No grouping: apply global sort and pagination as before
            cards = sortCards(cards);

            const totalPages = Math.ceil(cards.length / COLLECTION_PAGE_SIZE);
            if (totalPages > 1) {
              const start = (collectionCurrentPage - 1) * COLLECTION_PAGE_SIZE;
              const end = start + COLLECTION_PAGE_SIZE;
              const paginatedCards = cards.slice(start, end);
              renderPaginationControls(totalPages);
              cards = paginatedCards;
            } else {
              paginationDiv.innerHTML = "";
            }
          }

          if (collectionViewMode === "grid") {
            renderCollectionGrid(cards, groupByKeys);
          } else {
            renderCollectionTable(cards, groupByKeys);
          }
        }

        function renderPaginationControls(totalPages) {
          const paginationDiv = document.getElementById("collection-pagination");
          let html = "";
          for (let i = 1; i <= totalPages; i++) {
            const activeClass =
              i === collectionCurrentPage
                ? "bg-indigo-600 text-white"
                : "bg-gray-700 hover:bg-gray-600";
            html += `<button class="pagination-btn ${activeClass} font-bold py-2 px-4 rounded" data-page="${i}">${i}</button>`;
          }
          paginationDiv.innerHTML = html;

          document.querySelectorAll(".pagination-btn").forEach((button) => {
            button.addEventListener("click", () => {
              collectionCurrentPage = parseInt(button.dataset.page, 10);
              renderPaginatedCollection();
            });
          });
        }

        function renderCollectionGrid(cards, groupByKeys) {
          // renderCollectionGrid
          const contentDiv = document.getElementById("collection-content");

          const sizeClasses = {
            sm: "grid-cols-4 sm:grid-cols-5 md:grid-cols-7 lg:grid-cols-9 xl:grid-cols-11",
            md: "grid-cols-3 sm:grid-cols-4 md:grid-cols-6 lg:grid-cols-7 xl:grid-cols-9",
            lg: "grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6",
          };
          const gridClass = sizeClasses[collectionGridSize] || sizeClasses.md;

          function renderRecursiveGroups(groups, level) {
            return Object.keys(groups)
              .sort()
              .map((groupName) => {
                const content = groups[groupName];
                const uid = `group-${groupUidCounter++}`;
                // If content is an array, compute counts and render cards (sorted)
                if (Array.isArray(content)) {
                  const counts = computeGroupCounts(content);
                  const headerHtml = `
                    <details id="${uid}" class="col-span-full" ${level === 0 ? "" : "open"}>
                      <summary class="group-header" style="padding-left: ${1.5 + level}rem;">
                        ${groupName} <span class="text-sm text-gray-400 ml-3">(${counts.unique} items, ${counts.copies} total)</span>
                      </summary>
                      <div class="grid ${gridClass} gap-4 p-4">
                        ${sortGroupContent(content).map(renderCollectionCard).join("")}
                      </div>
                    </details>
                  `;
                  return headerHtml;
                } else {
                  // subgroup: compute aggregated counts from nested children and render collapsible group
                  const counts = computeGroupCounts(content);
                  const subgroupHtml = `
                    <details id="${uid}" class="col-span-full" ${level === 0 ? "" : "open"}>
                      <summary class="group-header" style="padding-left: ${1.5 + level}rem;">
                        ${groupName} <span class="text-sm text-gray-400 ml-3">(${counts.unique} items, ${counts.copies} total)</span>
                      </summary>
                      <div class="col-span-full">
                        ${renderRecursiveGroups(content, level + 1)}
                      </div>
                    </details>
                  `;
                  return subgroupHtml;
                }
              })
              .join("");
          }

          if (groupByKeys.length > 0) {
            console.log(
              `[renderCollectionGrid] Grouping cards by "${groupByKeys.join(
                ", "
              )}".`
            );
            const groupedCards = groupCardsRecursively(cards, groupByKeys);
            // Reset UID counter for stable IDs on re-render
            groupUidCounter = 0;
            contentDiv.innerHTML = `<div class="grid ${gridClass} gap-4 p-4">
                                        ${renderRecursiveGroups(groupedCards, 0)}
                                    </div>`;
            // Accessibility: make details summaries keyboard-toggleable
            contentDiv.querySelectorAll('details summary').forEach(summary => {
              summary.tabIndex = 0;
              summary.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                  e.preventDefault();
                  const details = summary.parentElement;
                  details.open = !details.open;
                }
              });
            });
          } else {
            contentDiv.innerHTML = `<div class="grid ${gridClass} gap-4 p-4">
                                        ${cards.map(renderCollectionCard).join("")}
                                    </div>`;
          }
          addCollectionCardListeners();
        }

        function renderCollectionTable(cards, groupByKeys) {
            // renderCollectionTable
            const contentDiv = document.getElementById("collection-content");
            const renderTableRows = (cardGroup) =>
                cardGroup
                .map((card) => {
                    const price = card.prices?.usd_foil && card.finish === "foil" ? card.prices.usd_foil : card.prices?.usd || "N/A";
                    const isCommander = card.type_line.includes("Legendary");
                    const assignment = (cardDeckAssignments[card.firestoreId] || [])[0];
                    return `<tr class="bg-gray-800 border-b border-gray-700 hover:bg-gray-700/50">
                                <td class="px-6 py-4">
                                    <div class="flex items-center gap-3">
                                        <div class="w-10 flex-shrink-0">
                                            <div class="card-image-container rounded-md overflow-hidden">
                                                <img src="${card.image_uris?.small}" class="card-image" loading="lazy" alt="${card.name}">
                                            </div>
                                        </div>
                                        <div>
                                            <div class="font-bold">${card.name}</div>
                                            <div class="text-sm text-gray-400">${card.set_name}</div>
                                        </div>
                                    </div>
                                </td>
                                <td class="px-6 py-4 text-center">${card.count || 1}</td>
                                <td class="px-6 py-4">${card.type_line}</td>
                                <td class="px-6 py-4">${assignment ? assignment.deckName : 'None'}</td>
                                <td class="px-6 py-4">${card.rarity}</td>
                                <td class="px-6 py-4 text-center">${card.cmc || 0}</td>
                                <td class="px-6 py-4 text-right">$${price}</td>
                                <td class="px-6 py-4 text-right">
                                    <button class="p-2 hover:bg-gray-600 rounded-full view-card-details-btn" data-firestore-id="${card.firestoreId}">
                                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>
                                    </button>
                                    ${isCommander ? `<button class="p-2 hover:bg-gray-600 rounded-full create-deck-from-commander-btn" data-firestore-id="${card.firestoreId}" title="Create Commander Deck">
                                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path></svg>
                                    </button>` : ""}
                                    <button class="p-2 hover:bg-red-800 rounded-full delete-button" data-firestore-id="${card.firestoreId}">
                                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                                    </button>
                                </td>
                            </tr>`;
                }).join("");

            function renderRecursiveRows(groups, level) {
        return Object.keys(groups).sort().map((groupName) => {
          const content = groups[groupName];
          const uid = `group-${groupUidCounter++}`;
          if (Array.isArray(content)) {
            const counts = computeGroupCounts(content);
            // Render a single row containing a <details> element for the group
            const headerAndRows = `
            <tr class="bg-gray-700">
              <th colspan="8" class="px-6 py-2 text-left text-lg font-bold text-gray-300 bg-gray-700" style="padding-left: ${1 + level}rem; z-index: 3;">
                <details id="${uid}" ${level === 0 ? "" : "open"}>
                  <summary style="list-style:none; outline:none;" class="cursor-pointer">${groupName} <span class="text-sm text-gray-400">(${counts.unique} items, ${counts.copies} total)</span></summary>
                  <div class="mt-2"></div>
                </details>
              </th>
            </tr>
            <tr class="group-rows-wrapper"><td colspan="8" class="p-0 border-0">
              <div class="overflow-hidden group-rows" data-group-id="${uid}">
                <table class="w-full text-sm text-left text-gray-300">
                  <tbody>
                  ${renderTableRows(sortGroupContent(content))}
                  </tbody>
                </table>
              </div>
            </td></tr>
            `;
            return headerAndRows;
          } else {
            // Subgroup: compute aggregated counts so parent headers reflect totals of nested groups
            const counts = computeGroupCounts(content);
            const subgroupHtml = `
            <tr class="bg-gray-700">
              <th colspan="8" class="px-6 py-2 text-left text-lg font-bold text-gray-300 bg-gray-700" style="padding-left: ${1 + level}rem; z-index: 3;">
                <details id="${uid}" ${level === 0 ? "" : "open"}>
                  <summary style="list-style:none; outline:none;" class="cursor-pointer">${groupName} <span class="text-sm text-gray-400">(${counts.unique} items, ${counts.copies} total)</span></summary>
                </details>
              </th>
            </tr>
            ${renderRecursiveRows(content, level + 1)}
            `;
            return subgroupHtml;
          }
        }).join("");
            }

            const tableHeader = `
  <thead class="text-xs text-gray-400 uppercase sticky bg-gray-800" style="z-index: 6;">
                    <tr>
                        <th scope="col" class="px-6 py-3 sortable" data-sort="name">Name / Info</th>
                        <th scope="col" class="px-6 py-3 sortable" data-sort="count">#</th>
                        <th scope="col" class="px-6 py-3 sortable" data-sort="type_line">Type</th>
                        <th scope="col" class="px-6 py-3 sortable" data-sort="deck">Deck</th>
                        <th scope="col" class="px-6 py-3 sortable" data-sort="rarity">Rarity</th>
                        <th scope="col" class="px-6 py-3 sortable" data-sort="cmc">Mana</th>
                        <th scope="col" class="px-6 py-3 sortable" data-sort="price">Price</th>
                        <th scope="col" class="px-6 py-3"></th>
                    </tr>
                </thead>`;

            if (groupByKeys.length > 0) {
                const groupedCards = groupCardsRecursively(cards, groupByKeys);
                // Render a floating header table (outside the horizontal scroller) and a scrollable body table
                contentDiv.innerHTML = `
                  <div class="table-area w-full">
                    <div class="floating-header-wrapper bg-gray-800"></div>
                    <div class="overflow-x-auto body-scroll bg-gray-800 rounded-b-lg">
                      <table class="w-full text-sm text-left text-gray-300 body-table">
                          <tbody>${renderRecursiveRows(groupedCards,0)}</tbody>
                        </table>
                    </div>
                  </div>
                `;

                // After DOM insertion, create the floating header table and sync widths + scroll
                (function setupFloatingHeader() {
                  try {
                    const area = contentDiv.querySelector('.table-area');
                    const floatingWrapper = area.querySelector('.floating-header-wrapper');
                    const bodyScroll = area.querySelector('.body-scroll');
                    const bodyTable = area.querySelector('.body-table');

                    // Create header-only table inside floating wrapper
                    const headerTable = document.createElement('table');
                    headerTable.className = 'w-full text-sm text-left text-gray-300 header-table';
                    headerTable.innerHTML = `${tableHeader}`;
                    floatingWrapper.appendChild(headerTable);

                    // Make the floating wrapper sticky relative to viewport and position under app header
                    floatingWrapper.style.position = 'sticky';
                    floatingWrapper.style.top = '0px';
                    floatingWrapper.style.zIndex = 8;

                    // Sync horizontal scroll: when the body scrolls horizontally, move the floating header
                    bodyScroll.addEventListener('scroll', () => {
                      floatingWrapper.scrollLeft = bodyScroll.scrollLeft;
                    });

                    // Sync column widths by measuring first body row cells
                    const syncWidths = () => {
                      const firstRow = bodyTable.querySelector('tbody tr');
                      if (!firstRow) return;
                      const bodyCells = Array.from(firstRow.children);
                      const headerCells = Array.from(headerTable.querySelectorAll('thead th'));
                      // set table layout fixed to keep columns stable
                      headerTable.style.tableLayout = 'fixed';
                      bodyTable.style.tableLayout = 'fixed';
                      // Apply widths
                      const widths = bodyCells.map(td => td.getBoundingClientRect().width);
                      // set header table total width to body table width
                      headerTable.style.width = `${bodyTable.getBoundingClientRect().width}px`;
                      headerCells.forEach((th, i) => {
                        if (widths[i]) th.style.width = `${widths[i]}px`;
                      });
                    };

                    // Initial sync and after a short delay to allow images to load
                    syncWidths();
                    setTimeout(syncWidths, 250);

                    // Re-sync on resize
                    window.addEventListener('resize', syncWidths);

                    // Position floating header under the app header
                    const placeHeader = () => {
                      const appHeader = document.querySelector('header');
                      const offset = appHeader ? appHeader.getBoundingClientRect().bottom : 0;
                      // compute offset relative to viewport for sticky positioning
                      floatingWrapper.style.top = `${Math.ceil(offset)}px`;
                    };
                    placeHeader();
                    window.addEventListener('resize', placeHeader);
                    window.addEventListener('scroll', placeHeader, { passive: true });
                  } catch (err) {
                    console.error('[setupFloatingHeader] error', err);
                  }
                })();
        // After inserting, wire up details toggle behavior: when a group's details open/close, show/hide its nested rows
        contentDiv.querySelectorAll('details').forEach(det => {
          det.addEventListener('toggle', (e) => {
          const id = det.id;
          const wrapper = contentDiv.querySelector(`.group-rows[data-group-id="${id}"]`);
          if (wrapper) {
            wrapper.style.display = det.open ? 'block' : 'none';
          }
          });
          // Initialize visibility based on initial open state
          const id = det.id;
          const wrapper = contentDiv.querySelector(`.group-rows[data-group-id="${id}"]`);
          if (wrapper) wrapper.style.display = det.open ? 'block' : 'none';
        });
            } else {
        // No grouping: apply global sort to the cards before rendering the table rows
        const sorted = sortCards(cards);
        contentDiv.innerHTML = `
          <div class="table-area w-full">
            <div class="floating-header-wrapper bg-gray-800"></div>
            <div class="overflow-x-auto body-scroll bg-gray-800 rounded-b-lg">
              <table class="w-full text-sm text-left text-gray-300 body-table">
                <tbody>${renderTableRows(sorted)}</tbody>
              </table>
            </div>
          </div>
        `;

        // Setup floating header behavior for the non-grouped table as well
        (function setupFloatingHeader() {
          try {
            const area = contentDiv.querySelector('.table-area');
            const floatingWrapper = area.querySelector('.floating-header-wrapper');
            const bodyScroll = area.querySelector('.body-scroll');
            const bodyTable = area.querySelector('.body-table');

            const headerTable = document.createElement('table');
            headerTable.className = 'w-full text-sm text-left text-gray-300 header-table';
            headerTable.innerHTML = `${tableHeader}`;
            floatingWrapper.appendChild(headerTable);

            floatingWrapper.style.position = 'sticky';
            floatingWrapper.style.top = '0px';
            floatingWrapper.style.zIndex = 8;

            bodyScroll.addEventListener('scroll', () => {
              floatingWrapper.scrollLeft = bodyScroll.scrollLeft;
            });

            const syncWidths = () => {
              const firstRow = bodyTable.querySelector('tbody tr');
              if (!firstRow) return;
              const bodyCells = Array.from(firstRow.children);
              const headerCells = Array.from(headerTable.querySelectorAll('thead th'));
              headerTable.style.tableLayout = 'fixed';
              bodyTable.style.tableLayout = 'fixed';
              const widths = bodyCells.map(td => td.getBoundingClientRect().width);
              headerTable.style.width = `${bodyTable.getBoundingClientRect().width}px`;
              headerCells.forEach((th, i) => {
                if (widths[i]) th.style.width = `${widths[i]}px`;
              });
            };

            syncWidths();
            setTimeout(syncWidths, 250);
            window.addEventListener('resize', syncWidths);

            const placeHeader = () => {
              const appHeader = document.querySelector('header');
              const offset = appHeader ? appHeader.getBoundingClientRect().bottom : 0;
              floatingWrapper.style.top = `${Math.ceil(offset)}px`;
            };
            placeHeader();
            window.addEventListener('resize', placeHeader);
            window.addEventListener('scroll', placeHeader, { passive: true });
          } catch (err) {
            console.error('[setupFloatingHeader] error', err);
          }
        })();
            }

            addCollectionTableListeners();
        }

        function renderSingleDeck(deckId) {
          console.log(
            `[Function: renderSingleDeck] Rendering view for deck ID ${deckId}. Find in <script> block.`
          );
          const deck = localDecks[deckId];
          if (!deck) {
            console.error(
              `[renderSingleDeck] Could not find deck with ID ${deckId}. Returning to decks view.`
            );
            showView("decks");
            return;
          }
          views.singleDeck.dataset.deckId = deckId;
          document.getElementById('page-title').textContent = deck.name;

          const allDeckCards = Object.keys(deck.cards || {}).map(firestoreId => {
              const cardData = localCollection[firestoreId];
              if (!cardData) return null;
              // The count in deck is stored on the deck object
              return { ...cardData, count: deck.cards[firestoreId].count };
          }).filter(Boolean); // Filter out any nulls if card was deleted from collection

          if (deck.commander) {
            // Find the commander in the collection to get its full data, but use a count of 1
            const commanderInCollection = localCollection[deck.commander.firestoreId];
            if(commanderInCollection) {
                allDeckCards.push({ ...commanderInCollection, count: 1 });
            }
          }


          const totalCost = allDeckCards.reduce((acc, card) => {
            const price =
              card.finish === "foil"
                ? card.prices?.usd_foil
                : card.prices?.usd;
            const cardCost = parseFloat(price) || 0;
            const count = card.count || 1;
            return acc + cardCost * count;
          }, 0);

          const cardCountsByType = allDeckCards.reduce((acc, card) => {
            const mainType = card.type_line.split(" — ")[0];
            const count = card.count || 1;
            if (acc[mainType]) {
              acc[mainType] += count;
            } else {
              acc[mainType] = count;
            }
            return acc;
          }, {});

          const blueprint = deck.aiBlueprint?.suggestedCounts;
          const kpiData = [
            {
              label: "Deck Value",
              current: `$${totalCost.toFixed(2)}`,
              target: null,
            },
            {
              label: "Total",
              current: allDeckCards.reduce((acc, c) => acc + (c.count || 1), 0),
              target: blueprint?.Total,
            },
            {
              label: "Creature",
              current: cardCountsByType.Creature || 0,
              target: blueprint?.Creature,
            },
            {
              label: "Land",
              current: cardCountsByType.Land || 0,
              target: blueprint?.Land,
            },
            {
              label: "Instant",
              current: cardCountsByType.Instant || 0,
              target: blueprint?.Instant,
            },
            {
              label: "Sorcery",
              current: cardCountsByType.Sorcery || 0,
              target: blueprint?.Sorcery,
            },
            {
              label: "Enchantment",
              current: cardCountsByType.Enchantment || 0,
              target: blueprint?.Enchantment,
            },
            {
              label: "Artifact",
              current: cardCountsByType.Artifact || 0,
              target: blueprint?.Artifact,
            },
            {
              label: "Planeswalker",
              current: cardCountsByType.Planeswalker || 0,
              target: blueprint?.Planeswalker,
            },
          ];

          const kpiHtml = kpiData
            .map((kpi) => {
              const hasTarget = kpi.target !== null && kpi.target !== undefined;
              const percentage = hasTarget
                ? Math.min((kpi.current / kpi.target) * 100, 100)
                : 0;
              let barColor = "bg-gray-500";
              if (hasTarget) {
                if (percentage < 50) barColor = "bg-red-500";
                else if (percentage < 90) barColor = "bg-yellow-500";
                else barColor = "bg-green-500";
              }

              return `
                <div class="bg-gray-700/50 p-3 rounded-lg relative overflow-hidden">
                    <div class="flex justify-between items-baseline">
                        <span class="text-sm text-gray-400">${kpi.label}</span>
                        <span class="font-bold text-lg">${kpi.current}${
                hasTarget ? ` / ${kpi.target}` : ""
              }</span>
                    </div>
                    ${
                      hasTarget
                        ? `<div class="kpi-gradient-bar ${barColor}" style="width: ${percentage}%"></div>`
                        : ""
                    }
                </div>
              `;
            })
            .join("");

          const manaCurveData = allDeckCards.reduce((acc, card) => {
            if (card && !card.type_line.toLowerCase().includes("land")) {
              const cmc = Math.min(card.cmc, 7); // Group 7+ cmc together
              const count = card.count || 1;
              acc[cmc] = (acc[cmc] || 0) + count;
            }
            return acc;
          }, {});

          const colorIdentity = deck.commander?.color_identity || [];
          const colorSymbols = {
            W: '<img src="https://svgs.scryfall.io/card-symbols/W.svg" class="w-5 h-5" alt="White Mana">',
            U: '<img src="https://svgs.scryfall.io/card-symbols/U.svg" class="w-5 h-5" alt="Blue Mana">',
            B: '<img src="https://svgs.scryfall.io/card-symbols/B.svg" class="w-5 h-5" alt="Black Mana">',
            R: '<img src="https://svgs.scryfall.io/card-symbols/R.svg" class="w-5 h-5" alt="Red Mana">',
            G: '<img src="https://svgs.scryfall.io/card-symbols/G.svg" class="w-5 h-5" alt="Green Mana">',
          };
          const colorIcons = colorIdentity
            .map((c) => colorSymbols[c])
            .join("");

          views.singleDeck.innerHTML = `
            <div class="space-y-6">
                <!-- Top Header Section -->
                <div class="bg-gray-800 p-4 rounded-lg shadow-lg">
                    <div class="flex flex-col sm:flex-row justify-between items-start gap-4">
                        <div>
                             <h2 class="text-3xl font-bold mb-2">${deck.name}</h2>
                             <p class="text-gray-400">Format: ${deck.format}</p>
                        </div>
                         <div class="flex items-center gap-2">
                          ${colorIcons}
                          <button id="add-cards-to-deck-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg ml-4">Add Cards</button>
                          <button id="deck-delete-btn" data-deck-id="${deckId}" class="delete-button bg-red-800 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg">Delete Deck</button>
                         </div>
                    </div>
                </div>

                <!-- Main Content Grid -->
                <div class="grid grid-cols-1 lg:grid-cols-5 gap-6">
                    <!-- Left Column: Commander & Stats -->
                    <div class="lg:col-span-2 space-y-6">
                        ${
                          deck.commander
                            ? `
                        <div class="bg-gray-800 p-4 rounded-lg shadow-lg">
                            <h3 class="text-xl font-semibold mb-3">Commander</h3>
                            <div class="relative group">
                                <div class="card-image-container rounded-lg overflow-hidden">
                                    <img src="${deck.commander.image_uris?.normal}" class="card-image" alt="${deck.commander.name}">
                                </div>
                                <div class="absolute inset-0 bg-black/50 opacity-0 group-hover:opacity-100 transition-opacity flex items-center justify-center">
                                    <button class="view-card-details-btn bg-white/20 backdrop-blur-sm text-white font-bold py-2 px-4 rounded-lg" data-firestore-id="${deck.commander.firestoreId}">View Details</button>
                                </div>
                            </div>
                        </div>`
                            : ""
                        }
                       
                        <div class="bg-gray-800 p-4 rounded-lg shadow-lg">
                            <h3 class="text-xl font-semibold mb-3">Statistics</h3>
                            <div class="grid grid-cols-2 gap-3">
                                ${kpiHtml}
                            </div>
                        </div>

                         <div class="bg-gray-800 p-4 rounded-lg shadow-lg">
                             <h3 class="text-xl font-semibold mb-3">Mana Curve</h3>
                             <canvas id="mana-curve-chart"></canvas>
                         </div>

                        <div class="bg-gray-800 p-4 rounded-lg shadow-lg">
                            <h3 class="text-xl font-semibold mb-3">Deck Tools</h3>
                            <div class="space-y-3">
                                ${deck.aiBlueprint ? `<button id="view-strategy-btn" class="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded-lg">View AI Strategy</button>` : ''}
                                <button id="ai-suggestions-btn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg">Deck Suggestions</button>
                                <button id="export-deck-btn" data-deck-id="${deckId}" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg">Export Decklist (.txt)</button>
                            </div>
                        </div>
                    </div>
                     <!-- Right Column: Decklist -->
                    <div class="lg:col-span-3 bg-gray-800 p-4 rounded-lg shadow-lg">
                        <h3 class="text-2xl font-semibold mb-4">Decklist</h3>
                        <div id="decklist-container" class="space-y-4">
                            <!-- Decklist will be populated here -->
                        </div>
                    </div>
                </div>
            </div>
          `;

          renderDecklist(deckId);
          renderManaCurveChart(manaCurveData);
          addSingleDeckListeners(deckId);
        }

        // --- UI/HELPER FUNCTIONS ---
        function toggleEditMode() {
            // toggleEditMode
            const appWrapper = document.getElementById('app-wrapper');
            const isEditMode = appWrapper.classList.toggle('edit-mode');
            const buttonText = document.getElementById('edit-mode-text');
            if (isEditMode) {
                buttonText.textContent = 'Exit Edit Mode';
                showToast('Edit mode enabled. Deletion is now possible.', 'warning');
            } else {
                buttonText.textContent = 'Edit Mode';
            }
            // Re-render views that might be affected by edit mode
            if (!views.collection.classList.contains('hidden')) {
                renderCollection();
            }
            if (!views.decks.classList.contains('hidden')) {
                renderDecksList();
            }
            const activeDeckId = views.singleDeck.dataset.deckId;
            if (!views.singleDeck.classList.contains('hidden') && activeDeckId) {
                renderSingleDeck(activeDeckId);
            }
        }

        function toggleCardDetailsEditMode() {
            // toggleCardDetailsEditMode
            const wrapper = document.getElementById('card-details-modal-content-wrapper');
            const isEditing = wrapper.classList.toggle('card-modal-edit-mode');

            if (isEditing) {
                showToast("Card edit mode enabled.", "info");
            } else {
                // If exiting edit mode, save the data
                const firestoreId = wrapper.dataset.firestoreId;
                if (firestoreId) {
                    saveCardDetails(firestoreId);
                }
            }
        }

        // --- Mock test runner (only active when ?mocktest=1 in URL) ---
        (function runMockTestIfRequested(){
          try {
            const params = new URLSearchParams(window.location.search);
            if (!params.get('mocktest')) return;
            console.log('[MockTest] Initializing mock dataset for saved-view + grouping test');
            // Minimal sample collection (two sets, multiple copies)
            localCollection = {
              'c1': { firestoreId: 'c1', name: 'Barbarian Class', set_name: 'Adventures in the Forgotten Realms', type_line: 'Enchantment — Class', rarity: 'uncommon', cmc: 1, count: 5, image_uris: { small: '' }, prices: { usd: '0.25' } },
              'c2': { firestoreId: 'c2', name: 'Battle Cry Goblin', set_name: 'Adventures in the Forgotten Realms', type_line: 'Creature — Goblin', rarity: 'uncommon', cmc: 2, count: 3, image_uris: { small: '' }, prices: { usd: '0.24' } },
              'c3': { firestoreId: 'c3', name: 'Forest', set_name: 'Core Set 2021', type_line: 'Basic Land — Forest', rarity: 'common', cmc: 0, count: 10, image_uris: { small: '' }, prices: { usd: '0.05' } },
              'c4': { firestoreId: 'c4', name: 'Llanowar Elves', set_name: 'Core Set 2021', type_line: 'Creature — Elf Druid', rarity: 'common', cmc: 1, count: 2, image_uris: { small: '' }, prices: { usd: '0.10' } }
            };
            updateCardAssignments();
            // Add a saved view that groups by set_name (primary) and sorts by name desc
            savedViews = [
              { id: 'mock_view_1', name: 'GroupBySet_NameDesc', isDefault: true, filters: [], sorts: [{ column: 'name', direction: 'desc' }], groupBy: ['set_name'], hideInDecks: false, viewMode: 'table', gridSize: 'md' }
            ];
            activeViewId = 'mock_view_1';
            renderSavedViewsSelect();
            // Ensure working rules are hydrated and applied
            setActiveViewById(activeViewId);
            console.log('[MockTest] Mock view applied — verify table grouping and collapse/expand behavior');
          } catch (err) {
            console.warn('Mock test setup failed', err);
          }
        })();

  /*
  Commit summary (suggested):
  - Fix: Table view grouping and collapsible group rows; sort within groups (group-first then sort)
  - Feature: Advanced saved views (multi-filter, multi-sort, group, hide-in-decks)
  - Feature: Save/load view mode (grid/table) and grid size (S/M/L) with views
  - UX: Collapsible groups (grid & table), group counts shown, pagination disabled when grouping
  - UX: Toast notifications on save/delete/apply view; improved saved-views dropdown labels
  - Dev: Mock test runner retained (trigger with ?mocktest=1) for local verification
  - Cleanup: Removed noisy debug logs and added UI polish
  */

        async function saveCardDetails(firestoreId) {
            if (!firestoreId) {
                showToast("Cannot save changes. Card not found in collection.", "error");
                return;
            }
            console.log(`[Function: saveCardDetails] Saving details for firestoreId ${firestoreId}.`);

            const cardRef = doc(db, `artifacts/${appId}/users/${userId}/collection`, firestoreId);

            try {
                const newCount = modalVisibilitySettings.count ? (parseInt(document.getElementById('modal-edit-count').value, 10) || 0) : localCollection[firestoreId].count;
                
                if (newCount <= 0) {
                    await deleteDoc(cardRef);
                    showToast("Card removed from collection as count was set to 0.", "success");
                    closeModal('card-details-modal');
                    return; // Exit early
                }

                const updatedData = { count: newCount };
                if (modalVisibilitySettings.finish) updatedData.finish = document.getElementById('modal-edit-finish').value;
                if (modalVisibilitySettings.condition) updatedData.condition = document.getElementById('modal-edit-condition').value.trim() || null;
                if (modalVisibilitySettings.purchasePrice) updatedData.purchasePrice = parseFloat(document.getElementById('modal-edit-purchasePrice').value) || null;
                if (modalVisibilitySettings.notes) updatedData.notes = document.getElementById('modal-edit-notes').value.trim() || null;
                
                await updateDoc(cardRef, updatedData);
                showToast("Card details saved!", "success");
                
                const wrapper = document.getElementById('card-details-modal-content-wrapper');
                wrapper.classList.remove('card-modal-edit-mode');
                // Let the snapshot listener handle the re-render of the modal content
                
            } catch (error) {
                console.error("Error saving card details:", error);
                showToast("Failed to save card details.", "error");
            }
        }
        
        function renderCardDetailsModal(card) {
            const contentDiv = document.getElementById('card-details-content');
            const wrapper = document.getElementById('card-details-modal-content-wrapper');
            wrapper.dataset.firestoreId = card.firestoreId; // Use firestoreId to ensure we're editing the correct document
            wrapper.classList.remove('card-modal-edit-mode');

            const assignments = cardDeckAssignments[card.firestoreId] || [];

            contentDiv.innerHTML = `
                <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                    <div class="md:col-span-1">
                        <img src="${card.image_uris?.normal}" class="rounded-lg w-full">
                    </div>
                    <div class="md:col-span-2 space-y-4">
                        <h3 class="text-3xl font-bold">${card.name} ${card.mana_cost || ''}</h3>
                        <p class="text-lg text-gray-400">${card.type_line}</p>
                        <div class="text-gray-300 space-y-2 whitespace-pre-wrap">${card.oracle_text}</div>
                        ${card.power && card.toughness ? `<p class="text-xl font-bold">${card.power}/${card.toughness}</p>` : ''}
                        <hr class="border-gray-600">
                        <div class="grid grid-cols-2 gap-x-4 gap-y-2 text-sm">
                            <p><strong>Set:</strong> ${card.set_name} (${card.set.toUpperCase()})</p>
                            <p><strong>Rarity:</strong> ${card.rarity}</p>
                            
                            <!-- Collection Details -->
                            ${modalVisibilitySettings.count ? `
                            <div><strong>Count:</strong>
                                <span class="card-modal-value-display">${card.count || 1}</span>
                                <input id="modal-edit-count" type="number" value="${card.count || 1}" min="0" class="card-modal-value-input mt-1 w-full bg-gray-700 border border-gray-600 rounded-lg px-2 py-1 text-sm">
                            </div>` : ''}

                            ${modalVisibilitySettings.finish ? `
                            <div><strong>Finish:</strong>
                                <span class="card-modal-value-display">${card.finish || 'nonfoil'}</span>
                                <select id="modal-edit-finish" class="card-modal-value-input mt-1 w-full bg-gray-700 border border-gray-600 rounded-lg px-2 py-1 text-sm">
                                    <option value="nonfoil" ${card.finish === 'nonfoil' ? 'selected' : ''}>Non-Foil</option>
                                    <option value="foil" ${card.finish === 'foil' ? 'selected' : ''}>Foil</option>
                                    <option value="etched" ${card.finish === 'etched' ? 'selected' : ''}>Etched</option>
                                </select>
                            </div>` : ''}

                            ${modalVisibilitySettings.condition ? `
                            <div><strong>Condition:</strong>
                                <span class="card-modal-value-display">${card.condition || 'Not Set'}</span>
                                <input id="modal-edit-condition" type="text" value="${card.condition || ''}" placeholder="e.g., Near Mint" class="card-modal-value-input mt-1 w-full bg-gray-700 border border-gray-600 rounded-lg px-2 py-1 text-sm">
                            </div>` : ''}

                            ${modalVisibilitySettings.purchasePrice ? `
                            <div><strong>Purchase Price:</strong>
                                <span class="card-modal-value-display">$${(card.purchasePrice || 0).toFixed(2)}</span>
                                <input id="modal-edit-purchasePrice" type="number" value="${card.purchasePrice || ''}" step="0.01" placeholder="e.g., 4.99" class="card-modal-value-input mt-1 w-full bg-gray-700 border border-gray-600 rounded-lg px-2 py-1 text-sm">
                            </div>` : ''}
                        </div>
                        
                        ${modalVisibilitySettings.notes ? `
                        <div class="col-span-2"><strong>Notes:</strong>
                            <p class="card-modal-value-display text-gray-400 whitespace-pre-wrap">${card.notes || 'No notes.'}</p>
                            <textarea id="modal-edit-notes" placeholder="Add notes here..." class="card-modal-value-input mt-1 w-full bg-gray-700 border border-gray-600 rounded-lg px-2 py-1 text-sm h-24">${card.notes || ''}</textarea>
                        </div>` : ''}
                        
                        ${modalVisibilitySettings.deckAssignments && assignments.length > 0 ? `
                        <div class="col-span-2">
                            <hr class="border-gray-600 my-2">
                            <p><strong>In Decks:</strong></p>
                            <ul class="list-disc list-inside text-gray-400">
                                ${assignments.map(a => `<li>${a.deckName}</li>`).join('')}
                            </ul>
                        </div>` : ''}
                    </div>
                </div>
            `;
        }


        function renderModalVisibilitySettings() {
            // renderModalVisibilitySettings
            const container = document.getElementById('modal-visibility-settings');
            const allFields = ['count', 'finish', 'condition', 'purchasePrice', 'notes', 'deckAssignments'];
            
            container.innerHTML = allFields.map(field => {
                const label = field.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
                return `
                    <div class="flex items-center">
                        <input type="checkbox" id="setting-vis-${field}" data-field="${field}" class="h-4 w-4 rounded bg-gray-700 border-gray-600 text-indigo-600 focus:ring-indigo-500" ${modalVisibilitySettings[field] ? 'checked' : ''}>
                        <label for="setting-vis-${field}" class="ml-2 text-sm text-gray-300">${label}</label>
                    </div>
                `;
            }).join('');

            container.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                checkbox.addEventListener('change', (e) => {
                    const field = e.target.dataset.field;
                    modalVisibilitySettings[field] = e.target.checked;
                    saveSettings();
                });
            });
        }
        
        function renderAiBlueprintModal(blueprint, deckName, isReadOnly = false) {
            console.log(`[Function: renderAiBlueprintModal] Rendering AI blueprint for "${deckName}". Read-only: ${isReadOnly}`);
            const titleEl = document.getElementById('ai-blueprint-title');
            const contentEl = document.getElementById('ai-blueprint-content');
            const footerEl = document.getElementById('ai-blueprint-footer');

            titleEl.textContent = `AI Blueprint: ${deckName}`;

            const counts = blueprint.suggestedCounts || {};
            const countsHtml = Object.entries(counts)
                .filter(([key]) => key !== 'Total')
                .map(([key, value]) => `
                    <div class="flex justify-between items-center p-2 bg-gray-900/50 rounded">
                        <span class="font-semibold">${key}</span>
                        <span class="text-indigo-400 font-bold">${value}</span>
                    </div>
                `).join('');

            contentEl.innerHTML = `
                <div>
                    <h4 class="text-xl font-bold text-indigo-300 mb-2">Deck Summary</h4>
                    <p class="text-gray-300">${blueprint.summary}</p>
                </div>
                <div>
                    <h4 class="text-xl font-bold text-indigo-300 mb-2">Strategy</h4>
                    <p class="text-gray-300 whitespace-pre-line">${blueprint.strategy}</p>
                </div>
                <div>
                    <h4 class="text-xl font-bold text-indigo-300 mb-2">Suggested Card Counts (99 total)</h4>
                    <div class="grid grid-cols-2 gap-2 text-sm">
                        ${countsHtml}
                        <div class="flex justify-between items-center p-2 bg-gray-700 rounded col-span-2">
                            <span class="font-bold text-lg">Total</span>
                            <span class="text-white font-bold text-lg">${counts.Total || 'N/A'}</span>
                        </div>
                    </div>
                </div>
            `;

            if (isReadOnly) {
                footerEl.classList.add('hidden');
            } else {
                footerEl.classList.remove('hidden');
            }
        }

    // showToast/openModal/closeModal delegators removed: rely on Public/js/lib/ui.js window shims.
        
        function renderDecksList() {
             console.log('[Function: renderDecksList] Rendering deck list. Find in <script> block.');
             const container = document.getElementById('decks-list');
             const noDecksMsg = document.getElementById('no-decks-msg');
             const decks = Object.values(localDecks);

             if (decks.length === 0) {
                 container.innerHTML = '';
                 noDecksMsg.classList.remove('hidden');
                 return;
             }
             noDecksMsg.classList.add('hidden');

             container.innerHTML = decks.map(deck => {
               const commander = deck.commander;
               const commanderImg = commander ? commander.image_uris?.art_crop : 'https://placehold.co/600x440/2d3748/e2e8f0?text=No+Commander';
               const cardCount = Object.keys(deck.cards || {}).reduce((sum, key) => sum + (deck.cards[key].count || 1), 0) + (commander ? 1 : 0);


                  return `
                       <div class="bg-gray-700/50 rounded-lg overflow-hidden shadow-lg hover:shadow-indigo-500/30 transition-shadow duration-300">
                           <div class="relative">
                               <img src="${commanderImg}" alt="${commander ? commander.name : 'Deck Art'}" class="w-full h-48 object-cover">
                               <div class="absolute inset-0 bg-gradient-to-t from-black/80 to-transparent"></div>
                               <div class="absolute bottom-0 left-0 p-4">
                                   <h3 class="text-xl font-bold">${deck.name}</h3>
                                   <p class="text-sm text-gray-300">${deck.format} - ${cardCount} cards</p>
                               </div>
                           </div>
                           <div class="p-4 flex justify-between items-center">
                               <button class="view-deck-btn bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg" data-deck-id="${deck.id}">View Deck</button>
                               <button class="delete-button bg-red-800 hover:bg-red-700 p-2 rounded-lg" data-deck-id="${deck.id}">
                                   <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                               </button>
                           </div>
                       </div>
                      `;
             }).join('');

           document.querySelectorAll('.view-deck-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const deckId = e.currentTarget.dataset.deckId;
                    showView('singleDeck');
                    renderSingleDeck(deckId);
                });
           });

             document.querySelectorAll('#decks-list .delete-button').forEach(btn => {
                 btn.addEventListener('click', (e) => {
                     const deckId = e.currentTarget.dataset.deckId;
                     openDeckDeleteOptions(deckId);
                 });
             });
        }
        
        function renderSettings() {
             console.log('[Function: renderSettings] Rendering settings view. Find in <script> block.');
             renderModalVisibilitySettings();
             const deckListContainer = document.getElementById('settings-deck-list');
             const decks = Object.values(localDecks);
             if (decks.length > 0) {
                 deckListContainer.innerHTML = decks.map(deck => `
                       <div class="flex justify-between items-center bg-gray-700 p-3 rounded-lg">
                           <span>${deck.name}</span>
                           <button class="delete-button bg-red-600 hover:bg-red-700 text-white font-bold py-1 px-3 rounded-lg" data-deck-id="${deck.id}">Delete</button>
                       </div>
                 `).join('');

                 deckListContainer.querySelectorAll('.delete-button').forEach(btn => {
                     btn.addEventListener('click', (e) => {
                         const deckId = e.currentTarget.dataset.deckId;
                         openDeckDeleteOptions(deckId);
                     });
                 });
             } else {
                 deckListContainer.innerHTML = '<p class="text-gray-500">No decks to manage.</p>';
             }
        }

        function openDeckDeleteOptions(deckId) {
            console.log(`[Function: openDeckDeleteOptions] Opening delete options for deck ${deckId}`);
            const modal = document.getElementById('deck-delete-options-modal');
      const andCardsBtn = modal.querySelector('#delete-deck-and-cards-btn');
      const onlyBtn = modal.querySelector('#delete-deck-only-btn');
      if (andCardsBtn) { andCardsBtn.dataset.deckId = deckId; andCardsBtn.dataset.id = deckId; }
      if (onlyBtn) { onlyBtn.dataset.deckId = deckId; onlyBtn.dataset.id = deckId; }
            openModal('deck-delete-options-modal');
        }

        function showView(viewName) {
            console.log(`[Function: showView] Switching to ${viewName} view. Find in <script> block.`);
            Object.keys(views).forEach(key => {
                views[key].classList.add('hidden');
            });
            views[viewName].classList.remove('hidden');

            Object.keys(navLinks).forEach(key => {
                const link = navLinks[key];
                link.classList.remove('bg-indigo-600', 'text-white');
                link.classList.add('text-gray-400', 'hover:bg-gray-700', 'hover:text-white');
            });
            
            const navLink = navLinks[viewName];
            if (navLink) {
                 navLink.classList.add('bg-indigo-600', 'text-white');
                 navLink.classList.remove('text-gray-400', 'hover:bg-gray-700', 'hover:text-white');
            }

            const pageTitle = document.getElementById('page-title');
            
            if (viewName === 'collection') {
                pageTitle.textContent = 'My Collection';
                 currentSearchContext = { mode: 'collection', deckId: null };
                renderCollection();
            } else if (viewName === 'decks') {
                pageTitle.textContent = 'Decks';
                renderDecksList();
            } else if (viewName === 'settings') {
                pageTitle.textContent = 'Settings';
                renderSettings();
            } else if (viewName === 'singleDeck') {
                // Title is set in renderSingleDeck
            }
        }
        
        function selectCommander(card) {
            console.log(`[Function: selectCommander] Commander selected: ${card.name}`);
      console.debug('[selectCommander] card object:', card);
            currentCommanderForAdd = card;
            const previewContainer = document.getElementById('selected-commander-preview');
            previewContainer.innerHTML = `
                <img src="${card.image_uris?.art_crop}" class="w-16 h-12 object-cover rounded-sm">
                <div class="flex-grow">
                    <p class="font-bold">${card.name}</p>
                    <p class="text-xs text-gray-400">${card.type_line}</p>
                </div>
                <button type="button" id="clear-selected-commander" class="p-1 text-red-400 hover:text-red-200 text-2xl font-bold">&times;</button>
            `;
            previewContainer.classList.remove('hidden');

            document.getElementById('clear-selected-commander').addEventListener('click', () => {
                currentCommanderForAdd = null;
                previewContainer.innerHTML = '';
                previewContainer.classList.add('hidden');
            });
        }

        function openDeckCreationModal(commanderCard = null) {
            // openDeckCreationModal
            const form = document.getElementById('deck-creation-form');
            form.reset();
            currentCommanderForAdd = null;
            tempAiBlueprint = null;

            document.getElementById('selected-commander-preview').innerHTML = '';
            document.getElementById('selected-commander-preview').classList.add('hidden');
            
            // Populate commander list from collection
            const commanderListContainer = document.getElementById('commander-collection-list');
            const legendaryCreatures = Object.values(localCollection).filter(c => c.type_line.includes('Legendary') && c.type_line.includes('Creature'));
            
        if (legendaryCreatures.length > 0) {
        commanderListContainer.innerHTML = legendaryCreatures.map(c => `
          <div class="flex items-center gap-2 p-1 rounded-md hover:bg-gray-700 cursor-pointer select-commander-from-collection-btn" data-firestore-id='${c.firestoreId}' tabindex="0" role="button" aria-label="Select ${c.name}">
            <div style="width:64px;height:48px;position:relative;flex-shrink:0;">
              <img src="${c.image_uris?.art_crop}" class="collection-card-img rounded-sm" style="position:absolute;inset:0;object-fit:cover;" />
            </div>
            <span class="flex-grow">${c.name}</span>
            <button type="button" class="commander-select-btn bg-indigo-600 hover:bg-indigo-700 text-white text-sm font-semibold py-1 px-2 rounded ml-2" data-firestore-id='${c.firestoreId}'>Select</button>
          </div>
        `).join('');

        // Delegated click handler - more resilient than per-item listeners
                 commanderListContainer.onclick = (e) => {
          // If the explicit select button was clicked, prefer that
          const selectBtn = e.target.closest('.commander-select-btn');
          if (selectBtn) {
            console.debug('[commanderListContainer.onclick] select-btn clicked:', selectBtn.dataset.firestoreId);
            const firestoreId = selectBtn.dataset.firestoreId;
            const card = localCollection[firestoreId];
            if (card) return selectCommander(card);
          }

          const btn = e.target.closest('.select-commander-from-collection-btn');
          console.debug('[commanderListContainer.onclick] event target:', e.target, 'closest btn:', btn);
          if (!btn) return;
          const firestoreId = btn.dataset.firestoreId;
          console.debug('[commanderListContainer.onclick] selected firestoreId:', firestoreId);
          const card = localCollection[firestoreId];
          if (card) selectCommander(card);
        };
        commanderListContainer.onkeydown = (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            const btn = e.target.closest('.select-commander-from-collection-btn');
            console.debug('[commanderListContainer.onkeydown] key event, btn:', btn);
            if (!btn) return;
            e.preventDefault();
            const firestoreId = btn.dataset.firestoreId;
            const card = localCollection[firestoreId];
            if (card) selectCommander(card);
          }
        };

            } else {
                commanderListContainer.innerHTML = '<p class="text-gray-500 text-sm p-2">No legendary creatures in your collection.</p>';
            }

            if (commanderCard) {
                selectCommander(commanderCard);
            }

            openModal('deck-creation-modal');
        }

        function handleCardSelection(card) {
            console.log(`[Function: handleCardSelection] Card selected: ${card.name} (${card.id})`);
            currentCardForAdd = card;
            closeModal('card-versions-modal');
            renderCardConfirmationModal(card);
            openModal('card-confirmation-modal');
        }

        function renderCardConfirmationModal(card) {
            const contentDiv = document.getElementById('card-confirmation-content');
            
            const cleanedCard = {
                id: card.id, name: card.name,
                image_uris: { small: card.image_uris?.small, normal: card.image_uris?.normal, art_crop: card.image_uris?.art_crop },
                mana_cost: card.mana_cost, cmc: card.cmc, type_line: card.type_line, oracle_text: card.oracle_text,
                power: card.power, toughness: card.toughness, colors: card.colors, color_identity: card.color_identity,
                keywords: card.keywords, set: card.set, set_name: card.set_name, rarity: card.rarity,
                prices: card.prices, legalities: card.legalities
            };

            contentDiv.innerHTML = `
            <div class="flex justify-center md:justify-start md:col-span-1">
              <img src="${card.image_uris?.normal}" alt="${card.name}" class="rounded-lg shadow-lg w-full max-w-[360px] h-auto max-h-[640px] object-contain">
            </div>
            <div class="space-y-4 md:col-span-1">
              <h3 class="text-3xl font-bold">${card.name}</h3>
              <form id="add-card-form">
                <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                  <div>
                    <label for="card-quantity" class="block text-sm font-medium text-gray-300">Quantity</label>
                    <input type="number" id="card-quantity" value="1" min="1" class="mt-1 w-full bg-gray-700 border border-gray-600 rounded-lg px-3 py-2">
                  </div>
                  <div>
                    <label for="card-finish" class="block text-sm font-medium text-gray-300">Finish</label>
                    <select id="card-finish" class="mt-1 w-full bg-gray-700 border border-gray-600 rounded-lg px-3 py-2">
                      <option value="nonfoil" ${!card.foil ? 'selected' : ''}>Non-Foil</option>
                      <option value="foil" ${card.foil ? 'selected' : ''}>Foil</option>
                    </select>
                  </div>
                </div>
                <div class="mt-6 flex justify-end gap-4">
                  <button type="button" id="cancel-add-card-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-lg">Cancel</button>
                  <button type="submit" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg">Add Card</button>
                </div>
              </form>
            </div>
            `;

            document.getElementById('cancel-add-card-btn').addEventListener('click', () => {
                closeModal('card-confirmation-modal');
                openModal('card-versions-modal');
            });
            
            document.getElementById('add-card-form').addEventListener('submit', async (e) => {
                e.preventDefault();
                const quantity = parseInt(document.getElementById('card-quantity').value, 10);
                const finish = document.getElementById('card-finish').value;

                // Use the globally set currentCardForAdd, not a locally scoped one
                if (!currentCardForAdd) {
                    showToast("Error: No card selected.", "error");
                    return;
                }
                
                const cardToAdd = { ...currentCardForAdd, count: quantity, finish: finish, addedAt: new Date().toISOString() };
                
                await addCardToCollection(cardToAdd);

                closeModal('card-confirmation-modal');
            });
        }
        
        async function addCardToCollection(cardData) {
            console.log(`[Function: addCardToCollection] Adding ${cardData.count}x ${cardData.name} to collection.`);
            // Find existing card based on Scryfall ID and finish, but not firestoreId
            const existingCard = Object.values(localCollection).find(c => c.id === cardData.id && c.finish === cardData.finish);
            
            try {
                if (existingCard) {
                    const newCount = (existingCard.count || 0) + cardData.count;
                    const cardRef = doc(db, `artifacts/${appId}/users/${userId}/collection`, existingCard.firestoreId);
                    await updateDoc(cardRef, { count: newCount });
                    showToast(`Updated ${cardData.name} to ${newCount} in collection.`, 'success');
                    return existingCard.firestoreId;
                } else {
                    const docRef = await addDoc(collection(db, `artifacts/${appId}/users/${userId}/collection`), cardData);
                    showToast(`Added ${cardData.count}x ${cardData.name} to collection.`, 'success');
                    return docRef.id;
                }
            } catch (error) {
                console.error("Error adding card to collection:", error);
                showToast("Failed to add card to collection.", "error");
                return null;
            }
        }
        
        async function handleAddSelectedCardsToDeck(deckId, firestoreIds) {
            if (!deckId || !firestoreIds || firestoreIds.length === 0) {
                showToast('No cards selected to add.', 'warning');
                return;
            }

            const deck = localDecks[deckId];
            if (!deck) {
                showToast('Deck not found.', 'error');
                return;
            }
            
      // Enforce commander color identity rules: all added cards must be legal
      const commanderColors = deck.commander?.color_identity || [];
      for (const firestoreId of firestoreIds) {
        const collectionCard = localCollection[firestoreId];
        if (!collectionCard) {
          showToast(`Card not found in collection: ${firestoreId}`, 'error');
          return;
        }
        if (!isColorIdentityValid(collectionCard.color_identity, commanderColors)) {
          showToast(`Card "${collectionCard.name}" is not legal with this commander (color identity mismatch).`, 'error');
          return; // Stop the whole process
        }
      }

            // Check if any selected cards are already in another deck
            for (const firestoreId of firestoreIds) {
                if(cardDeckAssignments[firestoreId] && cardDeckAssignments[firestoreId].length > 0) {
                    const assignment = cardDeckAssignments[firestoreId][0];
                    if(assignment.deckId !== deckId) {
                        showToast(`Card "${localCollection[firestoreId].name}" is already in another deck. Cards can only be in one deck at a time.`, 'error');
                        return; // Stop the whole process
                    }
                }
            }


            const batch = writeBatch(db);

            for (const firestoreId of firestoreIds) {
                const collectionCard = localCollection[firestoreId];
                if (!collectionCard || collectionCard.count < 1) {
                    console.warn(`Skipping card ${firestoreId}, not found or no copies available.`);
                    continue;
                }
                
                // Deck card ID is the firestore ID
                const deckCardId = firestoreId;
                const cardInDeck = deck.cards?.[deckCardId];

                // Logic to "move" a card
                if (!cardInDeck) {
                    const collectionCardRef = doc(db, `artifacts/${appId}/users/${userId}/collection`, firestoreId);
                    batch.update(collectionCardRef, { count: collectionCard.count - 1 });

                    const deckRef = doc(db, `artifacts/${appId}/users/${userId}/decks`, deckId);
                    const cardForDeck = {
                        count: 1,
                        name: collectionCard.name, // Storing minimal data for reference
                        type_line: collectionCard.type_line,
                    };
                    batch.update(deckRef, { [`cards.${deckCardId}`]: cardForDeck });
                } else {
                    // If it's already in the deck, just take another from the collection
                        const collectionCardRef = doc(db, `artifacts/${appId}/users/${userId}/collection`, firestoreId);
                    batch.update(collectionCardRef, { count: collectionCard.count - 1 });

                    const deckRef = doc(db, `artifacts/${appId}/users/${userId}/decks`, deckId);
                    batch.update(deckRef, { [`cards.${deckCardId}.count`]: (cardInDeck.count || 0) + 1 });
                }
            }

            try {
                await batch.commit();
                showToast(`Added ${firestoreIds.length} card(s) to ${deck.name}.`, 'success');
        // Optimistically update local state so the decklist refreshes immediately
        try {
          if (!localDecks[deckId]) localDecks[deckId] = deck;
          const localDeck = localDecks[deckId];
          localDeck.cards = localDeck.cards || {};
          firestoreIds.forEach((firestoreId) => {
            const collectionCard = localCollection[firestoreId];
            if (!collectionCard) return;

            // decrement collection count locally (min 0)
            collectionCard.count = Math.max((collectionCard.count || 0) - 1, 0);

            if (localDeck.cards[firestoreId]) {
              localDeck.cards[firestoreId].count = (localDeck.cards[firestoreId].count || 0) + 1;
            } else {
              localDeck.cards[firestoreId] = {
                count: 1,
                name: collectionCard.name,
                type_line: collectionCard.type_line,
              };
            }
          });

          // Update assignments map and re-render the single deck immediately
          updateCardAssignments();
          renderSingleDeck(deckId);
        } catch (e) {
          console.warn('Local optimistic update failed:', e);
        }
        closeModal('add-cards-to-deck-modal');
            } catch (error) {
                console.error("Error adding cards to deck:", error);
                showToast("Failed to add cards to deck.", "error");
            }
        }
        
        async function getAiDeckBlueprint(commanderCard) {
            const prompt = `You are a world-class Magic: The Gathering deck architect specializing in the Commander format. Given the following commander card, you will generate a detailed blueprint for a 100-card deck.

            Your response must be a single, valid JSON object and nothing else. Do not wrap it in markdown backticks.
            
            The JSON object must have the following keys:
            1.  "name": A creative, flavorful name for the deck.
            2.  "summary": A concise, one-paragraph summary of the deck's primary strategy and win condition.
            3.  "strategy": A more detailed explanation (2-3 paragraphs) of how to pilot the deck. Cover the early, mid, and late game. Mention key synergies and important card types to look for.
            4.  "suggestedCounts": An object detailing the ideal number of cards for each major card type. The sum of these counts must equal 99 (for the main deck, excluding the commander). The keys must be exactly: "Land", "Creature", "Instant", "Sorcery", "Artifact", "Enchantment", "Planeswalker", and "Total" (which must be 99).

            Commander Card Details:
            - Name: ${commanderCard.name}
            - Type: ${commanderCard.type_line}
            - Mana Cost: ${commanderCard.mana_cost}
            - Oracle Text: ${commanderCard.oracle_text}
            - Power/Toughness: ${commanderCard.power || 'N/A'}/${commanderCard.toughness || 'N/A'}`;

            try {
                const response = await fetch(GEMINI_API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }],
                    }),
                });

                if (!response.ok) {
                    throw new Error(`Gemini API request failed with status ${response.status}`);
                }

                const data = await response.json();
                const text = data.candidates?.[0]?.content?.parts?.[0]?.text;
                
                if (!text) {
                    throw new Error('Invalid or empty response from Gemini API');
                }
                
                // Clean potential markdown and parse
                const cleanedText = text.replace(/```json/g, '').replace(/```/g, '').trim();
                const aiResponse = JSON.parse(cleanedText);
                
                // Validate the response structure
                if (!aiResponse.name || !aiResponse.summary || !aiResponse.strategy || !aiResponse.suggestedCounts || aiResponse.suggestedCounts.Total !== 99) {
                    throw new Error("Gemini response is missing required fields or has incorrect structure.");
                }

                return aiResponse;

            } catch (error) {
                console.error("Error getting AI deck blueprint:", error);
                // Return a fallback blueprint
                return {
                    name: `Deck for ${commanderCard.name}`,
                    summary: "An error occurred while generating the AI summary. This is a placeholder.",
                    strategy: "Could not generate a detailed strategy.",
                    suggestedCounts: { "Land": 37, "Creature": 28, "Instant": 10, "Sorcery": 6, "Artifact": 10, "Enchantment": 8, "Planeswalker": 0, "Total": 99 }
                };
        // Attach per-button handlers that stopPropagation to ensure the
        // select button always triggers selection even if other layers
        // intercept the click.
        commanderListContainer.querySelectorAll('.commander-select-btn').forEach(b => {
          b.addEventListener('click', (ev) => {
            ev.stopPropagation();
            const firestoreId = b.dataset.firestoreId;
            const card = localCollection[firestoreId];
            console.debug('[commander-select-btn] clicked for', firestoreId, card);
            if (card) selectCommander(card);
          });
        });
            }
        }


        async function handleDeckCreationSubmit(e) {
            e.preventDefault();
            const deckNameInput = document.getElementById('deck-name-input');
            let deckName = deckNameInput.value.trim();
            const deckFormat = document.getElementById('deck-format-select').value;

            if (deckFormat === 'commander' && !currentCommanderForAdd) {
                showToast('Please select a commander for this deck.', 'error');
                return;
            }

            const saveButton = document.getElementById('save-deck-btn');
            const saveText = document.getElementById('save-deck-text');
            const saveSpinner = document.getElementById('save-deck-spinner');

            saveButton.disabled = true;
            saveText.textContent = 'Generating...';
            saveSpinner.classList.remove('hidden');

            try {
                if (deckFormat === 'commander') {
                    const blueprint = await getAiDeckBlueprint(currentCommanderForAdd);
                    tempAiBlueprint = blueprint; // Store for confirmation
                    
                    // Populate and open the blueprint confirmation modal
                    renderAiBlueprintModal(blueprint, deckName || blueprint.name); // Pass user-input name as potential override
                    openModal('ai-blueprint-modal');

                } else {
                   // For non-commander formats, create deck directly (or could add a simpler AI step later)
                    const newDeck = {
                        name: deckName || `New ${deckFormat} Deck`,
                        format: deckFormat,
                        summary: '',
                        commander: null,
                        cards: {},
                        createdAt: new Date().toISOString(),
                        aiBlueprint: null
                    };
                    const docRef = await addDoc(collection(db, `artifacts/${appId}/users/${userId}/decks`), newDeck);
                    showToast(`Deck "${newDeck.name}" created successfully!`, 'success');
                    closeModal('deck-creation-modal');
                    showView('singleDeck');
                    renderSingleDeck(docRef.id);
                }

            } catch (error) {
                console.error("Error during deck creation process:", error);
                showToast('Failed to generate AI deck plan.', 'error');
            } finally {
                saveButton.disabled = false;
                saveText.textContent = 'Get AI Blueprint';
                saveSpinner.classList.add('hidden');
            }
        }
        
        async function createDeckFromBlueprint() {
            // createDeckFromBlueprint
            if (!tempAiBlueprint || !currentCommanderForAdd) {
                showToast("Error: Missing blueprint or commander data.", "error");
                return;
            }

            const deckName = document.getElementById('deck-name-input').value.trim() || tempAiBlueprint.name;

            try {
                // Ensure commander exists in collection and we have its firestoreId
                const commanderFirestoreId = currentCommanderForAdd.firestoreId || await addCardToCollection({
                    ...currentCommanderForAdd,
                    count: 1,
                    finish: 'nonfoil'
                });

                if (!commanderFirestoreId) {
                    throw new Error("Failed to add commander to collection.");
                }

                // Create the final commander object to store in the deck
                const commanderForDeck = {
                    ...currentCommanderForAdd,
                    firestoreId: commanderFirestoreId
                };


                const newDeck = {
                    name: deckName,
                    format: 'commander',
                    commander: commanderForDeck,
                    cards: {}, // Start with an empty deck, user adds cards later
                    createdAt: new Date().toISOString(),
                    aiBlueprint: tempAiBlueprint
                };

                const docRef = await addDoc(collection(db, `artifacts/${appId}/users/${userId}/decks`), newDeck);

                showToast(`Deck "${deckName}" created successfully!`, 'success');
                closeModal('ai-blueprint-modal');
                closeModal('deck-creation-modal');

                // Navigate to the new deck
                showView('singleDeck');
                renderSingleDeck(docRef.id);

            } catch (error) {
                console.error("Error creating deck from blueprint:", error);
                showToast("Failed to create the new deck.", "error");
            } finally {
                // Cleanup temporary state
                tempAiBlueprint = null;
                currentCommanderForAdd = null;
            }
        }

        // --- AUTHENTICATION FUNCTIONS ---
        async function handleEmailLogin() {
            const email = document.getElementById('email').value;
            const password = document.getElementById('password').value;
            if (!email || !password) {
                showToast('Please enter both email and password.', 'error');
                return;
            }
            try {
                await signInWithEmailAndPassword(auth, email, password);
            } catch (error) {
                console.error("Error signing in:", error);
                showToast(error.message, 'error');
            }
        }

        async function handleEmailSignup() {
            const email = document.getElementById('email').value;
            const password = document.getElementById('password').value;
             if (!email || !password) {
                showToast('Please enter both email and password.', 'error');
                return;
            }
            try {
                await createUserWithEmailAndPassword(auth, email, password);
            } catch (error) {
                console.error("Error signing up:", error);
                showToast(error.message, 'error');
            }
        }

        async function handleGoogleLogin() {
            const provider = new GoogleAuthProvider();
            try {
                await signInWithPopup(auth, provider);
            } catch (error) {
                console.error("Google sign-in error:", error);
                showToast(error.message, 'error');
            }
        }

        async function searchForCard(mode, deckId = null) {
            console.log(`[Function: searchForCard] Initiating search in mode: ${mode}`);
            currentSearchContext = { mode, deckId };
            const input = document.getElementById(mode === 'commander' ? 'commander-search-input' : 'card-search-input');
            const query = input.value.trim();
            if (query.length < 3) {
                showToast("Please enter at least 3 characters to search.", "warning");
                return;
            }

            let scryfallQuery = query;
            if (mode === 'commander') {
                scryfallQuery += " t:legendary (t:creature or t:planeswalker)";
            }

            const searchButton = document.getElementById(mode === 'commander' ? 'commander-search-btn' : 'search-card-btn');
            const searchIcon = document.getElementById('search-icon');
            const searchSpinner = document.getElementById('search-spinner');
            const searchText = document.getElementById('search-text');

            searchButton.disabled = true;
            if(searchIcon) searchIcon.classList.add('hidden');
            if(searchSpinner) searchSpinner.classList.remove('hidden');
            if(searchText) searchText.textContent = 'Searching...';

            try {
                const response = await fetch(`https://api.scryfall.com/cards/search?q=${encodeURIComponent(scryfallQuery)}&unique=prints`);
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.details || 'Card not found.');
                }
                const data = await response.json();
                
                if (mode === 'commander') {
                    const resultsContainer = document.getElementById('commander-search-results');
        // Render each result as a stable grid cell with aspect-ratio
        resultsContainer.innerHTML = data.data.map(card => `
          <div class="cursor-pointer select-commander-from-search-btn rounded-md overflow-hidden" data-card-id='${card.id}' tabindex="0" role="button" aria-label="Select ${card.name}" style="aspect-ratio:2/3; position:relative">
            <img src="${card.image_uris.art_crop}" class="commander-search-img">
            <button type="button" class="commander-select-btn absolute bottom-2 right-2 bg-indigo-600 hover:bg-indigo-700 text-white text-xs font-semibold py-1 px-2 rounded" data-card-id='${card.id}'>Select</button>
          </div>
        `).join('');

        // Delegated handlers so clicks/keyboard work even when images overlay
                    resultsContainer.onclick = (e) => {
            const selectBtn = e.target.closest('.commander-select-btn');
            if (selectBtn) {
              const cardId = selectBtn.dataset.cardId || selectBtn.dataset.firestoreId;
              console.debug('[resultsContainer.onclick] select-btn clicked:', cardId);
              const card = data.data.find(c => c.id === cardId);
              if (card) return selectCommander(card);
            }

            const btn = e.target.closest('.select-commander-from-search-btn');
            console.debug('[resultsContainer.onclick] event target:', e.target, 'closest btn:', btn);
            if (!btn) return;
            const cardId = btn.dataset.cardId;
            console.debug('[resultsContainer.onclick] selected cardId:', cardId);
            const card = data.data.find(c => c.id === cardId);
            if (card) selectCommander(card);
          };
          resultsContainer.onkeydown = (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
              const btn = e.target.closest('.select-commander-from-search-btn');
              console.debug('[resultsContainer.onkeydown] key event, btn:', btn);
              if (!btn) return;
              e.preventDefault();
              const cardId = btn.dataset.cardId;
              const card = data.data.find(c => c.id === cardId);
              if (card) selectCommander(card);
            }
          };
          // Ensure per-button handlers exist for search tiles too
          resultsContainer.querySelectorAll('.commander-select-btn').forEach(b => {
            b.addEventListener('click', (ev) => {
              ev.stopPropagation();
              const cardId = b.dataset.cardId || b.dataset.firestoreId;
              console.debug('[commander-select-btn (search)] clicked for', cardId);
              const card = data.data.find(c => c.id === cardId);
              if (card) selectCommander(card);
            });
          });

                } else {
                    renderCardVersions(data.data);
                    openModal('card-versions-modal');
                }

            } catch (error) {
                console.error("Scryfall API error:", error);
                showToast(error.message, 'error');
            } finally {
                searchButton.disabled = false;
                 if(searchIcon) searchIcon.classList.remove('hidden');
                if(searchSpinner) searchSpinner.classList.add('hidden');
                if(searchText) searchText.textContent = 'Search';
            }
        }
        
        function searchForCommander() { 
            searchForCard('commander');
        }
        
        function filterCommanderCollectionList() { 
            const filterText = document.getElementById('commander-collection-filter').value.toLowerCase();
            const commanders = document.querySelectorAll('#commander-collection-list > div');
            commanders.forEach(commander => {
                const name = commander.textContent.toLowerCase();
                if (name.includes(filterText)) {
                    commander.style.display = 'flex';
                } else {
                    commander.style.display = 'none';
                }
            });
        }
        
        function handleAiChat(e) { e.preventDefault(); console.warn('handleAiChat is not implemented.'); }
        function handleRuleLookup(e) { e.preventDefault(); console.warn('handleRuleLookup is not implemented.'); }
        function handleMtgChat(e) { e.preventDefault(); console.warn('handleMtgChat is not implemented.'); }
        
        function confirmClearAllData() {
            // confirmClearAllData
            document.getElementById('confirmation-title').textContent = 'Delete Everything?';
            document.getElementById('confirmation-message').textContent = 'This will permanently delete your entire collection and all decks. This action is irreversible.';
            openModal('confirmation-modal');
            
            const confirmBtn = document.getElementById('confirm-action-btn');
            // Clone and replace to remove old event listeners
            const newConfirmBtn = confirmBtn.cloneNode(true);
            confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);

            newConfirmBtn.addEventListener('click', () => {
                closeModal('confirmation-modal');
                executeClearAllData();
            }, { once: true }); // Ensure it only runs once
        }

        async function executeClearAllData() {
            // executeClearAllData
            if (!userId) {
                showToast("User not authenticated.", "error");
                return;
            }

            showToast("Deleting all data... This may take a moment.", "warning");

            try {
                const batch = writeBatch(db);
                
                // Get and delete all collection documents
                const collectionRef = collection(db, `artifacts/${appId}/users/${userId}/collection`);
                const collectionSnapshot = await getDocs(collectionRef);
                collectionSnapshot.forEach(doc => batch.delete(doc.ref));

                // Get and delete all deck documents
                const decksRef = collection(db, `artifacts/${appId}/users/${userId}/decks`);
                const decksSnapshot = await getDocs(decksRef);
                decksSnapshot.forEach(doc => batch.delete(doc.ref));

                await batch.commit();

                showToast("All your data has been successfully deleted.", "success");
            } catch (error) {
                console.error("Error clearing all data:", error);
                showToast("An error occurred while deleting your data.", "error");
            }
        }

        function renderCollectionCard(card) {
             const price = card.prices?.usd_foil && card.finish === 'foil' ? card.prices.usd_foil : card.prices?.usd;
             const assignment = (cardDeckAssignments[card.firestoreId] || [])[0];
             return `
       <div class="relative group rounded-lg overflow-hidden shadow-lg transition-transform transform hover:-translate-y-1 hover:shadow-indigo-500/40 collection-card-item" style="aspect-ratio:2/3">
         <div class="card-image-container">
           <img src="${card.image_uris?.normal}" alt="${card.name}" class="collection-card-img" loading="lazy">
         </div>
                       <div class="absolute top-1 right-1 bg-gray-900/80 text-white text-sm font-bold px-2 py-1 rounded-full">${card.count || 1}</div>
                         <div class="absolute bottom-0 left-0 right-0 p-2 bg-gradient-to-t from-black/90 to-transparent">
                             <p class="text-white text-xs font-bold truncate">${card.name}</p>
                             ${assignment ? `<p class="text-indigo-400 text-xs font-semibold truncate">${assignment.deckName}</p>` : (price ? `<p class="text-green-400 text-xs font-semibold">$${price}</p>` : '')}
                         </div>
                       <div class="absolute inset-0 bg-black/60 opacity-0 group-hover:opacity-100 transition-opacity flex flex-col items-center justify-center gap-2 p-2">
                           <button class="view-card-details-btn bg-white/20 backdrop-blur-sm text-white text-xs font-bold py-2 px-3 rounded-lg w-full" data-firestore-id="${card.firestoreId}">View</button>
                           <button class="delete-button bg-red-600/50 hover:bg-red-600 backdrop-blur-sm text-white text-xs font-bold py-2 px-3 rounded-lg w-full" data-firestore-id="${card.firestoreId}">Delete</button>
                       </div>
                   </div>
                  `;
        }

        function addCollectionCardListeners() {
             document.querySelectorAll('#collection-content .view-card-details-btn').forEach(btn => {
                 btn.addEventListener('click', (e) => {
                     const firestoreId = e.currentTarget.dataset.firestoreId;
                     const card = localCollection[firestoreId];
                     if (card) {
                         renderCardDetailsModal(card);
                         openModal('card-details-modal');
                     }
                 });
             });
             document.querySelectorAll('#collection-content .delete-button').forEach(btn => {
                 btn.addEventListener('click', async (e) => {
                     const firestoreId = e.currentTarget.dataset.firestoreId;
                     if (firestoreId) {
                       await deleteDoc(doc(db, `artifacts/${appId}/users/${userId}/collection`, firestoreId));
                       showToast('Card removed from collection.', 'success');
                     }
                 });
             });
             document.querySelectorAll('#collection-content .create-deck-from-commander-btn').forEach(btn => {
                 btn.addEventListener('click', (e) => {
                     const firestoreId = e.currentTarget.dataset.firestoreId;
                     const card = localCollection[firestoreId];
                     if (card) {
                         openDeckCreationModal(card);
                     }
                 });
             });
        }
        
        function addCollectionTableListeners() { 
            addCollectionCardListeners(); // Re-use the same logic for buttons
            
            const table = document.querySelector('#collection-content table');
            if(!table) return;
      table.querySelectorAll('thead th.sortable').forEach(th => {
         th.addEventListener('click', () => {
           if(document.body.classList.contains('edit-mode')) return;

           const column = th.dataset.sort;
           table.querySelectorAll('thead th.sortable').forEach(otherTh => {
             if (otherTh !== th) otherTh.classList.remove('sort-asc', 'sort-desc');
           });

           if (collectionSortState.column === column) {
             collectionSortState.direction = collectionSortState.direction === 'asc' ? 'desc' : 'asc';
           } else {
             collectionSortState.column = column;
             collectionSortState.direction = 'asc';
           }
                     
           th.classList.remove('sort-asc', 'sort-desc');
           th.classList.add(collectionSortState.direction === 'asc' ? 'sort-asc' : 'sort-desc');

           // When grouped, sorting should be applied within each group. renderPaginatedCollection handles this.
           renderPaginatedCollection();
         });
      });

      // Make group <details> summaries keyboard accessible (toggle on Enter/Space)
      table.querySelectorAll('details summary').forEach(summary => {
        summary.tabIndex = 0;
        summary.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            const details = summary.parentElement;
            details.open = !details.open;
          }
        });
      });
        }
        
        function renderDecklist(deckId) {
            const container = document.getElementById('decklist-container');
            if (!container) return;

            const deck = localDecks[deckId];
            if (!deck) return;
            
            const allCards = Object.keys(deck.cards || {}).map(firestoreId => {
                const cardData = localCollection[firestoreId];
                if (!cardData) return null;
                return { ...cardData, countInDeck: deck.cards[firestoreId].count };
            }).filter(Boolean);

            const groupedCards = allCards.reduce((acc, card) => {
                const mainType = card.type_line.split(" — ")[0];
                (acc[mainType] = acc[mainType] || []).push(card);
                return acc;
            }, {});

            const typeOrder = ['Creature', 'Planeswalker', 'Instant', 'Sorcery', 'Artifact', 'Enchantment', 'Land'];
            
            let html = '';

            // Commander is handled separately in the main layout
            
            typeOrder.forEach(type => {
                if (groupedCards[type]) {
                    const cardsOfType = groupedCards[type].sort((a,b) => a.name.localeCompare(b.name));
                    const count = cardsOfType.reduce((sum, card) => sum + card.countInDeck, 0);
                    html += `<div>
                        <h4 class="text-lg font-semibold text-indigo-400 mb-2">${type} (${count})</h4>
                        ${cardsOfType.map(card => `
                            <div class="flex items-center justify-between p-2 rounded-lg hover:bg-gray-700/50">
                                <span>${card.countInDeck} ${card.name}</span>
                                <div class="flex items-center gap-2">
                                     <button class="view-card-details-btn p-1 text-gray-400 hover:text-white" data-firestore-id="${card.firestoreId}"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg></button>
                                     <button class="delete-button remove-card-from-deck-btn p-1 text-red-400 hover:text-red-300" data-firestore-id="${card.firestoreId}" data-deck-id="${deckId}"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg></button>
                                </div>
                            </div>
                        `).join('')}
                    </div>`;
                }
            });

            container.innerHTML = html || '<p class="text-gray-500">This deck is empty. Click "Add Cards" to get started.</p>';
            
            // Attach listeners for newly rendered buttons
            container.querySelectorAll('.view-card-details-btn').forEach(btn => btn.addEventListener('click', (e) => {
                const firestoreId = e.currentTarget.dataset.firestoreId;
                const card = localCollection[firestoreId];
                if (card) {
                    renderCardDetailsModal(card);
                    openModal('card-details-modal');
                }
            }));

            container.querySelectorAll('.remove-card-from-deck-btn').forEach(btn => btn.addEventListener('click', async (e) => {
                const firestoreId = e.currentTarget.dataset.firestoreId;
                const deckId = e.currentTarget.dataset.deckId;
                const deck = localDecks[deckId];
                const cardInDeck = deck.cards[firestoreId];
                const deckRef = doc(db, `artifacts/${appId}/users/${userId}/decks`, deckId);
                const collectionCardRef = doc(db, `artifacts/${appId}/users/${userId}/collection`, firestoreId);
                
                try {
                    await runTransaction(db, async (transaction) => {
                        const collectionCardDoc = await transaction.get(collectionCardRef);
                        const currentCollectionCount = collectionCardDoc.exists() ? collectionCardDoc.data().count : 0;
                        
                        transaction.update(collectionCardRef, { count: currentCollectionCount + 1 });

                        if (cardInDeck.count > 1) {
                            transaction.update(deckRef, {
                                [`cards.${firestoreId}.count`]: cardInDeck.count - 1
                            });
                        } else {
                            transaction.update(deckRef, {
                                [`cards.${firestoreId}`]: deleteField()
                            });
                        }
                    });
                    showToast(`Removed 1 copy of ${cardInDeck.name} from deck.`, 'success');
                } catch (error) {
                    console.error("Error removing card from deck:", error);
                    showToast('Failed to remove card from deck.', 'error');
                }
            }));
        }

        function renderManaCurveChart(manaCurveData) {
            const ctx = document.getElementById('mana-curve-chart')?.getContext('2d');
            if (!ctx) return;

            const chartId = 'mana-curve-chart';
            if (deckChartInstances[chartId]) {
                deckChartInstances[chartId].destroy();
            }

            const labels = ['0', '1', '2', '3', '4', '5', '6', '7+'];
            const data = labels.map((label, index) => {
                const cmc = parseInt(label);
                if (index < 7) {
                    return manaCurveData[cmc] || 0;
                } else {
                    let sum = 0;
                    for (let key in manaCurveData) {
                        if (parseInt(key) >= 7) {
                            sum += manaCurveData[key];
                        }
                    }
                    return sum;
                }
            });

            deckChartInstances[chartId] = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Card Count',
                        data: data,
                        backgroundColor: 'rgba(79, 70, 229, 0.6)',
                        borderColor: 'rgba(129, 140, 248, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: { legend: { display: false } },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: { color: '#9CA3AF', stepSize: 2 },
                            grid: { color: '#4B5563' }
                        },
                        x: {
                            ticks: { color: '#9CA3AF' },
                            grid: { display: false }
                        }
                    }
                }
            });
        }

        function addSingleDeckListeners(deckId) {
            document.getElementById('add-cards-to-deck-btn')?.addEventListener('click', () => {
                openAddCardsToDeckModal(deckId);
            });

            document.querySelector('#single-deck-view .view-card-details-btn')?.addEventListener('click', (e) => {
                const firestoreId = e.currentTarget.dataset.firestoreId;
                const card = localCollection[firestoreId];
                if (card) {
                     renderCardDetailsModal(card);
                     openModal('card-details-modal');
                }
            });

            document.getElementById('deck-delete-btn')?.addEventListener('click', (e) => {
                openDeckDeleteOptions(e.currentTarget.dataset.deckId);
            });
            
            document.getElementById('ai-suggestions-btn')?.addEventListener('click', () => {
                showToast('AI suggestions are coming soon!', 'info');
            });
             document.getElementById('export-deck-btn')?.addEventListener('click', (e) => {
                 exportDeck(e.currentTarget.dataset.deckId);
             });
             document.getElementById('view-strategy-btn')?.addEventListener('click', () => {
                 const deck = localDecks[deckId];
                 if(deck && deck.aiBlueprint) {
                     renderAiBlueprintModal(deck.aiBlueprint, deck.name, true); // true for read-only mode
                     openModal('ai-blueprint-modal');
                 }
             });
        }

        function renderCardVersions(cards) {
            const grid = document.getElementById('card-versions-grid');
            const loading = document.getElementById('versions-loading');
            grid.innerHTML = ''; // Clear previous results
            grid.onclick = null; // Clear old listener
            loading.classList.remove('hidden');

            grid.innerHTML = cards.map(card => {
                const price = card.prices?.usd ? `$${card.prices.usd}` : (card.prices?.usd_foil ? `$${card.prices.usd_foil} (Foil)`: 'N/A');
                return `
                <div class="relative group rounded-lg overflow-hidden cursor-pointer card-version-item" data-card-id="${card.id}" style="aspect-ratio:2/3">
                    <img src="${card.image_uris?.large}" alt="${card.name}" class="card-version-img">
                    <div class="absolute inset-0 bg-black/70 opacity-0 group-hover:opacity-100 transition-opacity flex flex-col justify-end p-3 text-white">
                    <p class="font-bold">${card.set_name}</p>
                    <p class="text-sm">${price}</p>
                    </div>
                </div>
                `;
            }).join('');
            
            // Add hover preview logic
            const hoverPreview = document.getElementById('card-hover-preview');
            const hoverImage = hoverPreview.querySelector('img');

            grid.querySelectorAll('.card-version-item').forEach(item => {
                item.addEventListener('mouseenter', (e) => {
                    const imgSrc = e.currentTarget.querySelector('img').src;
                    if (imgSrc) {
                        hoverImage.src = imgSrc;
                        hoverPreview.classList.remove('hidden');
                    }
                });
                item.addEventListener('mouseleave', () => {
                    hoverPreview.classList.add('hidden');
                    hoverImage.src = '';
                });
            });

            // Event delegation for clicks on the grid
            grid.onclick = function(event) {
                const cardItem = event.target.closest('.card-version-item');
                if (!cardItem) return;
                
                const cardId = cardItem.dataset.cardId;
                const selectedCard = cards.find(c => c.id === cardId);
                if (selectedCard) {
                    handleCardSelection(selectedCard);
                }
            };
            
            loading.classList.add('hidden');
        }

        // --- UI EVENT LISTENERS ---

        function setupGlobalListeners() {
          console.log(
            "[Function: setupGlobalListeners] Setting up global UI listeners. Find in <script> block."
          );

          // Navigation
          Object.keys(navLinks).forEach((key) => {
            navLinks[key].addEventListener("click", () => {
              if (key === "ruleLookup") {
                openModal("rule-lookup-modal");
              } else if (key === "generalChat") {
                openModal("mtg-chat-modal");
              } else {
                showView(key);
              }
            });
          });

          // Header Buttons
          document
            .getElementById("edit-mode-toggle")
            .addEventListener("click", toggleEditMode);
          document
            .getElementById("new-player-guide-btn")
            .addEventListener("click", () =>
              openModal("new-player-guide-modal")
            );

          // Collection Search & Filters
          document
            .getElementById("search-card-btn")
            .addEventListener("click", () => searchForCard("collection"));
          document
            .getElementById("card-search-input")
            .addEventListener("keyup", (e) => {
              if (e.key === "Enter") searchForCard("collection");
            });

          document
            .getElementById("filter-text")
            .addEventListener("input", () => {
              collectionCurrentPage = 1;
              renderPaginatedCollection();
            });
          document
            .getElementById("collection-group-by-1")
            .addEventListener("change", () => {
              collectionCurrentPage = 1;
              renderPaginatedCollection();
            });
          document
            .getElementById("collection-group-by-2")
            .addEventListener("change", () => {
              collectionCurrentPage = 1;
              renderPaginatedCollection();
            });
          document
            .getElementById("hide-in-deck-checkbox")
            .addEventListener("change", () => {
              collectionCurrentPage = 1;
              renderPaginatedCollection();
            });

          document.querySelectorAll(".grid-size-btn").forEach((btn) => {
            btn.addEventListener("click", () => {
              document
                .querySelectorAll(".grid-size-btn")
                .forEach((b) =>
                  b.classList.remove("bg-indigo-600", "text-white")
                );
              btn.classList.add("bg-indigo-600", "text-white");
              collectionGridSize = btn.dataset.size;
              if (collectionViewMode === "grid") renderPaginatedCollection();
            });
          });

          document.querySelectorAll(".view-toggle").forEach((btn) => {
            btn.addEventListener("click", () => {
              if (btn.id === "view-toggle-grid") {
                collectionViewMode = "grid";
                document
                  .getElementById("view-toggle-table")
                  .classList.remove("bg-indigo-600", "text-white");
                btn.classList.add("bg-indigo-600", "text-white");
              } else {
                collectionViewMode = "table";
                document
                  .getElementById("view-toggle-grid")
                  .classList.remove("bg-indigo-600", "text-white");
                btn.classList.add("bg-indigo-600", "text-white");
              }
              renderPaginatedCollection();
            });
          });

          // Advanced View Builder UI wiring
          document.getElementById('open-view-builder-btn')?.addEventListener('click', () => {
            const panel = document.getElementById('view-builder-panel');
            panel.classList.toggle('hidden');
            document.getElementById('save-view-btn').classList.toggle('hidden');
            renderViewBuilderLists();
          });

          document.getElementById('add-filter-rule-btn')?.addEventListener('click', () => {
            const col = document.getElementById('filter-column-select').value;
            const op = document.getElementById('filter-op-select').value;
            const val = document.getElementById('filter-value-input').value.trim();
            if (!val) return;
            viewFilterRules.push({ column: col, operator: op, value: val });
            document.getElementById('filter-value-input').value = '';
            renderViewBuilderLists();
          });

          document.getElementById('add-sort-rule-btn')?.addEventListener('click', () => {
            const col = document.getElementById('sort-column-select').value;
            const dir = document.getElementById('sort-dir-select').value;
            viewSortRules.push({ column: col, direction: dir });
            renderViewBuilderLists();
          });

          document.getElementById('save-view-confirm-btn')?.addEventListener('click', async () => {
            const name = document.getElementById('view-name-input').value.trim();
            if (!name) { showToast('Please provide a name for the view.', 'warning'); return; }
            const view = {
              id: activeViewId || null,
              name,
              filters: JSON.parse(JSON.stringify(viewFilterRules)),
              sorts: JSON.parse(JSON.stringify(viewSortRules)),
              groupBy: [document.getElementById('view-group-by-1').value, document.getElementById('view-group-by-2').value].filter(Boolean),
              hideInDecks: !!document.getElementById('view-hide-in-deck').checked,
              viewMode: document.getElementById('view-view-mode')?.value || collectionViewMode,
              gridSize: document.getElementById('view-grid-size')?.value || collectionGridSize,
              isDefault: !!document.getElementById('view-default-checkbox')?.checked
            };
            await saveViewToFirestore(view);
            document.getElementById('view-builder-panel').classList.add('hidden');
            renderCollection();
          });

          document.getElementById('cancel-view-builder-btn')?.addEventListener('click', () => {
            document.getElementById('view-builder-panel').classList.add('hidden');
          });

          document.getElementById('saved-views-select')?.addEventListener('change', (e) => {
            const select = e.target;
            const viewId = select.value || null;
            // Small inline status next to the select
            let status = document.getElementById('saved-views-status');
            if (!status) {
              status = document.createElement('span');
              status.id = 'saved-views-status';
              status.className = 'text-sm text-gray-400 ml-2';
              select.parentElement.appendChild(status);
            }
            try {
              status.textContent = 'Applying...';
              select.disabled = true;
              // Close builder panel if open to make change visible immediately
              const panel = document.getElementById('view-builder-panel');
              if (panel) panel.classList.add('hidden');
              // Apply the view (this updates UI controls and triggers a re-render)
              setActiveViewById(viewId);
              // Quick success feedback
              showToast('View applied', 'success');
            } catch (err) {
              console.error('Error applying view:', err);
              showToast('Failed to apply view', 'error');
            } finally {
              select.disabled = false;
              // remove status after a short delay for visibility
              setTimeout(() => { if (status) status.textContent = ''; }, 700);
            }
          });

          document.getElementById('manage-views-btn')?.addEventListener('click', () => {
            // Simple manage: open panel and show list; user can delete from there in future enhancements
            document.getElementById('view-builder-panel').classList.remove('hidden');
            renderViewBuilderLists();
          });

          // Save default views loaded from Firestore after login
          loadSavedViewsFromFirestore();

          document
            .getElementById("reset-filters-btn")
            .addEventListener("click", () => {
              console.log("[Event: Click] Reset filters button clicked.");
              document.getElementById("filter-text").value = "";
              document.getElementById("collection-group-by-1").value = "";
              document.getElementById("collection-group-by-2").value = "";
              document.getElementById("hide-in-deck-checkbox").checked = false;
              collectionCurrentPage = 1;
              renderPaginatedCollection();
            });

          // Modals
          document.querySelectorAll(".modal-backdrop").forEach((modal) => {
            modal.addEventListener("click", (e) => {
              if (e.target === modal) {
                closeModal(modal.id);
              }
            });
          });
          document
            .getElementById("close-versions-modal-btn")
            .addEventListener("click", () =>
              closeModal("card-versions-modal")
            );
          document
            .getElementById("close-card-details-btn")
            .addEventListener("click", () => closeModal("card-details-modal"));
          document
            .getElementById("edit-card-details-btn")
            .addEventListener("click", toggleCardDetailsEditMode);

          // Add Cards to Deck Modal Listeners
            document.getElementById('close-add-cards-modal-btn').addEventListener('click', () => closeModal('add-cards-to-deck-modal'));
            document.getElementById('cancel-add-cards-to-deck-btn').addEventListener('click', () => closeModal('add-cards-to-deck-modal'));

          // Deck Creation
          document
            .getElementById("create-deck-btn")
            .addEventListener("click", () => openDeckCreationModal());
          document
            .getElementById("deck-creation-form")
            .addEventListener("submit", handleDeckCreationSubmit);
          document
            .getElementById("cancel-deck-btn")
            .addEventListener("click", () => closeModal("deck-creation-modal"));
          document
            .getElementById("deck-format-select")
            .addEventListener("change", (e) => {
              const container = document.getElementById(
                "commander-selection-container"
              );
              if (e.target.value === "commander") {
                container.classList.remove("hidden");
              } else {
                container.classList.add("hidden");
              }
            });

          document
            .querySelectorAll(".commander-source-btn")
            .forEach((btn) => {
              btn.addEventListener("click", (e) => {
                document
                  .querySelectorAll(".commander-source-btn")
                  .forEach((b) => {
                    b.classList.remove("border-indigo-500", "text-white");
                    b.classList.add("border-transparent", "text-gray-400");
                  });
                e.currentTarget.classList.add("border-indigo-500", "text-white");
                e.currentTarget.classList.remove(
                  "border-transparent",
                  "text-gray-400"
                );

                if (e.currentTarget.id === "commander-source-collection-btn") {
                  document
                    .getElementById("commander-from-collection")
                    .classList.remove("hidden");
                  document
                    .getElementById("commander-from-search")
                    .classList.add("hidden");
                } else {
                  document
                    .getElementById("commander-from-collection")
                    .classList.add("hidden");
                  document
                    .getElementById("commander-from-search")
                    .classList.remove("hidden");
                }
              });
            });

          document
            .getElementById("commander-search-btn")
            .addEventListener("click", searchForCommander);
          document
            .getElementById("commander-search-input")
            .addEventListener("keyup", (e) => {
              if (e.key === "Enter") searchForCommander();
            });
          document
            .getElementById("commander-collection-filter")
            .addEventListener("input", filterCommanderCollectionList);

          // AI Blueprint Modal
          document
            .getElementById("close-blueprint-modal-btn")
            .addEventListener("click", () => closeModal("ai-blueprint-modal"));
          document
            .getElementById("cancel-blueprint-btn")
            .addEventListener("click", () => closeModal("ai-blueprint-modal"));
          document
            .getElementById("confirm-blueprint-btn")
            .addEventListener("click", createDeckFromBlueprint);

          // AI Chat Modals
          document
            .getElementById("close-ai-modal-btn")
            .addEventListener("click", () => closeModal("ai-suggestions-modal"));
          document
            .getElementById("ai-chat-form")
            .addEventListener("submit", handleAiChat);
          document
            .getElementById("close-rule-lookup-modal-btn")
            .addEventListener("click", () => closeModal("rule-lookup-modal"));
          document
            .getElementById("rule-lookup-form")
            .addEventListener("submit", handleRuleLookup);
          document
            .getElementById("close-mtg-chat-modal-btn")
            .addEventListener("click", () => closeModal("mtg-chat-modal"));
          document
            .getElementById("mtg-chat-form")
            .addEventListener("submit", handleMtgChat);
          document
            .getElementById("close-new-player-guide-modal-btn")
            .addEventListener("click", () =>
              closeModal("new-player-guide-modal")
            );

          // Confirmation Modals
          document
            .getElementById("cancel-action-btn")
            .addEventListener("click", () => closeModal("confirmation-modal"));
          document
            .getElementById("notification-close-btn")
            .addEventListener("click", () => closeModal("notification-modal"));

          document
            .getElementById("cancel-delete-deck-btn")
            .addEventListener("click", () =>
              closeModal("deck-delete-options-modal")
            );
          
          document.getElementById('delete-deck-only-btn').addEventListener('click', (e) => deleteDeck(e.currentTarget.dataset.deckId, false));
          document.getElementById('delete-deck-and-cards-btn').addEventListener('click', (e) => deleteDeck(e.currentTarget.dataset.deckId, true));

          // Settings & Data Management
          document
            .getElementById("logout-btn")
            .addEventListener("click", () => {
              signOut(auth);
              location.reload();
            });
          document
            .getElementById("clear-data-btn")
            .addEventListener("click", confirmClearAllData);
          document.getElementById('export-all-data-btn').addEventListener('click', exportAllData);
          document.getElementById('import-all-data-input').addEventListener('change', handleImportAllData);
          document.getElementById('import-deck-data-input').addEventListener('change', handleImportDeckData);

          // Data Import Modal
          document.getElementById('cancel-import-btn').addEventListener('click', () => closeModal('data-import-options-modal'));
          document.getElementById('import-merge-btn').addEventListener('click', () => processDataImport(false)); // false = merge
          document.getElementById('import-replace-btn').addEventListener('click', () => processDataImport(true)); // true = replace


          // Login
          document
            .getElementById("email-login-btn")
            .addEventListener("click", handleEmailLogin);
          document
            .getElementById("signup-btn")
            .addEventListener("click", handleEmailSignup);
          document
            .getElementById("login-with-google-btn")
            .addEventListener("click", handleGoogleLogin);
        }
        
        /**
         * Checks if a card's color identity is a subset of the commander's color identity.
         * @param {string[]} cardColors - Array of color letters for the card (e.g., ['G', 'W']).
         * @param {string[]} commanderColors - Array of color letters for the commander.
         * @returns {boolean} - True if the card is legal in the deck.
         */
        function isColorIdentityValid(cardColors, commanderColors) {
            if (!cardColors || cardColors.length === 0) {
                return true; // Colorless cards are always valid
            }
            const commanderColorSet = new Set(commanderColors);
            return cardColors.every(color => commanderColorSet.has(color));
        }
        
        // --- ADD CARDS TO DECK MODAL LOGIC ---
        function openAddCardsToDeckModal(deckId) {
            const deck = localDecks[deckId];
            if (!deck) {
                showToast('Could not find the specified deck.', 'error');
                return;
            }

            document.getElementById('add-cards-modal-title').textContent = `Add Cards to "${deck.name}"`;
            
            const commanderColors = deck.commander?.color_identity || ['W', 'U', 'B', 'R', 'G']; // Allow all colors if no commander
            const tableBody = document.getElementById('add-cards-modal-table-body');
            const filterInput = document.getElementById('add-card-modal-filter');
            filterInput.value = '';

            const renderTable = () => {
                const filterText = filterInput.value.toLowerCase();
                const eligibleCards = Object.values(localCollection)
                    .filter(card => card.count > 0 && isColorIdentityValid(card.color_identity, commanderColors))
                    .filter(card => card.name.toLowerCase().includes(filterText))
                    .sort((a, b) => a.name.localeCompare(b.name));

                if (eligibleCards.length === 0) {
                    tableBody.innerHTML = `<tr><td colspan="4" class="text-center p-4 text-gray-500">No eligible cards in your collection.</td></tr>`;
                } else {
                    tableBody.innerHTML = eligibleCards.map(card => `
                        <tr class="border-b border-gray-700 hover:bg-gray-700/50">
                            <td class="p-4">
                                <div class="flex items-center">
                                    <input id="checkbox-${card.firestoreId}" type="checkbox" data-firestore-id="${card.firestoreId}" class="add-card-checkbox w-4 h-4 text-blue-600 bg-gray-700 border-gray-600 rounded focus:ring-blue-600 ring-offset-gray-800 focus:ring-2">
                                    <label for="checkbox-${card.firestoreId}" class="sr-only">checkbox</label>
                                </div>
                            </td>
                            <td class="px-6 py-4 font-medium whitespace-nowrap">${card.name}</td>
                            <td class="px-6 py-4">${card.type_line.split(' — ')[0]}</td>
                            <td class="px-6 py-4 text-center">${card.count}</td>
                        </tr>
                    `).join('');
                }
                updateSelectedCount();
            };

            const updateSelectedCount = () => {
                const selectedCount = document.querySelectorAll('.add-card-checkbox:checked').length;
                document.getElementById('add-cards-selected-count').textContent = `${selectedCount} card(s) selected`;
            };

            // Initial render
            renderTable();

            // Event Listeners
            filterInput.addEventListener('input', renderTable);
            tableBody.addEventListener('change', updateSelectedCount);

            document.getElementById('add-cards-select-all').addEventListener('change', (e) => {
                document.querySelectorAll('.add-card-checkbox').forEach(checkbox => {
                    checkbox.checked = e.target.checked;
                });
                updateSelectedCount();
            });

            document.getElementById('confirm-add-cards-to-deck-btn').onclick = () => {
                const selectedIds = Array.from(document.querySelectorAll('.add-card-checkbox:checked')).map(cb => cb.dataset.firestoreId);
                handleAddSelectedCardsToDeck(deckId, selectedIds);
            };

            openModal('add-cards-to-deck-modal');
        }

        // --- DECK DELETION LOGIC ---
    async function deleteDeck(deckId, alsoDeleteCards) {
      // Be defensive: if deckId is not provided, attempt to read it from
      // the modal buttons or the currently viewed single deck.
      if (!deckId) {
        try {
          const modal = document.getElementById('deck-delete-options-modal');
          if (modal) {
            const btn = modal.querySelector('#delete-deck-only-btn') || modal.querySelector('#delete-deck-and-cards-btn');
            deckId = btn && (btn.dataset.deckId || btn.dataset.id) ? (btn.dataset.deckId || btn.dataset.id) : deckId;
          }
        } catch (e) {
          console.warn('[deleteDeck] Error while reading deckId from modal:', e);
        }
        if (!deckId && views && views.singleDeck) {
          deckId = views.singleDeck.dataset.deckId;
        }
      }

      console.log(`[Function: deleteDeck] Deleting deck ${deckId}. Also delete cards: ${alsoDeleteCards}`);

      const deck = localDecks[deckId];
      if (!deck) {
        console.warn('[deleteDeck] localDecks keys:', Object.keys(localDecks || {}));
        showToast("Deck not found.", "error");
        return;
      }

            try {
                const batch = writeBatch(db);

                // 1. Delete the deck document
                const deckRef = doc(db, `artifacts/${appId}/users/${userId}/decks`, deckId);
                batch.delete(deckRef);

                // 2. (Optional) Delete associated cards from the collection
                if (alsoDeleteCards) {
                    const cardIdsToDelete = new Set(Object.keys(deck.cards || {}));
                    if (deck.commander && deck.commander.firestoreId) {
                        cardIdsToDelete.add(deck.commander.firestoreId);
                    }

                    cardIdsToDelete.forEach(firestoreId => {
                        const cardRef = doc(db, `artifacts/${appId}/users/${userId}/collection`, firestoreId);
                        batch.delete(cardRef);
                    });
                }
                
                await batch.commit();

                showToast(`Deck "${deck.name}" deleted successfully.`, "success");

                // If we were viewing the deleted deck, go back to the list
                const activeDeckId = views.singleDeck.dataset.deckId;
                if(activeDeckId === deckId) {
                    showView('decks');
                }
                
                closeModal('deck-delete-options-modal');
            } catch(error) {
                console.error("Error deleting deck:", error);
                showToast("Failed to delete deck.", "error");
            }
        }
        
        // --- DATA EXPORT/IMPORT LOGIC ---
        function exportAllData() {
            try {
                const dataToExport = {
                    collection: localCollection,
                    decks: localDecks,
                    exportedAt: new Date().toISOString()
                };
                const dataStr = JSON.stringify(dataToExport, null, 2);
                const blob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `mtg_forge_backup_${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showToast("Full data exported successfully!", "success");
            } catch (error) {
                console.error("Error exporting data:", error);
                showToast("Failed to export data.", "error");
            }
        }

        function exportDeck(deckId) {
             const deck = localDecks[deckId];
             if (!deck) {
                 showToast('Deck not found for export.', 'error');
                 return;
             }
             
             let decklist = '';
             if (deck.commander) {
                 decklist += `1 ${deck.commander.name} # Commander\n`;
             }
             
             // Create a combined list of cards including the commander for sorting
             let allCardsForList = [];
             if (deck.commander && deck.commander.firestoreId) {
                allCardsForList.push({ name: deck.commander.name, count: 1 });
             }
             Object.keys(deck.cards || {}).forEach(firestoreId => {
                 const cardData = localCollection[firestoreId];
                 if(cardData) {
                    allCardsForList.push({ name: cardData.name, count: deck.cards[firestoreId].count });
                 }
             });

             // We can export the full deck object as a JSON file too
             const deckDataToExport = {
                 deckInfo: {
                     name: deck.name,
                     format: deck.format,
                     commander: deck.commander ? { scryfall_id: deck.commander.id, name: deck.commander.name } : null
                 },
                 cards: allCardsForList
             };

           const dataStr = JSON.stringify(deckDataToExport, null, 2);
           const blob = new Blob([dataStr], { type: 'application/json' });
           const url = URL.createObjectURL(blob);
           const a = document.createElement('a');
           a.href = url;
           a.download = `${deck.name.replace(/\s/g, '_')}.json`;
           document.body.appendChild(a);
           a.click();
           document.body.removeChild(a);
           URL.revokeObjectURL(url);
           showToast(`Exported ${deck.name} as a JSON file!`, 'success');
        }

        function handleImportDeckData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async (e) => {
                const content = e.target.result;
                try {
                    const deckData = JSON.parse(content);
                    // We now have the structured deck data, let's process it
                    await processDeckImport(deckData);
                } catch(error) {
                    console.error("Error parsing deck file:", error);
                    showToast("Could not parse file. Please ensure it's a valid deck JSON export.", "error");
                }
            };
            reader.readAsText(file);
            event.target.value = ''; // Reset input
        }

        async function processDeckImport(deckData) {
            // ... implementation to create a new deck from the JSON data
            showToast(`Importing deck "${deckData.deckInfo.name}"... This may take a moment.`, "info");
            
            const cardsToFetch = deckData.cards;
            const batch = writeBatch(db);

            for (const card of cardsToFetch) {
                // For simplicity, we'll assume we need to add these cards to the collection.
                // A more advanced version would check if they exist first.
                const response = await fetch(`https://api.scryfall.com/cards/named?exact=${encodeURIComponent(card.name)}`);
                if(response.ok) {
                    const scryfallCard = await response.json();
                    const cardToAdd = { ...scryfallCard, count: card.count, finish: 'nonfoil', addedAt: new Date().toISOString() };
                    
                    const existing = Object.values(localCollection).find(c => c.id === scryfallCard.id && c.finish === 'nonfoil');
                    if (existing) {
                        const newCount = existing.count + card.count;
                        batch.update(doc(db, `artifacts/${appId}/users/${userId}/collection`, existing.firestoreId), { count: newCount });
                    } else {
                        batch.set(doc(collection(db, `artifacts/${appId}/users/${userId}/collection`)), cardToAdd);
                    }
                }
            }
            await batch.commit();
            showToast("Deck cards added to collection. Creating deck entry...", "success");

            // Now create the deck itself (this part is simplified)
            const newDeck = {
                name: deckData.deckInfo.name,
                format: deckData.deckInfo.format,
                cards: {}, // This would need to be populated by finding the new firestoreIds
                // ... etc
            };
            // ... more logic needed here to map imported cards to firestoreIds and build the deck.cards object.
            // This is a complex step omitted for brevity but would be required for a full implementation.

            showToast("Deck import is complex and this is a simplified version.", "warning");
        }


        function handleImportAllData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    if (!data.collection || !data.decks) {
                        throw new Error("Invalid backup file structure.");
                    }
                    tempImportedData = data;
                    openModal('data-import-options-modal');
                } catch(error) {
                    console.error("Error parsing backup file:", error);
                    showToast("Could not parse file. It may be corrupted or not a valid backup.", "error");
                }
            };
            reader.readAsText(file);
            event.target.value = ''; // Reset the input
        }
        
        async function processDataImport(replace) {
            closeModal('data-import-options-modal');
            if (!tempImportedData) {
                showToast("Import data not found.", "error");
                return;
            }

            if (replace) {
                document.getElementById('confirmation-title').textContent = "Replace All Data?";
                document.getElementById('confirmation-message').textContent = "This will permanently delete all your current decks and collection. This action cannot be undone.";
                openModal('confirmation-modal');
                
                document.getElementById('confirm-action-btn').onclick = async () => {
                    closeModal('confirmation-modal');
                    await executeDataImport(true);
                    document.getElementById('confirm-action-btn').onclick = null; // Clean up listener
                };

            } else {
                 await executeDataImport(false);
            }
        }

        async function executeDataImport(replace) {
            showToast("Importing data... Please wait.", "info");
            const batch = writeBatch(db);

            if (replace) {
                // Delete existing data
                Object.keys(localCollection).forEach(id => batch.delete(doc(db, `artifacts/${appId}/users/${userId}/collection`, id)));
                Object.keys(localDecks).forEach(id => batch.delete(doc(db, `artifacts/${appId}/users/${userId}/decks`, id)));
            }

            // Set/Merge new data
            Object.entries(tempImportedData.collection).forEach(([id, cardData]) => {
                const ref = doc(db, `artifacts/${appId}/users/${userId}/collection`, id);
                batch.set(ref, cardData, { merge: !replace });
            });
            Object.entries(tempImportedData.decks).forEach(([id, deckData]) => {
                const ref = doc(db, `artifacts/${appId}/users/${userId}/decks`, id);
                batch.set(ref, deckData, { merge: !replace });
            });

            try {
                await batch.commit();
                showToast(`Data successfully imported (${replace ? 'Replaced' : 'Merged'}).`, "success");
            } catch (error) {
                console.error("Error executing data import:", error);
                showToast("A problem occurred during the import.", "error");
            } finally {
                tempImportedData = null; // Clear temp data
            }
        }


        setupGlobalListeners();

        // Modal logic for View Settings
        function openViewSettingsModal(e) {
          if (e) e.preventDefault();
          document.getElementById('view-settings-modal').classList.remove('hidden');
          syncSavedViewsDropdowns();
        }
        function closeViewSettingsModal() {
          document.getElementById('view-settings-modal').classList.add('hidden');
        }
        const manageViewsLink = document.getElementById('manage-views-link');
        if (manageViewsLink) manageViewsLink.addEventListener('click', openViewSettingsModal);
        const closeModalBtn = document.getElementById('close-view-settings-modal');
        if (closeModalBtn) closeModalBtn.addEventListener('click', closeViewSettingsModal);
        const cancelModalBtn = document.getElementById('cancel-view-settings-modal');
        if (cancelModalBtn) cancelModalBtn.addEventListener('click', closeViewSettingsModal);

        // Advanced settings popover logic
        const advSettingsBtn = document.querySelector('.group > button[aria-label="Show advanced settings"]');
        const advSettingsPopover = advSettingsBtn?.parentElement?.querySelector('.absolute.z-10');
        if (advSettingsBtn && advSettingsPopover) {
          advSettingsBtn.addEventListener('mouseenter', () => {
            advSettingsPopover.classList.remove('hidden');
          });
          advSettingsBtn.addEventListener('mouseleave', () => {
            advSettingsPopover.classList.add('hidden');
          });
          advSettingsPopover.addEventListener('mouseenter', () => {
            advSettingsPopover.classList.remove('hidden');
          });
          advSettingsPopover.addEventListener('mouseleave', () => {
            advSettingsPopover.classList.add('hidden');
          });
        }

        // Sync saved views dropdowns
        function syncSavedViewsDropdowns() {
          const toolbarSelect = document.getElementById('saved-views-select');
          const modalSelect = document.getElementById('modal-saved-views-select');
          if (toolbarSelect && modalSelect) {
            modalSelect.innerHTML = toolbarSelect.innerHTML;
            modalSelect.value = toolbarSelect.value;
          }
        }
      });
    </script>
  </body>
</html>
